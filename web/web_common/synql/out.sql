CREATE TABLE IF NOT EXISTS ranks (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS colors (
    name TEXT UNIQUE NOT NULL,
    hexadecimal_value TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS units (
    name TEXT UNIQUE NOT NULL,
    unit TEXT UNIQUE NOT NULL,
    icon TEXT NOT NULL,
    colors_id SMALLINT NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS team_states (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS taxa (
    id INTEGER PRIMARY KEY UNIQUE,
    name TEXT NOT NULL,
    parent_id INTEGER,
    ranks_id SMALLINT NOT NULL REFERENCES ranks(id)
);
CREATE TABLE IF NOT EXISTS sample_states (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS roles (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS project_states (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS permanence_categories (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS organizations (
    name TEXT NOT NULL,
    url TEXT UNIQUE NOT NULL,
    country TEXT NOT NULL,
    alpha_two_code CountryCode NOT NULL,
    state_province TEXT,
    domain TEXT UNIQUE NOT NULL,
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS observation_subjects (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS materials (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS instrument_states (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS countries (
    iso CountryCode PRIMARY KEY UNIQUE,
    name TEXT UNIQUE NOT NULL
);
/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::CAS
CREATE TYPE CAS;

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_in
CREATE  FUNCTION "cas_in"(
	"input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS CAS /* core::option::Option<cas_codes::CAS> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_in_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_out
CREATE  FUNCTION "cas_out"(
	"input" CAS /* cas_codes::CAS */
) RETURNS cstring /* alloc::ffi::c_str::CString */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_out_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_recv
CREATE  FUNCTION "cas_recv"(
	"internal" internal /* pgrx::datum::internal::Internal */
) RETURNS CAS /* cas_codes::CAS */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_recv_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_send
CREATE  FUNCTION "cas_send"(
	"input" CAS /* cas_codes::CAS */
) RETURNS bytea /* alloc::vec::Vec<u8> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_send_wrapper';


-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::CAS
CREATE TYPE CAS (
	INTERNALLENGTH = variable,
	INPUT = cas_in, /* cas_codes::cas_in */
	OUTPUT = cas_out, /* cas_codes::cas_out */
	RECEIVE = cas_recv, /* cas_codes::cas_recv */
	SEND = cas_send, /* cas_codes::cas_send */
	STORAGE = extended
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_cmp
CREATE  FUNCTION "cas_cmp"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_cmp_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_eq
CREATE  FUNCTION "cas_eq"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_eq_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_eq
CREATE OPERATOR = (
	PROCEDURE="cas_eq",
	LEFTARG=CAS, /* cas_codes::CAS */
	RIGHTARG=CAS, /* cas_codes::CAS */
	COMMUTATOR = =,
	NEGATOR = <>,
	RESTRICT = eqsel,
	JOIN = eqjoinsel,
	HASHES,
	MERGES
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_ge
CREATE  FUNCTION "cas_ge"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_ge_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_ge
CREATE OPERATOR >= (
	PROCEDURE="cas_ge",
	LEFTARG=CAS, /* cas_codes::CAS */
	RIGHTARG=CAS, /* cas_codes::CAS */
	COMMUTATOR = <=,
	NEGATOR = <,
	RESTRICT = scalargesel,
	JOIN = scalargejoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_gt
CREATE  FUNCTION "cas_gt"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_gt_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_gt
CREATE OPERATOR > (
	PROCEDURE="cas_gt",
	LEFTARG=CAS, /* cas_codes::CAS */
	RIGHTARG=CAS, /* cas_codes::CAS */
	COMMUTATOR = <,
	NEGATOR = <=,
	RESTRICT = scalargtsel,
	JOIN = scalargtjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_hash
CREATE  FUNCTION "cas_hash"(
	"value" CAS /* cas_codes::CAS */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_hash_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_le
CREATE  FUNCTION "cas_le"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_le_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_le
CREATE OPERATOR <= (
	PROCEDURE="cas_le",
	LEFTARG=CAS, /* cas_codes::CAS */
	RIGHTARG=CAS, /* cas_codes::CAS */
	COMMUTATOR = >=,
	NEGATOR = >,
	RESTRICT = scalarlesel,
	JOIN = scalarlejoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_lt
CREATE  FUNCTION "cas_lt"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_lt_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_lt
CREATE OPERATOR < (
	PROCEDURE="cas_lt",
	LEFTARG=CAS, /* cas_codes::CAS */
	RIGHTARG=CAS, /* cas_codes::CAS */
	COMMUTATOR = >,
	NEGATOR = >=,
	RESTRICT = scalarltsel,
	JOIN = scalarltjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_ne
CREATE  FUNCTION "cas_ne"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_ne_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_ne
CREATE OPERATOR <> (
	PROCEDURE="cas_ne",
	LEFTARG=CAS, /* cas_codes::CAS */
	RIGHTARG=CAS, /* cas_codes::CAS */
	COMMUTATOR = <>,
	NEGATOR = =,
	RESTRICT = neqsel,
	JOIN = neqjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::CAS
CREATE OPERATOR FAMILY CAS_btree_ops USING btree;
CREATE OPERATOR CLASS CAS_btree_ops DEFAULT FOR TYPE CAS USING btree FAMILY CAS_btree_ops AS
	OPERATOR 1 <,
	OPERATOR 2 <=,
	OPERATOR 3 =,
	OPERATOR 4 >=,
	OPERATOR 5 >,
	FUNCTION 1 cas_cmp(CAS, CAS);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::CAS
CREATE OPERATOR FAMILY CAS_hash_ops USING hash;
CREATE OPERATOR CLASS CAS_hash_ops DEFAULT FOR TYPE CAS USING hash FAMILY CAS_hash_ops AS
	OPERATOR    1   =  (CAS, CAS),
	FUNCTION    1   cas_hash(CAS);
/* </end connected objects> */

/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/actinium.rs:4
-- elements::isotopes::actinium::ActiniumIsotope
CREATE TYPE ActiniumIsotope AS ENUM (
	'Ac206',
	'Ac207',
	'Ac208',
	'Ac209',
	'Ac210',
	'Ac211',
	'Ac212',
	'Ac213',
	'Ac214',
	'Ac215',
	'Ac216',
	'Ac217',
	'Ac218',
	'Ac219',
	'Ac220',
	'Ac221',
	'Ac222',
	'Ac223',
	'Ac224',
	'Ac225',
	'Ac226',
	'Ac227',
	'Ac228',
	'Ac229',
	'Ac230',
	'Ac231',
	'Ac232',
	'Ac233',
	'Ac234',
	'Ac235',
	'Ac236',
	'Ac237'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/aluminium.rs:4
-- elements::isotopes::aluminium::AluminiumIsotope
CREATE TYPE AluminiumIsotope AS ENUM (
	'Al21',
	'Al22',
	'Al23',
	'Al24',
	'Al25',
	'Al26',
	'Al27',
	'Al28',
	'Al29',
	'Al30',
	'Al31',
	'Al32',
	'Al33',
	'Al34',
	'Al35',
	'Al36',
	'Al37',
	'Al38',
	'Al39',
	'Al40',
	'Al41',
	'Al42',
	'Al43'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/americium.rs:4
-- elements::isotopes::americium::AmericiumIsotope
CREATE TYPE AmericiumIsotope AS ENUM (
	'Am230',
	'Am231',
	'Am232',
	'Am233',
	'Am234',
	'Am235',
	'Am236',
	'Am237',
	'Am238',
	'Am239',
	'Am240',
	'Am241',
	'Am242',
	'Am243',
	'Am244',
	'Am245',
	'Am246',
	'Am247',
	'Am248',
	'Am249'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/antimony.rs:4
-- elements::isotopes::antimony::AntimonyIsotope
CREATE TYPE AntimonyIsotope AS ENUM (
	'Sb103',
	'Sb104',
	'Sb105',
	'Sb106',
	'Sb107',
	'Sb108',
	'Sb109',
	'Sb110',
	'Sb111',
	'Sb112',
	'Sb113',
	'Sb114',
	'Sb115',
	'Sb116',
	'Sb117',
	'Sb118',
	'Sb119',
	'Sb120',
	'Sb121',
	'Sb122',
	'Sb123',
	'Sb124',
	'Sb125',
	'Sb126',
	'Sb127',
	'Sb128',
	'Sb129',
	'Sb130',
	'Sb131',
	'Sb132',
	'Sb133',
	'Sb134',
	'Sb135',
	'Sb136',
	'Sb137',
	'Sb138',
	'Sb139',
	'Sb140'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/argon.rs:4
-- elements::isotopes::argon::ArgonIsotope
CREATE TYPE ArgonIsotope AS ENUM (
	'Ar30',
	'Ar31',
	'Ar32',
	'Ar33',
	'Ar34',
	'Ar35',
	'Ar36',
	'Ar37',
	'Ar38',
	'Ar39',
	'Ar40',
	'Ar41',
	'Ar42',
	'Ar43',
	'Ar44',
	'Ar45',
	'Ar46',
	'Ar47',
	'Ar48',
	'Ar49',
	'Ar50',
	'Ar51',
	'Ar52',
	'Ar53'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/arsenic.rs:4
-- elements::isotopes::arsenic::ArsenicIsotope
CREATE TYPE ArsenicIsotope AS ENUM (
	'As60',
	'As61',
	'As62',
	'As63',
	'As64',
	'As65',
	'As66',
	'As67',
	'As68',
	'As69',
	'As70',
	'As71',
	'As72',
	'As73',
	'As74',
	'As75',
	'As76',
	'As77',
	'As78',
	'As79',
	'As80',
	'As81',
	'As82',
	'As83',
	'As84',
	'As85',
	'As86',
	'As87',
	'As88',
	'As89',
	'As90',
	'As91',
	'As92'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/astatine.rs:4
-- elements::isotopes::astatine::AstatineIsotope
CREATE TYPE AstatineIsotope AS ENUM (
	'At191',
	'At192',
	'At193',
	'At194',
	'At195',
	'At196',
	'At197',
	'At198',
	'At199',
	'At200',
	'At201',
	'At202',
	'At203',
	'At204',
	'At205',
	'At206',
	'At207',
	'At208',
	'At209',
	'At210',
	'At211',
	'At212',
	'At213',
	'At214',
	'At215',
	'At216',
	'At217',
	'At218',
	'At219',
	'At220',
	'At221',
	'At222',
	'At223',
	'At224',
	'At225',
	'At226',
	'At227',
	'At228',
	'At229'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/barium.rs:4
-- elements::isotopes::barium::BariumIsotope
CREATE TYPE BariumIsotope AS ENUM (
	'Ba114',
	'Ba115',
	'Ba116',
	'Ba117',
	'Ba118',
	'Ba119',
	'Ba120',
	'Ba121',
	'Ba122',
	'Ba123',
	'Ba124',
	'Ba125',
	'Ba126',
	'Ba127',
	'Ba128',
	'Ba129',
	'Ba130',
	'Ba131',
	'Ba132',
	'Ba133',
	'Ba134',
	'Ba135',
	'Ba136',
	'Ba137',
	'Ba138',
	'Ba139',
	'Ba140',
	'Ba141',
	'Ba142',
	'Ba143',
	'Ba144',
	'Ba145',
	'Ba146',
	'Ba147',
	'Ba148',
	'Ba149',
	'Ba150',
	'Ba151',
	'Ba152',
	'Ba153'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/berkelium.rs:4
-- elements::isotopes::berkelium::BerkeliumIsotope
CREATE TYPE BerkeliumIsotope AS ENUM (
	'Bk234',
	'Bk235',
	'Bk236',
	'Bk237',
	'Bk238',
	'Bk239',
	'Bk240',
	'Bk241',
	'Bk242',
	'Bk243',
	'Bk244',
	'Bk245',
	'Bk246',
	'Bk247',
	'Bk248',
	'Bk249',
	'Bk250',
	'Bk251',
	'Bk252',
	'Bk253',
	'Bk254'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/beryllium.rs:4
-- elements::isotopes::beryllium::BerylliumIsotope
CREATE TYPE BerylliumIsotope AS ENUM (
	'Be5',
	'Be6',
	'Be7',
	'Be8',
	'Be9',
	'Be10',
	'Be11',
	'Be12',
	'Be13',
	'Be14',
	'Be15',
	'Be16'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/bismuth.rs:4
-- elements::isotopes::bismuth::BismuthIsotope
CREATE TYPE BismuthIsotope AS ENUM (
	'Bi184',
	'Bi185',
	'Bi186',
	'Bi187',
	'Bi188',
	'Bi189',
	'Bi190',
	'Bi191',
	'Bi192',
	'Bi193',
	'Bi194',
	'Bi195',
	'Bi196',
	'Bi197',
	'Bi198',
	'Bi199',
	'Bi200',
	'Bi201',
	'Bi202',
	'Bi203',
	'Bi204',
	'Bi205',
	'Bi206',
	'Bi207',
	'Bi208',
	'Bi209',
	'Bi210',
	'Bi211',
	'Bi212',
	'Bi213',
	'Bi214',
	'Bi215',
	'Bi216',
	'Bi217',
	'Bi218',
	'Bi219',
	'Bi220',
	'Bi221',
	'Bi222',
	'Bi223',
	'Bi224'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/bohrium.rs:4
-- elements::isotopes::bohrium::BohriumIsotope
CREATE TYPE BohriumIsotope AS ENUM (
	'Bh260',
	'Bh261',
	'Bh262',
	'Bh263',
	'Bh264',
	'Bh265',
	'Bh266',
	'Bh267',
	'Bh268',
	'Bh269',
	'Bh270',
	'Bh271',
	'Bh272',
	'Bh273',
	'Bh274',
	'Bh275'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/boron.rs:4
-- elements::isotopes::boron::BoronIsotope
CREATE TYPE BoronIsotope AS ENUM (
	'B6',
	'B7',
	'B8',
	'B9',
	'B10',
	'B11',
	'B12',
	'B13',
	'B14',
	'B15',
	'B16',
	'B17',
	'B18',
	'B19',
	'B20',
	'B21'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/bromine.rs:4
-- elements::isotopes::bromine::BromineIsotope
CREATE TYPE BromineIsotope AS ENUM (
	'Br67',
	'Br68',
	'Br69',
	'Br70',
	'Br71',
	'Br72',
	'Br73',
	'Br74',
	'Br75',
	'Br76',
	'Br77',
	'Br78',
	'Br79',
	'Br80',
	'Br81',
	'Br82',
	'Br83',
	'Br84',
	'Br85',
	'Br86',
	'Br87',
	'Br88',
	'Br89',
	'Br90',
	'Br91',
	'Br92',
	'Br93',
	'Br94',
	'Br95',
	'Br96',
	'Br97',
	'Br98'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/cadmium.rs:4
-- elements::isotopes::cadmium::CadmiumIsotope
CREATE TYPE CadmiumIsotope AS ENUM (
	'Cd95',
	'Cd96',
	'Cd97',
	'Cd98',
	'Cd99',
	'Cd100',
	'Cd101',
	'Cd102',
	'Cd103',
	'Cd104',
	'Cd105',
	'Cd106',
	'Cd107',
	'Cd108',
	'Cd109',
	'Cd110',
	'Cd111',
	'Cd112',
	'Cd113',
	'Cd114',
	'Cd115',
	'Cd116',
	'Cd117',
	'Cd118',
	'Cd119',
	'Cd120',
	'Cd121',
	'Cd122',
	'Cd123',
	'Cd124',
	'Cd125',
	'Cd126',
	'Cd127',
	'Cd128',
	'Cd129',
	'Cd130',
	'Cd131',
	'Cd132',
	'Cd133'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/caesium.rs:4
-- elements::isotopes::caesium::CaesiumIsotope
CREATE TYPE CaesiumIsotope AS ENUM (
	'Cs112',
	'Cs113',
	'Cs114',
	'Cs115',
	'Cs116',
	'Cs117',
	'Cs118',
	'Cs119',
	'Cs120',
	'Cs121',
	'Cs122',
	'Cs123',
	'Cs124',
	'Cs125',
	'Cs126',
	'Cs127',
	'Cs128',
	'Cs129',
	'Cs130',
	'Cs131',
	'Cs132',
	'Cs133',
	'Cs134',
	'Cs135',
	'Cs136',
	'Cs137',
	'Cs138',
	'Cs139',
	'Cs140',
	'Cs141',
	'Cs142',
	'Cs143',
	'Cs144',
	'Cs145',
	'Cs146',
	'Cs147',
	'Cs148',
	'Cs149',
	'Cs150',
	'Cs151'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/calcium.rs:4
-- elements::isotopes::calcium::CalciumIsotope
CREATE TYPE CalciumIsotope AS ENUM (
	'Ca34',
	'Ca35',
	'Ca36',
	'Ca37',
	'Ca38',
	'Ca39',
	'Ca40',
	'Ca41',
	'Ca42',
	'Ca43',
	'Ca44',
	'Ca45',
	'Ca46',
	'Ca47',
	'Ca48',
	'Ca49',
	'Ca50',
	'Ca51',
	'Ca52',
	'Ca53',
	'Ca54',
	'Ca55',
	'Ca56',
	'Ca57',
	'Ca58'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/californium.rs:4
-- elements::isotopes::californium::CaliforniumIsotope
CREATE TYPE CaliforniumIsotope AS ENUM (
	'Cf237',
	'Cf238',
	'Cf239',
	'Cf240',
	'Cf241',
	'Cf242',
	'Cf243',
	'Cf244',
	'Cf245',
	'Cf246',
	'Cf247',
	'Cf248',
	'Cf249',
	'Cf250',
	'Cf251',
	'Cf252',
	'Cf253',
	'Cf254',
	'Cf255',
	'Cf256'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/carbon.rs:4
-- elements::isotopes::carbon::CarbonIsotope
CREATE TYPE CarbonIsotope AS ENUM (
	'C8',
	'C9',
	'C10',
	'C11',
	'C12',
	'C13',
	'C14',
	'C15',
	'C16',
	'C17',
	'C18',
	'C19',
	'C20',
	'C21',
	'C22',
	'C23'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/cerium.rs:4
-- elements::isotopes::cerium::CeriumIsotope
CREATE TYPE CeriumIsotope AS ENUM (
	'Ce119',
	'Ce120',
	'Ce121',
	'Ce122',
	'Ce123',
	'Ce124',
	'Ce125',
	'Ce126',
	'Ce127',
	'Ce128',
	'Ce129',
	'Ce130',
	'Ce131',
	'Ce132',
	'Ce133',
	'Ce134',
	'Ce135',
	'Ce136',
	'Ce137',
	'Ce138',
	'Ce139',
	'Ce140',
	'Ce141',
	'Ce142',
	'Ce143',
	'Ce144',
	'Ce145',
	'Ce146',
	'Ce147',
	'Ce148',
	'Ce149',
	'Ce150',
	'Ce151',
	'Ce152',
	'Ce153',
	'Ce154',
	'Ce155',
	'Ce156',
	'Ce157'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/chlorine.rs:4
-- elements::isotopes::chlorine::ChlorineIsotope
CREATE TYPE ChlorineIsotope AS ENUM (
	'Cl28',
	'Cl29',
	'Cl30',
	'Cl31',
	'Cl32',
	'Cl33',
	'Cl34',
	'Cl35',
	'Cl36',
	'Cl37',
	'Cl38',
	'Cl39',
	'Cl40',
	'Cl41',
	'Cl42',
	'Cl43',
	'Cl44',
	'Cl45',
	'Cl46',
	'Cl47',
	'Cl48',
	'Cl49',
	'Cl50',
	'Cl51'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/chromium.rs:4
-- elements::isotopes::chromium::ChromiumIsotope
CREATE TYPE ChromiumIsotope AS ENUM (
	'Cr42',
	'Cr43',
	'Cr44',
	'Cr45',
	'Cr46',
	'Cr47',
	'Cr48',
	'Cr49',
	'Cr50',
	'Cr51',
	'Cr52',
	'Cr53',
	'Cr54',
	'Cr55',
	'Cr56',
	'Cr57',
	'Cr58',
	'Cr59',
	'Cr60',
	'Cr61',
	'Cr62',
	'Cr63',
	'Cr64',
	'Cr65',
	'Cr66',
	'Cr67',
	'Cr68'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/cobalt.rs:4
-- elements::isotopes::cobalt::CobaltIsotope
CREATE TYPE CobaltIsotope AS ENUM (
	'Co47',
	'Co48',
	'Co49',
	'Co50',
	'Co51',
	'Co52',
	'Co53',
	'Co54',
	'Co55',
	'Co56',
	'Co57',
	'Co58',
	'Co59',
	'Co60',
	'Co61',
	'Co62',
	'Co63',
	'Co64',
	'Co65',
	'Co66',
	'Co67',
	'Co68',
	'Co69',
	'Co70',
	'Co71',
	'Co72',
	'Co73',
	'Co74',
	'Co75',
	'Co76'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/copernicium.rs:4
-- elements::isotopes::copernicium::CoperniciumIsotope
CREATE TYPE CoperniciumIsotope AS ENUM (
	'Cn276',
	'Cn277',
	'Cn278',
	'Cn279',
	'Cn280',
	'Cn281',
	'Cn282',
	'Cn283',
	'Cn284',
	'Cn285'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/copper.rs:4
-- elements::isotopes::copper::CopperIsotope
CREATE TYPE CopperIsotope AS ENUM (
	'Cu52',
	'Cu53',
	'Cu54',
	'Cu55',
	'Cu56',
	'Cu57',
	'Cu58',
	'Cu59',
	'Cu60',
	'Cu61',
	'Cu62',
	'Cu63',
	'Cu64',
	'Cu65',
	'Cu66',
	'Cu67',
	'Cu68',
	'Cu69',
	'Cu70',
	'Cu71',
	'Cu72',
	'Cu73',
	'Cu74',
	'Cu75',
	'Cu76',
	'Cu77',
	'Cu78',
	'Cu79',
	'Cu80',
	'Cu81',
	'Cu82'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/curium.rs:4
-- elements::isotopes::curium::CuriumIsotope
CREATE TYPE CuriumIsotope AS ENUM (
	'Cm232',
	'Cm233',
	'Cm234',
	'Cm235',
	'Cm236',
	'Cm237',
	'Cm238',
	'Cm239',
	'Cm240',
	'Cm241',
	'Cm242',
	'Cm243',
	'Cm244',
	'Cm245',
	'Cm246',
	'Cm247',
	'Cm248',
	'Cm249',
	'Cm250',
	'Cm251',
	'Cm252'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/darmstadtium.rs:4
-- elements::isotopes::darmstadtium::DarmstadtiumIsotope
CREATE TYPE DarmstadtiumIsotope AS ENUM (
	'Ds267',
	'Ds268',
	'Ds269',
	'Ds270',
	'Ds271',
	'Ds272',
	'Ds273',
	'Ds274',
	'Ds275',
	'Ds276',
	'Ds277',
	'Ds278',
	'Ds279',
	'Ds280',
	'Ds281'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/dubnium.rs:4
-- elements::isotopes::dubnium::DubniumIsotope
CREATE TYPE DubniumIsotope AS ENUM (
	'Db255',
	'Db256',
	'Db257',
	'Db258',
	'Db259',
	'Db260',
	'Db261',
	'Db262',
	'Db263',
	'Db264',
	'Db265',
	'Db266',
	'Db267',
	'Db268',
	'Db269',
	'Db270'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/dysprosium.rs:4
-- elements::isotopes::dysprosium::DysprosiumIsotope
CREATE TYPE DysprosiumIsotope AS ENUM (
	'Dy138',
	'Dy139',
	'Dy140',
	'Dy141',
	'Dy142',
	'Dy143',
	'Dy144',
	'Dy145',
	'Dy146',
	'Dy147',
	'Dy148',
	'Dy149',
	'Dy150',
	'Dy151',
	'Dy152',
	'Dy153',
	'Dy154',
	'Dy155',
	'Dy156',
	'Dy157',
	'Dy158',
	'Dy159',
	'Dy160',
	'Dy161',
	'Dy162',
	'Dy163',
	'Dy164',
	'Dy165',
	'Dy166',
	'Dy167',
	'Dy168',
	'Dy169',
	'Dy170',
	'Dy171',
	'Dy172',
	'Dy173'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/einsteinium.rs:4
-- elements::isotopes::einsteinium::EinsteiniumIsotope
CREATE TYPE EinsteiniumIsotope AS ENUM (
	'Es239',
	'Es240',
	'Es241',
	'Es242',
	'Es243',
	'Es244',
	'Es245',
	'Es246',
	'Es247',
	'Es248',
	'Es249',
	'Es250',
	'Es251',
	'Es252',
	'Es253',
	'Es254',
	'Es255',
	'Es256',
	'Es257',
	'Es258'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/erbium.rs:4
-- elements::isotopes::erbium::ErbiumIsotope
CREATE TYPE ErbiumIsotope AS ENUM (
	'Er142',
	'Er143',
	'Er144',
	'Er145',
	'Er146',
	'Er147',
	'Er148',
	'Er149',
	'Er150',
	'Er151',
	'Er152',
	'Er153',
	'Er154',
	'Er155',
	'Er156',
	'Er157',
	'Er158',
	'Er159',
	'Er160',
	'Er161',
	'Er162',
	'Er163',
	'Er164',
	'Er165',
	'Er166',
	'Er167',
	'Er168',
	'Er169',
	'Er170',
	'Er171',
	'Er172',
	'Er173',
	'Er174',
	'Er175',
	'Er176',
	'Er177'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/europium.rs:4
-- elements::isotopes::europium::EuropiumIsotope
CREATE TYPE EuropiumIsotope AS ENUM (
	'Eu130',
	'Eu131',
	'Eu132',
	'Eu133',
	'Eu134',
	'Eu135',
	'Eu136',
	'Eu137',
	'Eu138',
	'Eu139',
	'Eu140',
	'Eu141',
	'Eu142',
	'Eu143',
	'Eu144',
	'Eu145',
	'Eu146',
	'Eu147',
	'Eu148',
	'Eu149',
	'Eu150',
	'Eu151',
	'Eu152',
	'Eu153',
	'Eu154',
	'Eu155',
	'Eu156',
	'Eu157',
	'Eu158',
	'Eu159',
	'Eu160',
	'Eu161',
	'Eu162',
	'Eu163',
	'Eu164',
	'Eu165',
	'Eu166',
	'Eu167'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/fermium.rs:4
-- elements::isotopes::fermium::FermiumIsotope
CREATE TYPE FermiumIsotope AS ENUM (
	'Fm241',
	'Fm242',
	'Fm243',
	'Fm244',
	'Fm245',
	'Fm246',
	'Fm247',
	'Fm248',
	'Fm249',
	'Fm250',
	'Fm251',
	'Fm252',
	'Fm253',
	'Fm254',
	'Fm255',
	'Fm256',
	'Fm257',
	'Fm258',
	'Fm259',
	'Fm260'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/flerovium.rs:4
-- elements::isotopes::flerovium::FleroviumIsotope
CREATE TYPE FleroviumIsotope AS ENUM (
	'Fl285',
	'Fl286',
	'Fl287',
	'Fl288',
	'Fl289'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/fluorine.rs:4
-- elements::isotopes::fluorine::FluorineIsotope
CREATE TYPE FluorineIsotope AS ENUM (
	'F14',
	'F15',
	'F16',
	'F17',
	'F18',
	'F19',
	'F20',
	'F21',
	'F22',
	'F23',
	'F24',
	'F25',
	'F26',
	'F27',
	'F28',
	'F29',
	'F30',
	'F31'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/francium.rs:4
-- elements::isotopes::francium::FranciumIsotope
CREATE TYPE FranciumIsotope AS ENUM (
	'Fr199',
	'Fr200',
	'Fr201',
	'Fr202',
	'Fr203',
	'Fr204',
	'Fr205',
	'Fr206',
	'Fr207',
	'Fr208',
	'Fr209',
	'Fr210',
	'Fr211',
	'Fr212',
	'Fr213',
	'Fr214',
	'Fr215',
	'Fr216',
	'Fr217',
	'Fr218',
	'Fr219',
	'Fr220',
	'Fr221',
	'Fr222',
	'Fr223',
	'Fr224',
	'Fr225',
	'Fr226',
	'Fr227',
	'Fr228',
	'Fr229',
	'Fr230',
	'Fr231',
	'Fr232',
	'Fr233'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/gadolinium.rs:4
-- elements::isotopes::gadolinium::GadoliniumIsotope
CREATE TYPE GadoliniumIsotope AS ENUM (
	'Gd133',
	'Gd134',
	'Gd135',
	'Gd136',
	'Gd137',
	'Gd138',
	'Gd139',
	'Gd140',
	'Gd141',
	'Gd142',
	'Gd143',
	'Gd144',
	'Gd145',
	'Gd146',
	'Gd147',
	'Gd148',
	'Gd149',
	'Gd150',
	'Gd151',
	'Gd152',
	'Gd153',
	'Gd154',
	'Gd155',
	'Gd156',
	'Gd157',
	'Gd158',
	'Gd159',
	'Gd160',
	'Gd161',
	'Gd162',
	'Gd163',
	'Gd164',
	'Gd165',
	'Gd166',
	'Gd167',
	'Gd168',
	'Gd169'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/gallium.rs:4
-- elements::isotopes::gallium::GalliumIsotope
CREATE TYPE GalliumIsotope AS ENUM (
	'Ga56',
	'Ga57',
	'Ga58',
	'Ga59',
	'Ga60',
	'Ga61',
	'Ga62',
	'Ga63',
	'Ga64',
	'Ga65',
	'Ga66',
	'Ga67',
	'Ga68',
	'Ga69',
	'Ga70',
	'Ga71',
	'Ga72',
	'Ga73',
	'Ga74',
	'Ga75',
	'Ga76',
	'Ga77',
	'Ga78',
	'Ga79',
	'Ga80',
	'Ga81',
	'Ga82',
	'Ga83',
	'Ga84',
	'Ga85',
	'Ga86',
	'Ga87'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/germanium.rs:4
-- elements::isotopes::germanium::GermaniumIsotope
CREATE TYPE GermaniumIsotope AS ENUM (
	'Ge58',
	'Ge59',
	'Ge60',
	'Ge61',
	'Ge62',
	'Ge63',
	'Ge64',
	'Ge65',
	'Ge66',
	'Ge67',
	'Ge68',
	'Ge69',
	'Ge70',
	'Ge71',
	'Ge72',
	'Ge73',
	'Ge74',
	'Ge75',
	'Ge76',
	'Ge77',
	'Ge78',
	'Ge79',
	'Ge80',
	'Ge81',
	'Ge82',
	'Ge83',
	'Ge84',
	'Ge85',
	'Ge86',
	'Ge87',
	'Ge88',
	'Ge89',
	'Ge90'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/gold.rs:4
-- elements::isotopes::gold::GoldIsotope
CREATE TYPE GoldIsotope AS ENUM (
	'Au169',
	'Au170',
	'Au171',
	'Au172',
	'Au173',
	'Au174',
	'Au175',
	'Au176',
	'Au177',
	'Au178',
	'Au179',
	'Au180',
	'Au181',
	'Au182',
	'Au183',
	'Au184',
	'Au185',
	'Au186',
	'Au187',
	'Au188',
	'Au189',
	'Au190',
	'Au191',
	'Au192',
	'Au193',
	'Au194',
	'Au195',
	'Au196',
	'Au197',
	'Au198',
	'Au199',
	'Au200',
	'Au201',
	'Au202',
	'Au203',
	'Au204',
	'Au205',
	'Au206',
	'Au207',
	'Au208',
	'Au209',
	'Au210'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/hafnium.rs:4
-- elements::isotopes::hafnium::HafniumIsotope
CREATE TYPE HafniumIsotope AS ENUM (
	'Hf153',
	'Hf154',
	'Hf155',
	'Hf156',
	'Hf157',
	'Hf158',
	'Hf159',
	'Hf160',
	'Hf161',
	'Hf162',
	'Hf163',
	'Hf164',
	'Hf165',
	'Hf166',
	'Hf167',
	'Hf168',
	'Hf169',
	'Hf170',
	'Hf171',
	'Hf172',
	'Hf173',
	'Hf174',
	'Hf175',
	'Hf176',
	'Hf177',
	'Hf178',
	'Hf179',
	'Hf180',
	'Hf181',
	'Hf182',
	'Hf183',
	'Hf184',
	'Hf185',
	'Hf186',
	'Hf187',
	'Hf188',
	'Hf189'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/hassium.rs:4
-- elements::isotopes::hassium::HassiumIsotope
CREATE TYPE HassiumIsotope AS ENUM (
	'Hs263',
	'Hs264',
	'Hs265',
	'Hs266',
	'Hs267',
	'Hs268',
	'Hs269',
	'Hs270',
	'Hs271',
	'Hs272',
	'Hs273',
	'Hs274',
	'Hs275',
	'Hs276',
	'Hs277'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/helium.rs:4
-- elements::isotopes::helium::HeliumIsotope
CREATE TYPE HeliumIsotope AS ENUM (
	'He3',
	'He4',
	'He5',
	'He6',
	'He7',
	'He8',
	'He9',
	'He10'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/holmium.rs:4
-- elements::isotopes::holmium::HolmiumIsotope
CREATE TYPE HolmiumIsotope AS ENUM (
	'Ho140',
	'Ho141',
	'Ho142',
	'Ho143',
	'Ho144',
	'Ho145',
	'Ho146',
	'Ho147',
	'Ho148',
	'Ho149',
	'Ho150',
	'Ho151',
	'Ho152',
	'Ho153',
	'Ho154',
	'Ho155',
	'Ho156',
	'Ho157',
	'Ho158',
	'Ho159',
	'Ho160',
	'Ho161',
	'Ho162',
	'Ho163',
	'Ho164',
	'Ho165',
	'Ho166',
	'Ho167',
	'Ho168',
	'Ho169',
	'Ho170',
	'Ho171',
	'Ho172',
	'Ho173',
	'Ho174',
	'Ho175'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/hydrogen.rs:4
-- elements::isotopes::hydrogen::HydrogenIsotope
CREATE TYPE HydrogenIsotope AS ENUM (
	'H1',
	'D2',
	'T3',
	'H4',
	'H5',
	'H6',
	'H7'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/indium.rs:4
-- elements::isotopes::indium::IndiumIsotope
CREATE TYPE IndiumIsotope AS ENUM (
	'In97',
	'In98',
	'In99',
	'In100',
	'In101',
	'In102',
	'In103',
	'In104',
	'In105',
	'In106',
	'In107',
	'In108',
	'In109',
	'In110',
	'In111',
	'In112',
	'In113',
	'In114',
	'In115',
	'In116',
	'In117',
	'In118',
	'In119',
	'In120',
	'In121',
	'In122',
	'In123',
	'In124',
	'In125',
	'In126',
	'In127',
	'In128',
	'In129',
	'In130',
	'In131',
	'In132',
	'In133',
	'In134',
	'In135'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/iodine.rs:4
-- elements::isotopes::iodine::IodineIsotope
CREATE TYPE IodineIsotope AS ENUM (
	'I107',
	'I108',
	'I109',
	'I110',
	'I111',
	'I112',
	'I113',
	'I114',
	'I115',
	'I116',
	'I117',
	'I118',
	'I119',
	'I120',
	'I121',
	'I122',
	'I123',
	'I124',
	'I125',
	'I126',
	'I127',
	'I128',
	'I129',
	'I130',
	'I131',
	'I132',
	'I133',
	'I134',
	'I135',
	'I136',
	'I137',
	'I138',
	'I139',
	'I140',
	'I141',
	'I142',
	'I143',
	'I144',
	'I145'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/iridium.rs:4
-- elements::isotopes::iridium::IridiumIsotope
CREATE TYPE IridiumIsotope AS ENUM (
	'Ir164',
	'Ir165',
	'Ir166',
	'Ir167',
	'Ir168',
	'Ir169',
	'Ir170',
	'Ir171',
	'Ir172',
	'Ir173',
	'Ir174',
	'Ir175',
	'Ir176',
	'Ir177',
	'Ir178',
	'Ir179',
	'Ir180',
	'Ir181',
	'Ir182',
	'Ir183',
	'Ir184',
	'Ir185',
	'Ir186',
	'Ir187',
	'Ir188',
	'Ir189',
	'Ir190',
	'Ir191',
	'Ir192',
	'Ir193',
	'Ir194',
	'Ir195',
	'Ir196',
	'Ir197',
	'Ir198',
	'Ir199',
	'Ir200',
	'Ir201',
	'Ir202',
	'Ir203',
	'Ir204'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/iron.rs:4
-- elements::isotopes::iron::IronIsotope
CREATE TYPE IronIsotope AS ENUM (
	'Fe45',
	'Fe46',
	'Fe47',
	'Fe48',
	'Fe49',
	'Fe50',
	'Fe51',
	'Fe52',
	'Fe53',
	'Fe54',
	'Fe55',
	'Fe56',
	'Fe57',
	'Fe58',
	'Fe59',
	'Fe60',
	'Fe61',
	'Fe62',
	'Fe63',
	'Fe64',
	'Fe65',
	'Fe66',
	'Fe67',
	'Fe68',
	'Fe69',
	'Fe70',
	'Fe71',
	'Fe72',
	'Fe73',
	'Fe74'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/krypton.rs:4
-- elements::isotopes::krypton::KryptonIsotope
CREATE TYPE KryptonIsotope AS ENUM (
	'Kr69',
	'Kr70',
	'Kr71',
	'Kr72',
	'Kr73',
	'Kr74',
	'Kr75',
	'Kr76',
	'Kr77',
	'Kr78',
	'Kr79',
	'Kr80',
	'Kr81',
	'Kr82',
	'Kr83',
	'Kr84',
	'Kr85',
	'Kr86',
	'Kr87',
	'Kr88',
	'Kr89',
	'Kr90',
	'Kr91',
	'Kr92',
	'Kr93',
	'Kr94',
	'Kr95',
	'Kr96',
	'Kr97',
	'Kr98',
	'Kr99',
	'Kr100',
	'Kr101'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/lanthanum.rs:4
-- elements::isotopes::lanthanum::LanthanumIsotope
CREATE TYPE LanthanumIsotope AS ENUM (
	'La116',
	'La117',
	'La118',
	'La119',
	'La120',
	'La121',
	'La122',
	'La123',
	'La124',
	'La125',
	'La126',
	'La127',
	'La128',
	'La129',
	'La130',
	'La131',
	'La132',
	'La133',
	'La134',
	'La135',
	'La136',
	'La137',
	'La138',
	'La139',
	'La140',
	'La141',
	'La142',
	'La143',
	'La144',
	'La145',
	'La146',
	'La147',
	'La148',
	'La149',
	'La150',
	'La151',
	'La152',
	'La153',
	'La154',
	'La155'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/lawrencium.rs:4
-- elements::isotopes::lawrencium::LawrenciumIsotope
CREATE TYPE LawrenciumIsotope AS ENUM (
	'Lr251',
	'Lr252',
	'Lr253',
	'Lr254',
	'Lr255',
	'Lr256',
	'Lr257',
	'Lr258',
	'Lr259',
	'Lr260',
	'Lr261',
	'Lr262',
	'Lr263',
	'Lr264',
	'Lr265',
	'Lr266'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/lead.rs:4
-- elements::isotopes::lead::LeadIsotope
CREATE TYPE LeadIsotope AS ENUM (
	'Pb178',
	'Pb179',
	'Pb180',
	'Pb181',
	'Pb182',
	'Pb183',
	'Pb184',
	'Pb185',
	'Pb186',
	'Pb187',
	'Pb188',
	'Pb189',
	'Pb190',
	'Pb191',
	'Pb192',
	'Pb193',
	'Pb194',
	'Pb195',
	'Pb196',
	'Pb197',
	'Pb198',
	'Pb199',
	'Pb200',
	'Pb201',
	'Pb202',
	'Pb203',
	'Pb204',
	'Pb205',
	'Pb206',
	'Pb207',
	'Pb208',
	'Pb209',
	'Pb210',
	'Pb211',
	'Pb212',
	'Pb213',
	'Pb214',
	'Pb215',
	'Pb216',
	'Pb217',
	'Pb218',
	'Pb219',
	'Pb220'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/lithium.rs:4
-- elements::isotopes::lithium::LithiumIsotope
CREATE TYPE LithiumIsotope AS ENUM (
	'Li3',
	'Li4',
	'Li5',
	'Li6',
	'Li7',
	'Li8',
	'Li9',
	'Li10',
	'Li11',
	'Li12',
	'Li13'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/livermorium.rs:4
-- elements::isotopes::livermorium::LivermoriumIsotope
CREATE TYPE LivermoriumIsotope AS ENUM (
	'Lv289',
	'Lv290',
	'Lv291',
	'Lv292',
	'Lv293'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/lutetium.rs:4
-- elements::isotopes::lutetium::LutetiumIsotope
CREATE TYPE LutetiumIsotope AS ENUM (
	'Lu150',
	'Lu151',
	'Lu152',
	'Lu153',
	'Lu154',
	'Lu155',
	'Lu156',
	'Lu157',
	'Lu158',
	'Lu159',
	'Lu160',
	'Lu161',
	'Lu162',
	'Lu163',
	'Lu164',
	'Lu165',
	'Lu166',
	'Lu167',
	'Lu168',
	'Lu169',
	'Lu170',
	'Lu171',
	'Lu172',
	'Lu173',
	'Lu174',
	'Lu175',
	'Lu176',
	'Lu177',
	'Lu178',
	'Lu179',
	'Lu180',
	'Lu181',
	'Lu182',
	'Lu183',
	'Lu184',
	'Lu185'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/magnesium.rs:4
-- elements::isotopes::magnesium::MagnesiumIsotope
CREATE TYPE MagnesiumIsotope AS ENUM (
	'Mg19',
	'Mg20',
	'Mg21',
	'Mg22',
	'Mg23',
	'Mg24',
	'Mg25',
	'Mg26',
	'Mg27',
	'Mg28',
	'Mg29',
	'Mg30',
	'Mg31',
	'Mg32',
	'Mg33',
	'Mg34',
	'Mg35',
	'Mg36',
	'Mg37',
	'Mg38',
	'Mg39',
	'Mg40'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/manganese.rs:4
-- elements::isotopes::manganese::ManganeseIsotope
CREATE TYPE ManganeseIsotope AS ENUM (
	'Mn44',
	'Mn45',
	'Mn46',
	'Mn47',
	'Mn48',
	'Mn49',
	'Mn50',
	'Mn51',
	'Mn52',
	'Mn53',
	'Mn54',
	'Mn55',
	'Mn56',
	'Mn57',
	'Mn58',
	'Mn59',
	'Mn60',
	'Mn61',
	'Mn62',
	'Mn63',
	'Mn64',
	'Mn65',
	'Mn66',
	'Mn67',
	'Mn68',
	'Mn69',
	'Mn70',
	'Mn71'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/meitnerium.rs:4
-- elements::isotopes::meitnerium::MeitneriumIsotope
CREATE TYPE MeitneriumIsotope AS ENUM (
	'Mt265',
	'Mt266',
	'Mt267',
	'Mt268',
	'Mt269',
	'Mt270',
	'Mt271',
	'Mt272',
	'Mt273',
	'Mt274',
	'Mt275',
	'Mt276',
	'Mt277',
	'Mt278',
	'Mt279'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/mendelevium.rs:4
-- elements::isotopes::mendelevium::MendeleviumIsotope
CREATE TYPE MendeleviumIsotope AS ENUM (
	'Md245',
	'Md246',
	'Md247',
	'Md248',
	'Md249',
	'Md250',
	'Md251',
	'Md252',
	'Md253',
	'Md254',
	'Md255',
	'Md256',
	'Md257',
	'Md258',
	'Md259',
	'Md260',
	'Md261',
	'Md262'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/mercury.rs:4
-- elements::isotopes::mercury::MercuryIsotope
CREATE TYPE MercuryIsotope AS ENUM (
	'Hg171',
	'Hg172',
	'Hg173',
	'Hg174',
	'Hg175',
	'Hg176',
	'Hg177',
	'Hg178',
	'Hg179',
	'Hg180',
	'Hg181',
	'Hg182',
	'Hg183',
	'Hg184',
	'Hg185',
	'Hg186',
	'Hg187',
	'Hg188',
	'Hg189',
	'Hg190',
	'Hg191',
	'Hg192',
	'Hg193',
	'Hg194',
	'Hg195',
	'Hg196',
	'Hg197',
	'Hg198',
	'Hg199',
	'Hg200',
	'Hg201',
	'Hg202',
	'Hg203',
	'Hg204',
	'Hg205',
	'Hg206',
	'Hg207',
	'Hg208',
	'Hg209',
	'Hg210',
	'Hg211',
	'Hg212',
	'Hg213',
	'Hg214',
	'Hg215',
	'Hg216'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/molybdenum.rs:4
-- elements::isotopes::molybdenum::MolybdenumIsotope
CREATE TYPE MolybdenumIsotope AS ENUM (
	'Mo83',
	'Mo84',
	'Mo85',
	'Mo86',
	'Mo87',
	'Mo88',
	'Mo89',
	'Mo90',
	'Mo91',
	'Mo92',
	'Mo93',
	'Mo94',
	'Mo95',
	'Mo96',
	'Mo97',
	'Mo98',
	'Mo99',
	'Mo100',
	'Mo101',
	'Mo102',
	'Mo103',
	'Mo104',
	'Mo105',
	'Mo106',
	'Mo107',
	'Mo108',
	'Mo109',
	'Mo110',
	'Mo111',
	'Mo112',
	'Mo113',
	'Mo114',
	'Mo115',
	'Mo116',
	'Mo117'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/moscovium.rs:4
-- elements::isotopes::moscovium::MoscoviumIsotope
CREATE TYPE MoscoviumIsotope AS ENUM (
	'Mc287',
	'Mc288',
	'Mc289',
	'Mc290',
	'Mc291'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/neodymium.rs:4
-- elements::isotopes::neodymium::NeodymiumIsotope
CREATE TYPE NeodymiumIsotope AS ENUM (
	'Nd124',
	'Nd125',
	'Nd126',
	'Nd127',
	'Nd128',
	'Nd129',
	'Nd130',
	'Nd131',
	'Nd132',
	'Nd133',
	'Nd134',
	'Nd135',
	'Nd136',
	'Nd137',
	'Nd138',
	'Nd139',
	'Nd140',
	'Nd141',
	'Nd142',
	'Nd143',
	'Nd144',
	'Nd145',
	'Nd146',
	'Nd147',
	'Nd148',
	'Nd149',
	'Nd150',
	'Nd151',
	'Nd152',
	'Nd153',
	'Nd154',
	'Nd155',
	'Nd156',
	'Nd157',
	'Nd158',
	'Nd159',
	'Nd160',
	'Nd161'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/neon.rs:4
-- elements::isotopes::neon::NeonIsotope
CREATE TYPE NeonIsotope AS ENUM (
	'Ne16',
	'Ne17',
	'Ne18',
	'Ne19',
	'Ne20',
	'Ne21',
	'Ne22',
	'Ne23',
	'Ne24',
	'Ne25',
	'Ne26',
	'Ne27',
	'Ne28',
	'Ne29',
	'Ne30',
	'Ne31',
	'Ne32',
	'Ne33',
	'Ne34'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/neptunium.rs:4
-- elements::isotopes::neptunium::NeptuniumIsotope
CREATE TYPE NeptuniumIsotope AS ENUM (
	'Np219',
	'Np220',
	'Np221',
	'Np222',
	'Np223',
	'Np224',
	'Np225',
	'Np226',
	'Np227',
	'Np228',
	'Np229',
	'Np230',
	'Np231',
	'Np232',
	'Np233',
	'Np234',
	'Np235',
	'Np236',
	'Np237',
	'Np238',
	'Np239',
	'Np240',
	'Np241',
	'Np242',
	'Np243',
	'Np244',
	'Np245'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/nickel.rs:4
-- elements::isotopes::nickel::NickelIsotope
CREATE TYPE NickelIsotope AS ENUM (
	'Ni48',
	'Ni49',
	'Ni50',
	'Ni51',
	'Ni52',
	'Ni53',
	'Ni54',
	'Ni55',
	'Ni56',
	'Ni57',
	'Ni58',
	'Ni59',
	'Ni60',
	'Ni61',
	'Ni62',
	'Ni63',
	'Ni64',
	'Ni65',
	'Ni66',
	'Ni67',
	'Ni68',
	'Ni69',
	'Ni70',
	'Ni71',
	'Ni72',
	'Ni73',
	'Ni74',
	'Ni75',
	'Ni76',
	'Ni77',
	'Ni78',
	'Ni79'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/nihonium.rs:4
-- elements::isotopes::nihonium::NihoniumIsotope
CREATE TYPE NihoniumIsotope AS ENUM (
	'Nh278',
	'Nh279',
	'Nh280',
	'Nh281',
	'Nh282',
	'Nh283',
	'Nh284',
	'Nh285',
	'Nh286',
	'Nh287'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/niobium.rs:4
-- elements::isotopes::niobium::NiobiumIsotope
CREATE TYPE NiobiumIsotope AS ENUM (
	'Nb81',
	'Nb82',
	'Nb83',
	'Nb84',
	'Nb85',
	'Nb86',
	'Nb87',
	'Nb88',
	'Nb89',
	'Nb90',
	'Nb91',
	'Nb92',
	'Nb93',
	'Nb94',
	'Nb95',
	'Nb96',
	'Nb97',
	'Nb98',
	'Nb99',
	'Nb100',
	'Nb101',
	'Nb102',
	'Nb103',
	'Nb104',
	'Nb105',
	'Nb106',
	'Nb107',
	'Nb108',
	'Nb109',
	'Nb110',
	'Nb111',
	'Nb112',
	'Nb113',
	'Nb114',
	'Nb115'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/nitrogen.rs:4
-- elements::isotopes::nitrogen::NitrogenIsotope
CREATE TYPE NitrogenIsotope AS ENUM (
	'N10',
	'N11',
	'N12',
	'N13',
	'N14',
	'N15',
	'N16',
	'N17',
	'N18',
	'N19',
	'N20',
	'N21',
	'N22',
	'N23',
	'N24',
	'N25'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/nobelium.rs:4
-- elements::isotopes::nobelium::NobeliumIsotope
CREATE TYPE NobeliumIsotope AS ENUM (
	'No248',
	'No249',
	'No250',
	'No251',
	'No252',
	'No253',
	'No254',
	'No255',
	'No256',
	'No257',
	'No258',
	'No259',
	'No260',
	'No261',
	'No262',
	'No263',
	'No264'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/oganesson.rs:4
-- elements::isotopes::oganesson::OganessonIsotope
CREATE TYPE OganessonIsotope AS ENUM (
	'Og293',
	'Og294',
	'Og295'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/osmium.rs:4
-- elements::isotopes::osmium::OsmiumIsotope
CREATE TYPE OsmiumIsotope AS ENUM (
	'Os161',
	'Os162',
	'Os163',
	'Os164',
	'Os165',
	'Os166',
	'Os167',
	'Os168',
	'Os169',
	'Os170',
	'Os171',
	'Os172',
	'Os173',
	'Os174',
	'Os175',
	'Os176',
	'Os177',
	'Os178',
	'Os179',
	'Os180',
	'Os181',
	'Os182',
	'Os183',
	'Os184',
	'Os185',
	'Os186',
	'Os187',
	'Os188',
	'Os189',
	'Os190',
	'Os191',
	'Os192',
	'Os193',
	'Os194',
	'Os195',
	'Os196',
	'Os197',
	'Os198',
	'Os199',
	'Os200',
	'Os201',
	'Os202'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/oxygen.rs:4
-- elements::isotopes::oxygen::OxygenIsotope
CREATE TYPE OxygenIsotope AS ENUM (
	'O12',
	'O13',
	'O14',
	'O15',
	'O16',
	'O17',
	'O18',
	'O19',
	'O20',
	'O21',
	'O22',
	'O23',
	'O24',
	'O25',
	'O26',
	'O27',
	'O28'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/palladium.rs:4
-- elements::isotopes::palladium::PalladiumIsotope
CREATE TYPE PalladiumIsotope AS ENUM (
	'Pd91',
	'Pd92',
	'Pd93',
	'Pd94',
	'Pd95',
	'Pd96',
	'Pd97',
	'Pd98',
	'Pd99',
	'Pd100',
	'Pd101',
	'Pd102',
	'Pd103',
	'Pd104',
	'Pd105',
	'Pd106',
	'Pd107',
	'Pd108',
	'Pd109',
	'Pd110',
	'Pd111',
	'Pd112',
	'Pd113',
	'Pd114',
	'Pd115',
	'Pd116',
	'Pd117',
	'Pd118',
	'Pd119',
	'Pd120',
	'Pd121',
	'Pd122',
	'Pd123',
	'Pd124',
	'Pd125',
	'Pd126',
	'Pd127',
	'Pd128'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/phosphorus.rs:4
-- elements::isotopes::phosphorus::PhosphorusIsotope
CREATE TYPE PhosphorusIsotope AS ENUM (
	'P24',
	'P25',
	'P26',
	'P27',
	'P28',
	'P29',
	'P30',
	'P31',
	'P32',
	'P33',
	'P34',
	'P35',
	'P36',
	'P37',
	'P38',
	'P39',
	'P40',
	'P41',
	'P42',
	'P43',
	'P44',
	'P45',
	'P46',
	'P47'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/platinum.rs:4
-- elements::isotopes::platinum::PlatinumIsotope
CREATE TYPE PlatinumIsotope AS ENUM (
	'Pt166',
	'Pt167',
	'Pt168',
	'Pt169',
	'Pt170',
	'Pt171',
	'Pt172',
	'Pt173',
	'Pt174',
	'Pt175',
	'Pt176',
	'Pt177',
	'Pt178',
	'Pt179',
	'Pt180',
	'Pt181',
	'Pt182',
	'Pt183',
	'Pt184',
	'Pt185',
	'Pt186',
	'Pt187',
	'Pt188',
	'Pt189',
	'Pt190',
	'Pt191',
	'Pt192',
	'Pt193',
	'Pt194',
	'Pt195',
	'Pt196',
	'Pt197',
	'Pt198',
	'Pt199',
	'Pt200',
	'Pt201',
	'Pt202',
	'Pt203',
	'Pt204',
	'Pt205',
	'Pt206'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/plutonium.rs:4
-- elements::isotopes::plutonium::PlutoniumIsotope
CREATE TYPE PlutoniumIsotope AS ENUM (
	'Pu228',
	'Pu229',
	'Pu230',
	'Pu231',
	'Pu232',
	'Pu233',
	'Pu234',
	'Pu235',
	'Pu236',
	'Pu237',
	'Pu238',
	'Pu239',
	'Pu240',
	'Pu241',
	'Pu242',
	'Pu243',
	'Pu244',
	'Pu245',
	'Pu246',
	'Pu247'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/polonium.rs:4
-- elements::isotopes::polonium::PoloniumIsotope
CREATE TYPE PoloniumIsotope AS ENUM (
	'Po186',
	'Po187',
	'Po188',
	'Po189',
	'Po190',
	'Po191',
	'Po192',
	'Po193',
	'Po194',
	'Po195',
	'Po196',
	'Po197',
	'Po198',
	'Po199',
	'Po200',
	'Po201',
	'Po202',
	'Po203',
	'Po204',
	'Po205',
	'Po206',
	'Po207',
	'Po208',
	'Po209',
	'Po210',
	'Po211',
	'Po212',
	'Po213',
	'Po214',
	'Po215',
	'Po216',
	'Po217',
	'Po218',
	'Po219',
	'Po220',
	'Po221',
	'Po222',
	'Po223',
	'Po224',
	'Po225',
	'Po226',
	'Po227'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/potassium.rs:4
-- elements::isotopes::potassium::PotassiumIsotope
CREATE TYPE PotassiumIsotope AS ENUM (
	'K32',
	'K33',
	'K34',
	'K35',
	'K36',
	'K37',
	'K38',
	'K39',
	'K40',
	'K41',
	'K42',
	'K43',
	'K44',
	'K45',
	'K46',
	'K47',
	'K48',
	'K49',
	'K50',
	'K51',
	'K52',
	'K53',
	'K54',
	'K55',
	'K56'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/praseodymium.rs:4
-- elements::isotopes::praseodymium::PraseodymiumIsotope
CREATE TYPE PraseodymiumIsotope AS ENUM (
	'Pr121',
	'Pr122',
	'Pr123',
	'Pr124',
	'Pr125',
	'Pr126',
	'Pr127',
	'Pr128',
	'Pr129',
	'Pr130',
	'Pr131',
	'Pr132',
	'Pr133',
	'Pr134',
	'Pr135',
	'Pr136',
	'Pr137',
	'Pr138',
	'Pr139',
	'Pr140',
	'Pr141',
	'Pr142',
	'Pr143',
	'Pr144',
	'Pr145',
	'Pr146',
	'Pr147',
	'Pr148',
	'Pr149',
	'Pr150',
	'Pr151',
	'Pr152',
	'Pr153',
	'Pr154',
	'Pr155',
	'Pr156',
	'Pr157',
	'Pr158',
	'Pr159'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/promethium.rs:4
-- elements::isotopes::promethium::PromethiumIsotope
CREATE TYPE PromethiumIsotope AS ENUM (
	'Pm126',
	'Pm127',
	'Pm128',
	'Pm129',
	'Pm130',
	'Pm131',
	'Pm132',
	'Pm133',
	'Pm134',
	'Pm135',
	'Pm136',
	'Pm137',
	'Pm138',
	'Pm139',
	'Pm140',
	'Pm141',
	'Pm142',
	'Pm143',
	'Pm144',
	'Pm145',
	'Pm146',
	'Pm147',
	'Pm148',
	'Pm149',
	'Pm150',
	'Pm151',
	'Pm152',
	'Pm153',
	'Pm154',
	'Pm155',
	'Pm156',
	'Pm157',
	'Pm158',
	'Pm159',
	'Pm160',
	'Pm161',
	'Pm162',
	'Pm163'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/protactinium.rs:4
-- elements::isotopes::protactinium::ProtactiniumIsotope
CREATE TYPE ProtactiniumIsotope AS ENUM (
	'Pa212',
	'Pa213',
	'Pa214',
	'Pa215',
	'Pa216',
	'Pa217',
	'Pa218',
	'Pa219',
	'Pa220',
	'Pa221',
	'Pa222',
	'Pa223',
	'Pa224',
	'Pa225',
	'Pa226',
	'Pa227',
	'Pa228',
	'Pa229',
	'Pa230',
	'Pa231',
	'Pa232',
	'Pa233',
	'Pa234',
	'Pa235',
	'Pa236',
	'Pa237',
	'Pa238',
	'Pa239',
	'Pa240',
	'Pa241'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/radium.rs:4
-- elements::isotopes::radium::RadiumIsotope
CREATE TYPE RadiumIsotope AS ENUM (
	'Ra201',
	'Ra202',
	'Ra203',
	'Ra204',
	'Ra205',
	'Ra206',
	'Ra207',
	'Ra208',
	'Ra209',
	'Ra210',
	'Ra211',
	'Ra212',
	'Ra213',
	'Ra214',
	'Ra215',
	'Ra216',
	'Ra217',
	'Ra218',
	'Ra219',
	'Ra220',
	'Ra221',
	'Ra222',
	'Ra223',
	'Ra224',
	'Ra225',
	'Ra226',
	'Ra227',
	'Ra228',
	'Ra229',
	'Ra230',
	'Ra231',
	'Ra232',
	'Ra233',
	'Ra234',
	'Ra235'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/radon.rs:4
-- elements::isotopes::radon::RadonIsotope
CREATE TYPE RadonIsotope AS ENUM (
	'Rn193',
	'Rn194',
	'Rn195',
	'Rn196',
	'Rn197',
	'Rn198',
	'Rn199',
	'Rn200',
	'Rn201',
	'Rn202',
	'Rn203',
	'Rn204',
	'Rn205',
	'Rn206',
	'Rn207',
	'Rn208',
	'Rn209',
	'Rn210',
	'Rn211',
	'Rn212',
	'Rn213',
	'Rn214',
	'Rn215',
	'Rn216',
	'Rn217',
	'Rn218',
	'Rn219',
	'Rn220',
	'Rn221',
	'Rn222',
	'Rn223',
	'Rn224',
	'Rn225',
	'Rn226',
	'Rn227',
	'Rn228',
	'Rn229',
	'Rn230',
	'Rn231'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/rhenium.rs:4
-- elements::isotopes::rhenium::RheniumIsotope
CREATE TYPE RheniumIsotope AS ENUM (
	'Re159',
	'Re160',
	'Re161',
	'Re162',
	'Re163',
	'Re164',
	'Re165',
	'Re166',
	'Re167',
	'Re168',
	'Re169',
	'Re170',
	'Re171',
	'Re172',
	'Re173',
	'Re174',
	'Re175',
	'Re176',
	'Re177',
	'Re178',
	'Re179',
	'Re180',
	'Re181',
	'Re182',
	'Re183',
	'Re184',
	'Re185',
	'Re186',
	'Re187',
	'Re188',
	'Re189',
	'Re190',
	'Re191',
	'Re192',
	'Re193',
	'Re194',
	'Re195',
	'Re196',
	'Re197',
	'Re198'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/rhodium.rs:4
-- elements::isotopes::rhodium::RhodiumIsotope
CREATE TYPE RhodiumIsotope AS ENUM (
	'Rh89',
	'Rh90',
	'Rh91',
	'Rh92',
	'Rh93',
	'Rh94',
	'Rh95',
	'Rh96',
	'Rh97',
	'Rh98',
	'Rh99',
	'Rh100',
	'Rh101',
	'Rh102',
	'Rh103',
	'Rh104',
	'Rh105',
	'Rh106',
	'Rh107',
	'Rh108',
	'Rh109',
	'Rh110',
	'Rh111',
	'Rh112',
	'Rh113',
	'Rh114',
	'Rh115',
	'Rh116',
	'Rh117',
	'Rh118',
	'Rh119',
	'Rh120',
	'Rh121',
	'Rh122',
	'Rh123',
	'Rh124',
	'Rh125',
	'Rh126'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/roentgenium.rs:4
-- elements::isotopes::roentgenium::RoentgeniumIsotope
CREATE TYPE RoentgeniumIsotope AS ENUM (
	'Rg272',
	'Rg273',
	'Rg274',
	'Rg275',
	'Rg276',
	'Rg277',
	'Rg278',
	'Rg279',
	'Rg280',
	'Rg281',
	'Rg282',
	'Rg283'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/rubidium.rs:4
-- elements::isotopes::rubidium::RubidiumIsotope
CREATE TYPE RubidiumIsotope AS ENUM (
	'Rb71',
	'Rb72',
	'Rb73',
	'Rb74',
	'Rb75',
	'Rb76',
	'Rb77',
	'Rb78',
	'Rb79',
	'Rb80',
	'Rb81',
	'Rb82',
	'Rb83',
	'Rb84',
	'Rb85',
	'Rb86',
	'Rb87',
	'Rb88',
	'Rb89',
	'Rb90',
	'Rb91',
	'Rb92',
	'Rb93',
	'Rb94',
	'Rb95',
	'Rb96',
	'Rb97',
	'Rb98',
	'Rb99',
	'Rb100',
	'Rb101',
	'Rb102',
	'Rb103'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/ruthenium.rs:4
-- elements::isotopes::ruthenium::RutheniumIsotope
CREATE TYPE RutheniumIsotope AS ENUM (
	'Ru87',
	'Ru88',
	'Ru89',
	'Ru90',
	'Ru91',
	'Ru92',
	'Ru93',
	'Ru94',
	'Ru95',
	'Ru96',
	'Ru97',
	'Ru98',
	'Ru99',
	'Ru100',
	'Ru101',
	'Ru102',
	'Ru103',
	'Ru104',
	'Ru105',
	'Ru106',
	'Ru107',
	'Ru108',
	'Ru109',
	'Ru110',
	'Ru111',
	'Ru112',
	'Ru113',
	'Ru114',
	'Ru115',
	'Ru116',
	'Ru117',
	'Ru118',
	'Ru119',
	'Ru120',
	'Ru121',
	'Ru122',
	'Ru123',
	'Ru124'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/rutherfordium.rs:4
-- elements::isotopes::rutherfordium::RutherfordiumIsotope
CREATE TYPE RutherfordiumIsotope AS ENUM (
	'Rf253',
	'Rf254',
	'Rf255',
	'Rf256',
	'Rf257',
	'Rf258',
	'Rf259',
	'Rf260',
	'Rf261',
	'Rf262',
	'Rf263',
	'Rf264',
	'Rf265',
	'Rf266',
	'Rf267',
	'Rf268'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/samarium.rs:4
-- elements::isotopes::samarium::SamariumIsotope
CREATE TYPE SamariumIsotope AS ENUM (
	'Sm128',
	'Sm129',
	'Sm130',
	'Sm131',
	'Sm132',
	'Sm133',
	'Sm134',
	'Sm135',
	'Sm136',
	'Sm137',
	'Sm138',
	'Sm139',
	'Sm140',
	'Sm141',
	'Sm142',
	'Sm143',
	'Sm144',
	'Sm145',
	'Sm146',
	'Sm147',
	'Sm148',
	'Sm149',
	'Sm150',
	'Sm151',
	'Sm152',
	'Sm153',
	'Sm154',
	'Sm155',
	'Sm156',
	'Sm157',
	'Sm158',
	'Sm159',
	'Sm160',
	'Sm161',
	'Sm162',
	'Sm163',
	'Sm164',
	'Sm165'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/scandium.rs:4
-- elements::isotopes::scandium::ScandiumIsotope
CREATE TYPE ScandiumIsotope AS ENUM (
	'Sc36',
	'Sc37',
	'Sc38',
	'Sc39',
	'Sc40',
	'Sc41',
	'Sc42',
	'Sc43',
	'Sc44',
	'Sc45',
	'Sc46',
	'Sc47',
	'Sc48',
	'Sc49',
	'Sc50',
	'Sc51',
	'Sc52',
	'Sc53',
	'Sc54',
	'Sc55',
	'Sc56',
	'Sc57',
	'Sc58',
	'Sc59',
	'Sc60',
	'Sc61'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/seaborgium.rs:4
-- elements::isotopes::seaborgium::SeaborgiumIsotope
CREATE TYPE SeaborgiumIsotope AS ENUM (
	'Sg258',
	'Sg259',
	'Sg260',
	'Sg261',
	'Sg262',
	'Sg263',
	'Sg264',
	'Sg265',
	'Sg266',
	'Sg267',
	'Sg268',
	'Sg269',
	'Sg270',
	'Sg271',
	'Sg272',
	'Sg273'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/selenium.rs:4
-- elements::isotopes::selenium::SeleniumIsotope
CREATE TYPE SeleniumIsotope AS ENUM (
	'Se64',
	'Se65',
	'Se66',
	'Se67',
	'Se68',
	'Se69',
	'Se70',
	'Se71',
	'Se72',
	'Se73',
	'Se74',
	'Se75',
	'Se76',
	'Se77',
	'Se78',
	'Se79',
	'Se80',
	'Se81',
	'Se82',
	'Se83',
	'Se84',
	'Se85',
	'Se86',
	'Se87',
	'Se88',
	'Se89',
	'Se90',
	'Se91',
	'Se92',
	'Se93',
	'Se94',
	'Se95'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/silicon.rs:4
-- elements::isotopes::silicon::SiliconIsotope
CREATE TYPE SiliconIsotope AS ENUM (
	'Si22',
	'Si23',
	'Si24',
	'Si25',
	'Si26',
	'Si27',
	'Si28',
	'Si29',
	'Si30',
	'Si31',
	'Si32',
	'Si33',
	'Si34',
	'Si35',
	'Si36',
	'Si37',
	'Si38',
	'Si39',
	'Si40',
	'Si41',
	'Si42',
	'Si43',
	'Si44',
	'Si45'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/silver.rs:4
-- elements::isotopes::silver::SilverIsotope
CREATE TYPE SilverIsotope AS ENUM (
	'Ag93',
	'Ag94',
	'Ag95',
	'Ag96',
	'Ag97',
	'Ag98',
	'Ag99',
	'Ag100',
	'Ag101',
	'Ag102',
	'Ag103',
	'Ag104',
	'Ag105',
	'Ag106',
	'Ag107',
	'Ag108',
	'Ag109',
	'Ag110',
	'Ag111',
	'Ag112',
	'Ag113',
	'Ag114',
	'Ag115',
	'Ag116',
	'Ag117',
	'Ag118',
	'Ag119',
	'Ag120',
	'Ag121',
	'Ag122',
	'Ag123',
	'Ag124',
	'Ag125',
	'Ag126',
	'Ag127',
	'Ag128',
	'Ag129',
	'Ag130'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/sodium.rs:4
-- elements::isotopes::sodium::SodiumIsotope
CREATE TYPE SodiumIsotope AS ENUM (
	'Na18',
	'Na19',
	'Na20',
	'Na21',
	'Na22',
	'Na23',
	'Na24',
	'Na25',
	'Na26',
	'Na27',
	'Na28',
	'Na29',
	'Na30',
	'Na31',
	'Na32',
	'Na33',
	'Na34',
	'Na35',
	'Na36',
	'Na37'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/strontium.rs:4
-- elements::isotopes::strontium::StrontiumIsotope
CREATE TYPE StrontiumIsotope AS ENUM (
	'Sr73',
	'Sr74',
	'Sr75',
	'Sr76',
	'Sr77',
	'Sr78',
	'Sr79',
	'Sr80',
	'Sr81',
	'Sr82',
	'Sr83',
	'Sr84',
	'Sr85',
	'Sr86',
	'Sr87',
	'Sr88',
	'Sr89',
	'Sr90',
	'Sr91',
	'Sr92',
	'Sr93',
	'Sr94',
	'Sr95',
	'Sr96',
	'Sr97',
	'Sr98',
	'Sr99',
	'Sr100',
	'Sr101',
	'Sr102',
	'Sr103',
	'Sr104',
	'Sr105',
	'Sr106',
	'Sr107'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/sulfur.rs:4
-- elements::isotopes::sulfur::SulfurIsotope
CREATE TYPE SulfurIsotope AS ENUM (
	'S26',
	'S27',
	'S28',
	'S29',
	'S30',
	'S31',
	'S32',
	'S33',
	'S34',
	'S35',
	'S36',
	'S37',
	'S38',
	'S39',
	'S40',
	'S41',
	'S42',
	'S43',
	'S44',
	'S45',
	'S46',
	'S47',
	'S48',
	'S49'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/tantalum.rs:4
-- elements::isotopes::tantalum::TantalumIsotope
CREATE TYPE TantalumIsotope AS ENUM (
	'Ta155',
	'Ta156',
	'Ta157',
	'Ta158',
	'Ta159',
	'Ta160',
	'Ta161',
	'Ta162',
	'Ta163',
	'Ta164',
	'Ta165',
	'Ta166',
	'Ta167',
	'Ta168',
	'Ta169',
	'Ta170',
	'Ta171',
	'Ta172',
	'Ta173',
	'Ta174',
	'Ta175',
	'Ta176',
	'Ta177',
	'Ta178',
	'Ta179',
	'Ta180',
	'Ta181',
	'Ta182',
	'Ta183',
	'Ta184',
	'Ta185',
	'Ta186',
	'Ta187',
	'Ta188',
	'Ta189',
	'Ta190',
	'Ta191',
	'Ta192'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/technetium.rs:4
-- elements::isotopes::technetium::TechnetiumIsotope
CREATE TYPE TechnetiumIsotope AS ENUM (
	'Tc85',
	'Tc86',
	'Tc87',
	'Tc88',
	'Tc89',
	'Tc90',
	'Tc91',
	'Tc92',
	'Tc93',
	'Tc94',
	'Tc95',
	'Tc96',
	'Tc97',
	'Tc98',
	'Tc99',
	'Tc100',
	'Tc101',
	'Tc102',
	'Tc103',
	'Tc104',
	'Tc105',
	'Tc106',
	'Tc107',
	'Tc108',
	'Tc109',
	'Tc110',
	'Tc111',
	'Tc112',
	'Tc113',
	'Tc114',
	'Tc115',
	'Tc116',
	'Tc117',
	'Tc118',
	'Tc119',
	'Tc120'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/tellurium.rs:4
-- elements::isotopes::tellurium::TelluriumIsotope
CREATE TYPE TelluriumIsotope AS ENUM (
	'Te105',
	'Te106',
	'Te107',
	'Te108',
	'Te109',
	'Te110',
	'Te111',
	'Te112',
	'Te113',
	'Te114',
	'Te115',
	'Te116',
	'Te117',
	'Te118',
	'Te119',
	'Te120',
	'Te121',
	'Te122',
	'Te123',
	'Te124',
	'Te125',
	'Te126',
	'Te127',
	'Te128',
	'Te129',
	'Te130',
	'Te131',
	'Te132',
	'Te133',
	'Te134',
	'Te135',
	'Te136',
	'Te137',
	'Te138',
	'Te139',
	'Te140',
	'Te141',
	'Te142',
	'Te143'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/tennessine.rs:4
-- elements::isotopes::tennessine::TennessineIsotope
CREATE TYPE TennessineIsotope AS ENUM (
	'Ts291',
	'Ts292',
	'Ts293',
	'Ts294'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/terbium.rs:4
-- elements::isotopes::terbium::TerbiumIsotope
CREATE TYPE TerbiumIsotope AS ENUM (
	'Tb135',
	'Tb136',
	'Tb137',
	'Tb138',
	'Tb139',
	'Tb140',
	'Tb141',
	'Tb142',
	'Tb143',
	'Tb144',
	'Tb145',
	'Tb146',
	'Tb147',
	'Tb148',
	'Tb149',
	'Tb150',
	'Tb151',
	'Tb152',
	'Tb153',
	'Tb154',
	'Tb155',
	'Tb156',
	'Tb157',
	'Tb158',
	'Tb159',
	'Tb160',
	'Tb161',
	'Tb162',
	'Tb163',
	'Tb164',
	'Tb165',
	'Tb166',
	'Tb167',
	'Tb168',
	'Tb169',
	'Tb170',
	'Tb171'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/thallium.rs:4
-- elements::isotopes::thallium::ThalliumIsotope
CREATE TYPE ThalliumIsotope AS ENUM (
	'Tl176',
	'Tl177',
	'Tl178',
	'Tl179',
	'Tl180',
	'Tl181',
	'Tl182',
	'Tl183',
	'Tl184',
	'Tl185',
	'Tl186',
	'Tl187',
	'Tl188',
	'Tl189',
	'Tl190',
	'Tl191',
	'Tl192',
	'Tl193',
	'Tl194',
	'Tl195',
	'Tl196',
	'Tl197',
	'Tl198',
	'Tl199',
	'Tl200',
	'Tl201',
	'Tl202',
	'Tl203',
	'Tl204',
	'Tl205',
	'Tl206',
	'Tl207',
	'Tl208',
	'Tl209',
	'Tl210',
	'Tl211',
	'Tl212',
	'Tl213',
	'Tl214',
	'Tl215',
	'Tl216',
	'Tl217',
	'Tl218'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/thorium.rs:4
-- elements::isotopes::thorium::ThoriumIsotope
CREATE TYPE ThoriumIsotope AS ENUM (
	'Th208',
	'Th209',
	'Th210',
	'Th211',
	'Th212',
	'Th213',
	'Th214',
	'Th215',
	'Th216',
	'Th217',
	'Th218',
	'Th219',
	'Th220',
	'Th221',
	'Th222',
	'Th223',
	'Th224',
	'Th225',
	'Th226',
	'Th227',
	'Th228',
	'Th229',
	'Th230',
	'Th231',
	'Th232',
	'Th233',
	'Th234',
	'Th235',
	'Th236',
	'Th237',
	'Th238',
	'Th239'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/thulium.rs:4
-- elements::isotopes::thulium::ThuliumIsotope
CREATE TYPE ThuliumIsotope AS ENUM (
	'Tm144',
	'Tm145',
	'Tm146',
	'Tm147',
	'Tm148',
	'Tm149',
	'Tm150',
	'Tm151',
	'Tm152',
	'Tm153',
	'Tm154',
	'Tm155',
	'Tm156',
	'Tm157',
	'Tm158',
	'Tm159',
	'Tm160',
	'Tm161',
	'Tm162',
	'Tm163',
	'Tm164',
	'Tm165',
	'Tm166',
	'Tm167',
	'Tm168',
	'Tm169',
	'Tm170',
	'Tm171',
	'Tm172',
	'Tm173',
	'Tm174',
	'Tm175',
	'Tm176',
	'Tm177',
	'Tm178',
	'Tm179'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/tin.rs:4
-- elements::isotopes::tin::TinIsotope
CREATE TYPE TinIsotope AS ENUM (
	'Sn99',
	'Sn100',
	'Sn101',
	'Sn102',
	'Sn103',
	'Sn104',
	'Sn105',
	'Sn106',
	'Sn107',
	'Sn108',
	'Sn109',
	'Sn110',
	'Sn111',
	'Sn112',
	'Sn113',
	'Sn114',
	'Sn115',
	'Sn116',
	'Sn117',
	'Sn118',
	'Sn119',
	'Sn120',
	'Sn121',
	'Sn122',
	'Sn123',
	'Sn124',
	'Sn125',
	'Sn126',
	'Sn127',
	'Sn128',
	'Sn129',
	'Sn130',
	'Sn131',
	'Sn132',
	'Sn133',
	'Sn134',
	'Sn135',
	'Sn136',
	'Sn137',
	'Sn138'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/titanium.rs:4
-- elements::isotopes::titanium::TitaniumIsotope
CREATE TYPE TitaniumIsotope AS ENUM (
	'Ti38',
	'Ti39',
	'Ti40',
	'Ti41',
	'Ti42',
	'Ti43',
	'Ti44',
	'Ti45',
	'Ti46',
	'Ti47',
	'Ti48',
	'Ti49',
	'Ti50',
	'Ti51',
	'Ti52',
	'Ti53',
	'Ti54',
	'Ti55',
	'Ti56',
	'Ti57',
	'Ti58',
	'Ti59',
	'Ti60',
	'Ti61',
	'Ti62',
	'Ti63'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/tungsten.rs:4
-- elements::isotopes::tungsten::TungstenIsotope
CREATE TYPE TungstenIsotope AS ENUM (
	'W157',
	'W158',
	'W159',
	'W160',
	'W161',
	'W162',
	'W163',
	'W164',
	'W165',
	'W166',
	'W167',
	'W168',
	'W169',
	'W170',
	'W171',
	'W172',
	'W173',
	'W174',
	'W175',
	'W176',
	'W177',
	'W178',
	'W179',
	'W180',
	'W181',
	'W182',
	'W183',
	'W184',
	'W185',
	'W186',
	'W187',
	'W188',
	'W189',
	'W190',
	'W191',
	'W192',
	'W193',
	'W194'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/uranium.rs:4
-- elements::isotopes::uranium::UraniumIsotope
CREATE TYPE UraniumIsotope AS ENUM (
	'U217',
	'U218',
	'U219',
	'U220',
	'U221',
	'U222',
	'U223',
	'U224',
	'U225',
	'U226',
	'U227',
	'U228',
	'U229',
	'U230',
	'U231',
	'U232',
	'U233',
	'U234',
	'U235',
	'U236',
	'U237',
	'U238',
	'U239',
	'U240',
	'U241',
	'U242',
	'U243'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/vanadium.rs:4
-- elements::isotopes::vanadium::VanadiumIsotope
CREATE TYPE VanadiumIsotope AS ENUM (
	'V40',
	'V41',
	'V42',
	'V43',
	'V44',
	'V45',
	'V46',
	'V47',
	'V48',
	'V49',
	'V50',
	'V51',
	'V52',
	'V53',
	'V54',
	'V55',
	'V56',
	'V57',
	'V58',
	'V59',
	'V60',
	'V61',
	'V62',
	'V63',
	'V64',
	'V65',
	'V66'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/xenon.rs:4
-- elements::isotopes::xenon::XenonIsotope
CREATE TYPE XenonIsotope AS ENUM (
	'Xe109',
	'Xe110',
	'Xe111',
	'Xe112',
	'Xe113',
	'Xe114',
	'Xe115',
	'Xe116',
	'Xe117',
	'Xe118',
	'Xe119',
	'Xe120',
	'Xe121',
	'Xe122',
	'Xe123',
	'Xe124',
	'Xe125',
	'Xe126',
	'Xe127',
	'Xe128',
	'Xe129',
	'Xe130',
	'Xe131',
	'Xe132',
	'Xe133',
	'Xe134',
	'Xe135',
	'Xe136',
	'Xe137',
	'Xe138',
	'Xe139',
	'Xe140',
	'Xe141',
	'Xe142',
	'Xe143',
	'Xe144',
	'Xe145',
	'Xe146',
	'Xe147',
	'Xe148'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/ytterbium.rs:4
-- elements::isotopes::ytterbium::YtterbiumIsotope
CREATE TYPE YtterbiumIsotope AS ENUM (
	'Yb148',
	'Yb149',
	'Yb150',
	'Yb151',
	'Yb152',
	'Yb153',
	'Yb154',
	'Yb155',
	'Yb156',
	'Yb157',
	'Yb158',
	'Yb159',
	'Yb160',
	'Yb161',
	'Yb162',
	'Yb163',
	'Yb164',
	'Yb165',
	'Yb166',
	'Yb167',
	'Yb168',
	'Yb169',
	'Yb170',
	'Yb171',
	'Yb172',
	'Yb173',
	'Yb174',
	'Yb175',
	'Yb176',
	'Yb177',
	'Yb178',
	'Yb179',
	'Yb180',
	'Yb181'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/yttrium.rs:4
-- elements::isotopes::yttrium::YttriumIsotope
CREATE TYPE YttriumIsotope AS ENUM (
	'Y76',
	'Y77',
	'Y78',
	'Y79',
	'Y80',
	'Y81',
	'Y82',
	'Y83',
	'Y84',
	'Y85',
	'Y86',
	'Y87',
	'Y88',
	'Y89',
	'Y90',
	'Y91',
	'Y92',
	'Y93',
	'Y94',
	'Y95',
	'Y96',
	'Y97',
	'Y98',
	'Y99',
	'Y100',
	'Y101',
	'Y102',
	'Y103',
	'Y104',
	'Y105',
	'Y106',
	'Y107',
	'Y108',
	'Y109'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/zinc.rs:4
-- elements::isotopes::zinc::ZincIsotope
CREATE TYPE ZincIsotope AS ENUM (
	'Zn54',
	'Zn55',
	'Zn56',
	'Zn57',
	'Zn58',
	'Zn59',
	'Zn60',
	'Zn61',
	'Zn62',
	'Zn63',
	'Zn64',
	'Zn65',
	'Zn66',
	'Zn67',
	'Zn68',
	'Zn69',
	'Zn70',
	'Zn71',
	'Zn72',
	'Zn73',
	'Zn74',
	'Zn75',
	'Zn76',
	'Zn77',
	'Zn78',
	'Zn79',
	'Zn80',
	'Zn81',
	'Zn82',
	'Zn83',
	'Zn84',
	'Zn85'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/zirconium.rs:4
-- elements::isotopes::zirconium::ZirconiumIsotope
CREATE TYPE ZirconiumIsotope AS ENUM (
	'Zr78',
	'Zr79',
	'Zr80',
	'Zr81',
	'Zr82',
	'Zr83',
	'Zr84',
	'Zr85',
	'Zr86',
	'Zr87',
	'Zr88',
	'Zr89',
	'Zr90',
	'Zr91',
	'Zr92',
	'Zr93',
	'Zr94',
	'Zr95',
	'Zr96',
	'Zr97',
	'Zr98',
	'Zr99',
	'Zr100',
	'Zr101',
	'Zr102',
	'Zr103',
	'Zr104',
	'Zr105',
	'Zr106',
	'Zr107',
	'Zr108',
	'Zr109',
	'Zr110',
	'Zr111',
	'Zr112'
);
/* </end connected objects> */

/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/iso_codes/src/country_codes.rs:17
-- iso_codes::country_codes::CountryCode
CREATE TYPE CountryCode AS ENUM (
	'AD',
	'AE',
	'AF',
	'AG',
	'AI',
	'AL',
	'AM',
	'AO',
	'AQ',
	'AR',
	'AS',
	'AT',
	'AU',
	'AW',
	'AX',
	'AZ',
	'BA',
	'BB',
	'BD',
	'BE',
	'BF',
	'BG',
	'BH',
	'BI',
	'BJ',
	'BL',
	'BM',
	'BN',
	'BO',
	'BQ',
	'BR',
	'BS',
	'BT',
	'BV',
	'BW',
	'BY',
	'BZ',
	'CA',
	'CC',
	'CD',
	'CF',
	'CG',
	'CH',
	'CI',
	'CK',
	'CL',
	'CM',
	'CN',
	'CO',
	'CR',
	'CU',
	'CV',
	'CW',
	'CX',
	'CY',
	'CZ',
	'DE',
	'DJ',
	'DK',
	'DM',
	'DO',
	'DZ',
	'EC',
	'EE',
	'EG',
	'EH',
	'ER',
	'ES',
	'ET',
	'FI',
	'FJ',
	'FK',
	'FM',
	'FO',
	'FR',
	'GA',
	'GB',
	'GD',
	'GE',
	'GF',
	'GG',
	'GH',
	'GI',
	'GL',
	'GM',
	'GN',
	'GP',
	'GQ',
	'GR',
	'GS',
	'GT',
	'GU',
	'GW',
	'GY',
	'HK',
	'HM',
	'HN',
	'HR',
	'HT',
	'HU',
	'ID',
	'IE',
	'IL',
	'IM',
	'IN',
	'IO',
	'IQ',
	'IR',
	'IS',
	'IT',
	'JE',
	'JM',
	'JO',
	'JP',
	'KE',
	'KG',
	'KH',
	'KI',
	'KM',
	'KN',
	'KP',
	'KR',
	'KW',
	'KY',
	'KZ',
	'LA',
	'LB',
	'LC',
	'LI',
	'LK',
	'LR',
	'LS',
	'LT',
	'LU',
	'LV',
	'LY',
	'MA',
	'MC',
	'MD',
	'ME',
	'MF',
	'MG',
	'MH',
	'MK',
	'ML',
	'MM',
	'MN',
	'MO',
	'MP',
	'MQ',
	'MR',
	'MS',
	'MT',
	'MU',
	'MV',
	'MW',
	'MX',
	'MY',
	'MZ',
	'NA',
	'NC',
	'NE',
	'NF',
	'NG',
	'NI',
	'NL',
	'NO',
	'NP',
	'NR',
	'NU',
	'NZ',
	'OM',
	'PA',
	'PE',
	'PF',
	'PG',
	'PH',
	'PK',
	'PL',
	'PM',
	'PN',
	'PR',
	'PS',
	'PT',
	'PW',
	'PY',
	'QA',
	'RE',
	'RO',
	'RS',
	'RU',
	'RW',
	'SA',
	'SB',
	'SC',
	'SD',
	'SE',
	'SG',
	'SH',
	'SI',
	'SJ',
	'SK',
	'SL',
	'SM',
	'SN',
	'SO',
	'SR',
	'SS',
	'ST',
	'SV',
	'SX',
	'SY',
	'SZ',
	'TC',
	'TD',
	'TF',
	'TG',
	'TH',
	'TJ',
	'TK',
	'TL',
	'TM',
	'TN',
	'TO',
	'TR',
	'TT',
	'TV',
	'TW',
	'TZ',
	'UA',
	'UG',
	'UM',
	'US',
	'UY',
	'UZ',
	'VA',
	'VC',
	'VE',
	'VG',
	'VI',
	'VN',
	'VU',
	'WF',
	'WS',
	'YE',
	'YT',
	'ZA',
	'ZM',
	'ZW',
	'XK'
);
/* </end connected objects> */

/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::MediaType
CREATE TYPE MediaType;

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_in
CREATE  FUNCTION "mediatype_in"(
	"input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS MediaType /* core::option::Option<media_types::MediaType> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_in_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_out
CREATE  FUNCTION "mediatype_out"(
	"input" MediaType /* media_types::MediaType */
) RETURNS cstring /* alloc::ffi::c_str::CString */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_out_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_recv
CREATE  FUNCTION "mediatype_recv"(
	"internal" internal /* pgrx::datum::internal::Internal */
) RETURNS MediaType /* media_types::MediaType */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_recv_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_send
CREATE  FUNCTION "mediatype_send"(
	"input" MediaType /* media_types::MediaType */
) RETURNS bytea /* alloc::vec::Vec<u8> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_send_wrapper';


-- web/web_common/media_types/src/lib.rs:31
-- media_types::MediaType
CREATE TYPE MediaType (
	INTERNALLENGTH = variable,
	INPUT = mediatype_in, /* media_types::mediatype_in */
	OUTPUT = mediatype_out, /* media_types::mediatype_out */
	RECEIVE = mediatype_recv, /* media_types::mediatype_recv */
	SEND = mediatype_send, /* media_types::mediatype_send */
	STORAGE = extended
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_cmp
CREATE  FUNCTION "mediatype_cmp"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_cmp_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_eq
CREATE  FUNCTION "mediatype_eq"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_eq_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_eq
CREATE OPERATOR = (
	PROCEDURE="mediatype_eq",
	LEFTARG=MediaType, /* media_types::MediaType */
	RIGHTARG=MediaType, /* media_types::MediaType */
	COMMUTATOR = =,
	NEGATOR = <>,
	RESTRICT = eqsel,
	JOIN = eqjoinsel,
	HASHES,
	MERGES
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_ge
CREATE  FUNCTION "mediatype_ge"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_ge_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_ge
CREATE OPERATOR >= (
	PROCEDURE="mediatype_ge",
	LEFTARG=MediaType, /* media_types::MediaType */
	RIGHTARG=MediaType, /* media_types::MediaType */
	COMMUTATOR = <=,
	NEGATOR = <,
	RESTRICT = scalargesel,
	JOIN = scalargejoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_gt
CREATE  FUNCTION "mediatype_gt"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_gt_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_gt
CREATE OPERATOR > (
	PROCEDURE="mediatype_gt",
	LEFTARG=MediaType, /* media_types::MediaType */
	RIGHTARG=MediaType, /* media_types::MediaType */
	COMMUTATOR = <,
	NEGATOR = <=,
	RESTRICT = scalargtsel,
	JOIN = scalargtjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_hash
CREATE  FUNCTION "mediatype_hash"(
	"value" MediaType /* media_types::MediaType */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_hash_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_le
CREATE  FUNCTION "mediatype_le"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_le_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_le
CREATE OPERATOR <= (
	PROCEDURE="mediatype_le",
	LEFTARG=MediaType, /* media_types::MediaType */
	RIGHTARG=MediaType, /* media_types::MediaType */
	COMMUTATOR = >=,
	NEGATOR = >,
	RESTRICT = scalarlesel,
	JOIN = scalarlejoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_lt
CREATE  FUNCTION "mediatype_lt"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_lt_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_lt
CREATE OPERATOR < (
	PROCEDURE="mediatype_lt",
	LEFTARG=MediaType, /* media_types::MediaType */
	RIGHTARG=MediaType, /* media_types::MediaType */
	COMMUTATOR = >,
	NEGATOR = >=,
	RESTRICT = scalarltsel,
	JOIN = scalarltjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_ne
CREATE  FUNCTION "mediatype_ne"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_ne_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_ne
CREATE OPERATOR <> (
	PROCEDURE="mediatype_ne",
	LEFTARG=MediaType, /* media_types::MediaType */
	RIGHTARG=MediaType, /* media_types::MediaType */
	COMMUTATOR = <>,
	NEGATOR = =,
	RESTRICT = neqsel,
	JOIN = neqjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::MediaType
CREATE OPERATOR FAMILY MediaType_btree_ops USING btree;
CREATE OPERATOR CLASS MediaType_btree_ops DEFAULT FOR TYPE MediaType USING btree FAMILY MediaType_btree_ops AS
	OPERATOR 1 <,
	OPERATOR 2 <=,
	OPERATOR 3 =,
	OPERATOR 4 >=,
	OPERATOR 5 >,
	FUNCTION 1 mediatype_cmp(MediaType, MediaType);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::MediaType
CREATE OPERATOR FAMILY MediaType_hash_ops USING hash;
CREATE OPERATOR CLASS MediaType_hash_ops DEFAULT FOR TYPE MediaType USING hash FAMILY MediaType_hash_ops AS
	OPERATOR    1   =  (MediaType, MediaType),
	FUNCTION    1   mediatype_hash(MediaType);
/* </end connected objects> */

/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::MolecularFormula
CREATE TYPE MolecularFormula;

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_in
CREATE  FUNCTION "molecularformula_in"(
	"input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS MolecularFormula /* core::option::Option<molecular_formulas::molecular_formula::MolecularFormula> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_in_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_out
CREATE  FUNCTION "molecularformula_out"(
	"input" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS cstring /* alloc::ffi::c_str::CString */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_out_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_recv
CREATE  FUNCTION "molecularformula_recv"(
	"internal" internal /* pgrx::datum::internal::Internal */
) RETURNS MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_recv_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_send
CREATE  FUNCTION "molecularformula_send"(
	"input" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bytea /* alloc::vec::Vec<u8> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_send_wrapper';


-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::MolecularFormula
CREATE TYPE MolecularFormula (
	INTERNALLENGTH = variable,
	INPUT = molecularformula_in, /* molecular_formulas::molecular_formula::molecularformula_in */
	OUTPUT = molecularformula_out, /* molecular_formulas::molecular_formula::molecularformula_out */
	RECEIVE = molecularformula_recv, /* molecular_formulas::molecular_formula::molecularformula_recv */
	SEND = molecularformula_send, /* molecular_formulas::molecular_formula::molecularformula_send */
	STORAGE = extended
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_cmp
CREATE  FUNCTION "molecularformula_cmp"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_cmp_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_eq
CREATE  FUNCTION "molecularformula_eq"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_eq_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_eq
CREATE OPERATOR = (
	PROCEDURE="molecularformula_eq",
	LEFTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	RIGHTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	COMMUTATOR = =,
	NEGATOR = <>,
	RESTRICT = eqsel,
	JOIN = eqjoinsel,
	HASHES,
	MERGES
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_ge
CREATE  FUNCTION "molecularformula_ge"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_ge_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_ge
CREATE OPERATOR >= (
	PROCEDURE="molecularformula_ge",
	LEFTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	RIGHTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	COMMUTATOR = <=,
	NEGATOR = <,
	RESTRICT = scalargesel,
	JOIN = scalargejoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_gt
CREATE  FUNCTION "molecularformula_gt"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_gt_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_gt
CREATE OPERATOR > (
	PROCEDURE="molecularformula_gt",
	LEFTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	RIGHTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	COMMUTATOR = <,
	NEGATOR = <=,
	RESTRICT = scalargtsel,
	JOIN = scalargtjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_hash
CREATE  FUNCTION "molecularformula_hash"(
	"value" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_hash_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_le
CREATE  FUNCTION "molecularformula_le"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_le_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_le
CREATE OPERATOR <= (
	PROCEDURE="molecularformula_le",
	LEFTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	RIGHTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	COMMUTATOR = >=,
	NEGATOR = >,
	RESTRICT = scalarlesel,
	JOIN = scalarlejoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_lt
CREATE  FUNCTION "molecularformula_lt"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_lt_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_lt
CREATE OPERATOR < (
	PROCEDURE="molecularformula_lt",
	LEFTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	RIGHTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	COMMUTATOR = >,
	NEGATOR = >=,
	RESTRICT = scalarltsel,
	JOIN = scalarltjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_ne
CREATE  FUNCTION "molecularformula_ne"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_ne_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_ne
CREATE OPERATOR <> (
	PROCEDURE="molecularformula_ne",
	LEFTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	RIGHTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	COMMUTATOR = <>,
	NEGATOR = =,
	RESTRICT = neqsel,
	JOIN = neqjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::MolecularFormula
CREATE OPERATOR FAMILY MolecularFormula_btree_ops USING btree;
CREATE OPERATOR CLASS MolecularFormula_btree_ops DEFAULT FOR TYPE MolecularFormula USING btree FAMILY MolecularFormula_btree_ops AS
	OPERATOR 1 <,
	OPERATOR 2 <=,
	OPERATOR 3 =,
	OPERATOR 4 >=,
	OPERATOR 5 >,
	FUNCTION 1 molecularformula_cmp(MolecularFormula, MolecularFormula);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::MolecularFormula
CREATE OPERATOR FAMILY MolecularFormula_hash_ops USING hash;
CREATE OPERATOR CLASS MolecularFormula_hash_ops DEFAULT FOR TYPE MolecularFormula USING hash FAMILY MolecularFormula_hash_ops AS
	OPERATOR    1   =  (MolecularFormula, MolecularFormula),
	FUNCTION    1   molecularformula_hash(MolecularFormula);
/* </end connected objects> */

/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:40
-- pgrx_validation::str::must_be_distinct
CREATE  FUNCTION "must_be_distinct"(
	"left" TEXT, /* &str */
	"right" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_distinct_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/int.rs:68
-- pgrx_validation::int::must_be_distinct_i16
CREATE  FUNCTION "must_be_distinct_i16"(
	"left" smallint, /* i16 */
	"right" smallint /* i16 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_distinct_i16_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/int.rs:5
-- pgrx_validation::int::must_be_distinct_i32
CREATE  FUNCTION "must_be_distinct_i32"(
	"left" INT, /* i32 */
	"right" INT /* i32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_distinct_i32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/uuid.rs:5
-- pgrx_validation::uuid::must_be_distinct_uuid
CREATE  FUNCTION "must_be_distinct_uuid"(
	"left" uuid, /* rosetta_uuid::Uuid */
	"right" uuid /* rosetta_uuid::Uuid */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_distinct_uuid_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:6
-- pgrx_validation::str::must_be_email
CREATE  FUNCTION "must_be_email"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_email_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/font_awesome_icons.rs:1437
-- pgrx_validation::font_awesome_icons::must_be_font_awesome_class
CREATE  FUNCTION "must_be_font_awesome_class"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_font_awesome_class_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:47
-- pgrx_validation::float::must_be_greater_than_f32
CREATE  FUNCTION "must_be_greater_than_f32"(
	"value" real, /* f32 */
	"lower_bound" real /* f32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_greater_than_f32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:124
-- pgrx_validation::str::must_be_paragraph
CREATE  FUNCTION "must_be_paragraph"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_paragraph_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/int.rs:112
-- pgrx_validation::int::must_be_positive_i16
CREATE  FUNCTION "must_be_positive_i16"(
	"value" smallint /* i16 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_positive_i16_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/int.rs:49
-- pgrx_validation::int::must_be_positive_i32
CREATE  FUNCTION "must_be_positive_i32"(
	"value" INT /* i32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_positive_i32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:70
-- pgrx_validation::float::must_be_smaller_than_f32
CREATE  FUNCTION "must_be_smaller_than_f32"(
	"value" real, /* f32 */
	"lower_bound" real /* f32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_smaller_than_f32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/chrono.rs:5
-- pgrx_validation::chrono::must_be_smaller_than_utc
CREATE  FUNCTION "must_be_smaller_than_utc"(
	"left" timestamp with time zone, /* rosetta_timestamp::TimestampUTC */
	"right" timestamp with time zone /* rosetta_timestamp::TimestampUTC */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_smaller_than_utc_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:93
-- pgrx_validation::float::must_be_strictly_greater_than_f32
CREATE  FUNCTION "must_be_strictly_greater_than_f32"(
	"value" real, /* f32 */
	"lower_bound" real /* f32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_greater_than_f32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:139
-- pgrx_validation::float::must_be_strictly_greater_than_f64
CREATE  FUNCTION "must_be_strictly_greater_than_f64"(
	"value" double precision, /* f64 */
	"lower_bound" double precision /* f64 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_greater_than_f64_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:5
-- pgrx_validation::float::must_be_strictly_positive_f32
CREATE  FUNCTION "must_be_strictly_positive_f32"(
	"value" real /* f32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_positive_f32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:26
-- pgrx_validation::float::must_be_strictly_positive_f64
CREATE  FUNCTION "must_be_strictly_positive_f64"(
	"value" double precision /* f64 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_positive_f64_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/int.rs:91
-- pgrx_validation::int::must_be_strictly_positive_i16
CREATE  FUNCTION "must_be_strictly_positive_i16"(
	"value" smallint /* i16 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_positive_i16_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/int.rs:28
-- pgrx_validation::int::must_be_strictly_positive_i32
CREATE  FUNCTION "must_be_strictly_positive_i32"(
	"value" INT /* i32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_positive_i32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:116
-- pgrx_validation::float::must_be_strictly_smaller_than_f32
CREATE  FUNCTION "must_be_strictly_smaller_than_f32"(
	"value" real, /* f32 */
	"lower_bound" real /* f32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_smaller_than_f32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:162
-- pgrx_validation::float::must_be_strictly_smaller_than_f64
CREATE  FUNCTION "must_be_strictly_smaller_than_f64"(
	"value" double precision, /* f64 */
	"lower_bound" double precision /* f64 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_smaller_than_f64_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/chrono.rs:29
-- pgrx_validation::chrono::must_be_strictly_smaller_than_utc
CREATE  FUNCTION "must_be_strictly_smaller_than_utc"(
	"left" timestamp with time zone, /* rosetta_timestamp::TimestampUTC */
	"right" timestamp with time zone /* rosetta_timestamp::TimestampUTC */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_smaller_than_utc_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:26
-- pgrx_validation::str::must_not_be_empty
CREATE  FUNCTION "must_not_be_empty"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_not_be_empty_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:63
-- pgrx_validation::str::must_not_be_padded
CREATE  FUNCTION "must_not_be_padded"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_not_be_padded_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:82
-- pgrx_validation::str::must_not_contain_consecutive_whitespace
CREATE  FUNCTION "must_not_contain_consecutive_whitespace"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_not_contain_consecutive_whitespace_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:103
-- pgrx_validation::str::must_not_contain_control_characters
CREATE  FUNCTION "must_not_contain_control_characters"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_not_contain_control_characters_wrapper';
/* </end connected objects> */

CREATE TABLE IF NOT EXISTS ranks (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS colors (
    name TEXT UNIQUE NOT NULL,
    hexadecimal_value TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS units (
    name TEXT UNIQUE NOT NULL,
    unit TEXT UNIQUE NOT NULL,
    icon TEXT NOT NULL,
    colors_id SMALLINT NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS team_states (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS taxa (
    id INTEGER PRIMARY KEY UNIQUE,
    name TEXT NOT NULL,
    parent_id INTEGER,
    ranks_id SMALLINT NOT NULL REFERENCES ranks(id)
);
CREATE TABLE IF NOT EXISTS sample_states (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS roles (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS project_states (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS permanence_categories (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS organizations (
    name TEXT NOT NULL,
    url TEXT UNIQUE NOT NULL,
    country TEXT NOT NULL,
    alpha_two_code CountryCode NOT NULL,
    state_province TEXT,
    domain TEXT UNIQUE NOT NULL,
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS observation_subjects (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS materials (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS instrument_states (
    name TEXT UNIQUE NOT NULL,
    description TEXT UNIQUE NOT NULL,
    icon TEXT UNIQUE NOT NULL,
    colors_id SMALLINT UNIQUE NOT NULL REFERENCES colors(id),
    id SMALLSERIAL PRIMARY KEY
);
CREATE TABLE IF NOT EXISTS countries (
    iso CountryCode PRIMARY KEY UNIQUE,
    name TEXT UNIQUE NOT NULL
);
-- Enables the extension to generate UUIDs
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
-- Purpose: Enable the pg_trgm extension.
CREATE EXTENSION IF NOT EXISTS pg_trgm;
-- Purpose: Enable the pgrx_validation extension.
CREATE EXTENSION IF NOT EXISTS pgrx_validation;
-- Enables the PostGIS extension in the database.
CREATE EXTENSION IF NOT EXISTS postgis;SET TIME ZONE 'UTC';-- Enable the `iso_codes` extension.
CREATE EXTENSION IF NOT EXISTS iso_codes;
-- Enable several of the PGRX extensions.
CREATE EXTENSION IF NOT EXISTS media_types;
CREATE EXTENSION  IF NOT EXISTS "cas_codes";
CREATE EXTENSION  IF NOT EXISTS "molecular_formulas";-- Enables the extension to log execution statistics of SQL statements
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;CREATE TABLE IF NOT EXISTS cities (
	id SERIAL PRIMARY KEY,
	name TEXT NOT NULL,
	iso CountryCode NOT NULL REFERENCES countries(iso)
);CREATE TABLE IF NOT EXISTS login_providers (
  id SMALLSERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL UNIQUE CHECK (must_be_paragraph(name)),
  icon TEXT NOT NULL CHECK (must_be_font_awesome_class(icon)),
  client_id VARCHAR(255) NOT NULL CHECK (must_be_paragraph(client_id)),
  redirect_uri VARCHAR(255) NOT NULL,
  oauth_url VARCHAR(255) NOT NULL,
  scope VARCHAR(255) NOT NULL CHECK (must_be_paragraph(scope))
);
CREATE TABLE IF NOT EXISTS addresses (
	id SERIAL PRIMARY KEY,
	city_id INTEGER NOT NULL REFERENCES cities(id),
	street_name TEXT NOT NULL,
	house_number TEXT NOT NULL,
	postal_code TEXT NOT NULL,
	geolocation GEOGRAPHY(Point, 4326) NOT NULL,
	CONSTRAINT unique_address UNIQUE (city_id, street_name, house_number)
);CREATE TABLE IF NOT EXISTS temporary_user (
    id SERIAL PRIMARY KEY,
    email text NOT NULL CHECK (must_be_email(email)),
    login_provider_id SMALLINT NOT NULL REFERENCES login_providers (id) ON DELETE CASCADE,
    UNIQUE (email, login_provider_id)
);

-- We need to create a table to store users
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    first_name TEXT NOT NULL CHECK (must_be_paragraph(first_name)),
    last_name TEXT NOT NULL CHECK (must_be_paragraph(last_name)),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CHECK (must_be_smaller_than_utc(created_at, updated_at))
);

CREATE INDEX IF NOT EXISTS idx_users_first_name_last_name 
    ON users(first_name, last_name);

-- Since users may have multiple organizations, we need a join table to represent this relationship
CREATE TABLE IF NOT EXISTS user_organizations (
    user_id INTEGER NOT NULL,
    organization_id SMALLINT NOT NULL,
    PRIMARY KEY (user_id, organization_id),
    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
    FOREIGN KEY (organization_id) REFERENCES organizations (id) ON DELETE CASCADE
);CREATE TABLE IF NOT EXISTS brands (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE CHECK (must_be_paragraph(name)),
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER NOT NULL REFERENCES users(id),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CHECK (must_be_smaller_than_utc(created_at, updated_at))
);-- SQL to create the projects table.
CREATE TABLE IF NOT EXISTS projects (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL UNIQUE CHECK (must_be_paragraph(name)),
    description TEXT NOT NULL CHECK (must_be_paragraph(description)),
    state_id SMALLINT NOT NULL DEFAULT 1,
    icon TEXT NOT NULL CHECK (must_be_font_awesome_class(icon)),
    color_id SMALLINT NOT NULL DEFAULT 1,
    parent_project_id INTEGER,
    budget REAL,
    expenses REAL,
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER NOT NULL REFERENCES users(id),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expected_end_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE NOT NULL,
    FOREIGN KEY (state_id) REFERENCES project_states(id),
    FOREIGN KEY (color_id) REFERENCES colors(id),
    FOREIGN KEY (parent_project_id) REFERENCES projects(id) ON DELETE CASCADE,
    CHECK (must_be_distinct_i32(parent_project_id, id)),
    CHECK (must_be_distinct(name, description)),
    CHECK (must_be_smaller_than_utc(created_at, updated_at))
);
CREATE TABLE IF NOT EXISTS user_emails (
    id SERIAL PRIMARY KEY,
    email text NOT NULL UNIQUE CHECK (must_be_email(email)),
    created_by INTEGER NOT NULL REFERENCES users (id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    primary_email BOOLEAN NOT NULL DEFAULT TRUE,
    -- There can only be one user associated with an email address
    UNIQUE (email, created_by),
    -- There can only be one primary email address per user
    UNIQUE (created_by, primary_email)
);

CREATE TABLE IF NOT EXISTS email_providers (
    email_id INTEGER NOT NULL REFERENCES user_emails (id) ON DELETE CASCADE,
    login_provider_id SMALLINT NOT NULL REFERENCES login_providers (id) ON DELETE CASCADE,
    PRIMARY KEY (email_id, login_provider_id)
);
CREATE TABLE IF NOT EXISTS rooms (
	id SERIAL PRIMARY KEY,
	name TEXT NOT NULL  CHECK (must_be_paragraph(name)),
	description TEXT NOT NULL CHECK (must_be_paragraph(description)),
	qrcode UUID NOT NULL UNIQUE,
	addresses_id INTEGER NOT NULL REFERENCES addresses(id),
	geolocation GEOGRAPHY(POINT, 4326) NOT NULL,
	created_by INTEGER NOT NULL REFERENCES users(id),
	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	updated_by INTEGER NOT NULL REFERENCES users(id),
	updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CHECK (must_be_smaller_than_utc(created_at, updated_at))
);CREATE TABLE IF NOT EXISTS asset_models (
    id SERIAL PRIMARY KEY,
    most_concrete_table TEXT NOT NULL,
    name VARCHAR(255) NOT NULL UNIQUE CHECK (must_be_paragraph(name)),
    description TEXT NOT NULL CHECK (must_be_paragraph(description)),
    parent_model INTEGER REFERENCES asset_models(id) ON DELETE CASCADE,
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER NOT NULL REFERENCES users(id),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CHECK (must_be_distinct(name, description)),
    CHECK (must_be_distinct_i32(id, parent_model)),
    CHECK (must_be_smaller_than_utc(created_at, updated_at)),
    UNIQUE (id, parent_model)
);
CREATE TABLE IF NOT EXISTS assets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    most_concrete_table TEXT NOT NULL,
    name VARCHAR(255) CHECK (must_be_paragraph(name)),
    description TEXT CHECK (must_be_paragraph(description)),
    model INTEGER NOT NULL REFERENCES asset_models(id) ON DELETE CASCADE,
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER NOT NULL REFERENCES users(id),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CHECK (must_be_distinct(name, description)),
    CHECK (must_be_smaller_than_utc(created_at, updated_at)),
    UNIQUE (id, model),
    -- Assets of different models can have the same name, but not assets of the same model.
    UNIQUE (name, model)
);
CREATE TABLE IF NOT EXISTS physical_asset_models (
    id INTEGER PRIMARY KEY REFERENCES asset_models(id) ON DELETE CASCADE,
    parent_model INTEGER REFERENCES physical_asset_models(id) ON DELETE CASCADE,
    FOREIGN KEY (id, parent_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS physical_assets (
    id UUID PRIMARY KEY REFERENCES assets(id) ON DELETE CASCADE,
    model INTEGER NOT NULL REFERENCES physical_asset_models(id) ON DELETE CASCADE,
    FOREIGN KEY (id, model) REFERENCES assets(id, model)
);
CREATE TABLE IF NOT EXISTS digital_asset_models (
    id INTEGER PRIMARY KEY REFERENCES asset_models(id) ON DELETE CASCADE,
    parent_model INTEGER REFERENCES digital_asset_models(id) ON DELETE CASCADE,
    mime_type MediaType NOT NULL,
    FOREIGN KEY (id, parent_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS digital_assets (
    id UUID PRIMARY KEY REFERENCES assets(id) ON DELETE CASCADE,
    model INTEGER NOT NULL REFERENCES digital_asset_models(id) ON DELETE CASCADE,
    FOREIGN KEY (id, model) REFERENCES assets(id, model)
);
CREATE TABLE IF NOT EXISTS asset_compatibility_rules (
    left_asset_model INTEGER NOT NULL REFERENCES asset_models(id) ON DELETE CASCADE,
    right_asset_model INTEGER NOT NULL REFERENCES asset_models(id) ON DELETE CASCADE,
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (left_asset_model, right_asset_model),
    CHECK (
        must_be_distinct_i32(left_asset_model, right_asset_model)
    )
);
CREATE UNIQUE INDEX unique_asset_compatibility_pair ON asset_compatibility_rules (
    LEAST(left_asset_model, right_asset_model),
    GREATEST(left_asset_model, right_asset_model)
);
CREATE TABLE IF NOT EXISTS asset_model_ancestors (
    descendant_model INTEGER NOT NULL REFERENCES asset_models(id) ON DELETE CASCADE,
    ancestor_model INTEGER NOT NULL REFERENCES asset_models(id) ON DELETE CASCADE,
    PRIMARY KEY (descendant_model, ancestor_model)
);
-- When a new `asset_models` row is inserted, we also populate the `asset_model_ancestors` table
-- with the tautological relationship (a row is an ancestor of itself) and all the ancestors of its parent model.
CREATE OR REPLACE FUNCTION populate_asset_model_ancestors() RETURNS TRIGGER AS $$ BEGIN -- Insert the tautological relationship
INSERT INTO asset_model_ancestors (descendant_model, ancestor_model)
VALUES (NEW.id, NEW.id);
-- Insert all ancestors of the parent model
INSERT INTO asset_model_ancestors (descendant_model, ancestor_model)
SELECT NEW.id,
    ancestor_model
FROM asset_model_ancestors
WHERE descendant_model = NEW.parent_model AND NEW.parent_model IS NOT NULL;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER after_insert_asset_models
AFTER
INSERT ON asset_models FOR EACH ROW EXECUTE FUNCTION populate_asset_model_ancestors();
-- When an `asset_models` row is deleted, we also delete all its descendants.
CREATE OR REPLACE FUNCTION delete_descendant_asset_models() RETURNS TRIGGER AS $$ BEGIN
DELETE FROM asset_models
WHERE id IN (
        SELECT descendant_model
        FROM asset_model_ancestors
        WHERE ancestor_model = OLD.id
            AND descendant_model != OLD.id
    );
RETURN OLD;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER after_delete_asset_models
AFTER DELETE ON asset_models FOR EACH ROW EXECUTE FUNCTION delete_descendant_asset_models();CREATE TABLE IF NOT EXISTS teams (
    -- change to integer and the change it to serial in a new directoy
    id INTEGER PRIMARY KEY,
    -- a name of the team
    name TEXT NOT NULL UNIQUE CHECK (must_be_paragraph(name)),
    -- a description of the team
    description TEXT NOT NULL,
    icon TEXT NOT NULL CHECK (must_be_font_awesome_class(icon)),
    color_id SMALLINT NOT NULL DEFAULT 15,
    state_id SMALLINT NOT NULL DEFAULT 1,
    parent_team_id INTEGER,
    -- The user who created the team
    created_by INTEGER NOT NULL REFERENCES users(id),
    -- The date the team was created
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER NOT NULL REFERENCES users(id),
    -- The date the team was last updated
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (color_id) REFERENCES colors(id),
    FOREIGN KEY (state_id) REFERENCES team_states(id),
    FOREIGN KEY (parent_team_id) REFERENCES teams(id) ON DELETE CASCADE,
    CHECK (must_be_distinct_i32(parent_team_id, id)),
    CHECK (must_be_smaller_than_utc(created_at, updated_at))
);

CREATE TABLE IF NOT EXISTS team_members (
  team_id INTEGER NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
  member_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  PRIMARY KEY (team_id, member_id)
);

CREATE TABLE IF NOT EXISTS team_projects (
  team_id INTEGER NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
  project_id INTEGER NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  PRIMARY KEY (team_id, project_id)
);CREATE TABLE IF NOT EXISTS photographs (
	id UUID PRIMARY KEY REFERENCES digital_assets(id)
);-- Your SQL goes here
CREATE TABLE IF NOT EXISTS spectra_collections (
    id UUID PRIMARY KEY REFERENCES digital_assets(id) ON DELETE CASCADE
);CREATE TABLE IF NOT EXISTS reagent_models (
  id INTEGER PRIMARY KEY REFERENCES asset_models(id) ON DELETE CASCADE,
  purity REAL NOT NULL CHECK (
    must_be_strictly_positive_f32(purity)
    AND must_be_smaller_than_f32(purity, 100.0)
  ),
  cas_code CAS NOT NULL UNIQUE,
  molecular_formula MolecularFormula NOT NULL
);CREATE TABLE IF NOT EXISTS container_models (
    id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id)
);
CREATE TABLE IF NOT EXISTS volumetric_container_models (
    id INTEGER PRIMARY KEY REFERENCES container_models(id),
    -- The maximum volume of the container in liters.
    liters REAL NOT NULL CHECK (must_be_strictly_positive_f32(liters))
);
CREATE TABLE IF NOT EXISTS container_compatibility_rules (
    container_model INTEGER NOT NULL REFERENCES container_models(id),
    contained_asset_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
    -- The maximal quantity of the right trackable that can be associated with the left trackable.
    quantity SMALLINT CHECK (must_be_strictly_positive_i16(quantity)),
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (container_model, contained_asset_model),
    CHECK (
        must_be_distinct_i32(container_model, contained_asset_model)
    )
);
CREATE TABLE IF NOT EXISTS containers (
    id UUID PRIMARY KEY REFERENCES physical_assets(id) ON DELETE CASCADE,
    container_model INTEGER NOT NULL REFERENCES container_models(id),
    FOREIGN KEY (id, container_model) REFERENCES assets(id, model)
);
CREATE TABLE IF NOT EXISTS volumetric_containers (
    id UUID PRIMARY KEY REFERENCES containers(id) ON DELETE CASCADE,
    volumetric_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
    -- We ensure that the parent table's container_model is indeed a volumetric_container_model.
    FOREIGN KEY (id, volumetric_container_model) REFERENCES assets(id, model)
);CREATE TABLE IF NOT EXISTS weighing_device_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS volume_measuring_device_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS positioning_device_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS camera_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS pipette_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS pipette_tip_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS phone_models (
	id INTEGER PRIMARY KEY,
	CONSTRAINT phone_models_camera FOREIGN KEY (id) REFERENCES camera_models (id) ON DELETE CASCADE,
	CONSTRAINT phone_models_positioning FOREIGN KEY (id) REFERENCES positioning_device_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS freezer_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS freeze_dryer_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS centrifuge_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS ball_mill_machine_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);CREATE TABLE IF NOT EXISTS procedure_templates (
	-- Identifier of the procedure template
	procedure_template SERIAL PRIMARY KEY,
	-- The most concrete table variant descendant of this procedure template,
	-- which allows for rapidly determining the type of a procedure template
	-- without having to execute multiple queries.
	most_concrete_table TEXT NOT NULL,
	-- Human-readable name of the procedure template
	name TEXT UNIQUE NOT NULL CHECK (must_be_paragraph(name)),
	-- Human-readable description of the procedure template
	description TEXT NOT NULL CHECK (must_be_paragraph(description)),
	-- The user who created this procedure template
	created_by INTEGER NOT NULL REFERENCES users(id),
	-- The timestamp when this procedure template was created
	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	-- The user who last updated this procedure template
	updated_by INTEGER NOT NULL REFERENCES users(id),
	-- The timestamp when this procedure template was last updated
	updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP CHECK (must_be_smaller_than_utc(created_at, updated_at)),
	-- Whether this procedure template is deprecated and should not be used for new procedures
	deprecated BOOLEAN NOT NULL DEFAULT FALSE,
	-- We enforce that the name and description are distinct to avoid lazy duplicates
	CHECK (must_be_distinct(name, description))
);
CREATE TABLE IF NOT EXISTS parent_procedure_templates (
	PRIMARY KEY (parent, child),
	-- The parent procedure template
	parent INTEGER NOT NULL REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The child procedure template
	child INTEGER NOT NULL REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE CHECK (must_be_distinct_i32(parent, child)),
	-- The user who created this relationship
	created_by INTEGER NOT NULL REFERENCES users(id),
	-- The timestamp when this relationship was created
	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE IF NOT EXISTS next_procedure_templates (
	PRIMARY KEY (parent, predecessor, successor),
	-- The parent procedure template
	parent INTEGER NOT NULL REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The predecessor procedure template
	predecessor INTEGER NOT NULL REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The successor procedure template
	successor INTEGER NOT NULL REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE CHECK (must_be_distinct_i32(predecessor, successor)),
	-- The user who created this relationship
	created_by INTEGER NOT NULL REFERENCES users(id),
	-- The timestamp when this relationship was created
	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	-- We enforce that the parent procedure is indeed a parent of the predecessor procedure
	FOREIGN KEY (parent, predecessor) REFERENCES parent_procedure_templates(parent, child),
	-- We enforce that the parent procedure is indeed a parent of the successor procedure
	FOREIGN KEY (parent, successor) REFERENCES parent_procedure_templates(parent, child)
);
-- Trigger function
CREATE OR REPLACE FUNCTION ensure_parent_procedure_templates() RETURNS TRIGGER LANGUAGE plpgsql AS $$ BEGIN -- Insert predecessor parent relationship if missing
INSERT INTO parent_procedure_templates (parent, child, created_by)
VALUES (NEW.parent, NEW.predecessor, NEW.created_by) ON CONFLICT (parent, child) DO NOTHING;
-- Insert successor parent relationship if missing
INSERT INTO parent_procedure_templates (parent, child, created_by)
VALUES (NEW.parent, NEW.successor, NEW.created_by) ON CONFLICT (parent, child) DO NOTHING;
RETURN NEW;
END;
$$;
-- Trigger
CREATE OR REPLACE TRIGGER before_insert_next_procedure_templates BEFORE
INSERT ON next_procedure_templates FOR EACH ROW EXECUTE FUNCTION ensure_parent_procedure_templates();
CREATE TABLE IF NOT EXISTS procedure_template_asset_models (
	-- Identifier of the procedure template asset model
	id SERIAL PRIMARY KEY,
	-- The name of the procedure template asset model
	name TEXT NOT NULL CHECK (must_be_paragraph(name)),
	-- Procedure template this asset model is associated with
	procedure_template INTEGER NOT NULL REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- Optional reference to a procedure template asset model from another procedure template
	-- which this procedure template asset model is based on
	based_on INTEGER REFERENCES procedure_template_asset_models(id),
	-- The asset model this procedure template asset model is associated with
	asset_model INTEGER NOT NULL REFERENCES asset_models(id) ON DELETE CASCADE,
	-- We enforce that, if based_on is specified, then the asset model must be the same as the one
	-- of the procedure template asset model it is based on.
	FOREIGN KEY (based_on, asset_model) REFERENCES procedure_template_asset_models(id, asset_model),
	-- The name of the procedure template asset model must be unique for a given procedure template
	-- (i.e., you cannot have two asset models with the same name for the same procedure template)
	UNIQUE (procedure_template, name),
	-- We create an index on (procedure_template, asset_model) to allow for foreign
	-- keys from the concrete procedures to check that the asset model is correctly aligned.
	UNIQUE (id, procedure_template),
	-- We create an index on (procedure_template, asset_model) to allow for foreign
	-- keys from the concrete procedures to check that the asset model is correctly aligned.
	UNIQUE (id, asset_model)
);
CREATE OR REPLACE FUNCTION inherit_procedure_template_asset_models() RETURNS TRIGGER AS $$ BEGIN
INSERT INTO procedure_template_asset_models (
		name,
		procedure_template,
		based_on,
		asset_model
	)
SELECT pam.name,
	NEW.parent,
	pam.id,
	pam.asset_model
FROM procedure_template_asset_models pam
WHERE pam.procedure_template = NEW.child;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER trg_inherit_procedure_template_asset_models
AFTER
INSERT ON parent_procedure_templates FOR EACH ROW EXECUTE FUNCTION inherit_procedure_template_asset_models();CREATE TABLE IF NOT EXISTS packaging_models (
    id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id)
);CREATE TABLE IF NOT EXISTS bead_models (
    id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id),
    diameter_millimeters REAL NOT NULL CHECK (
        must_be_strictly_positive_f32(diameter_millimeters)
    )
);CREATE TABLE IF NOT EXISTS cap_models (
    id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id)
);CREATE TABLE IF NOT EXISTS sample_source_models (
  id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id)
);
CREATE TABLE IF NOT EXISTS sample_sources (
  id UUID PRIMARY KEY REFERENCES physical_assets(id),
  model INTEGER NOT NULL REFERENCES sample_source_models(id),
  FOREIGN KEY (id, model) REFERENCES assets(id, model)
);CREATE TABLE IF NOT EXISTS spectra (
    id UUID PRIMARY KEY REFERENCES digital_assets(id) ON DELETE CASCADE,
    spectra_collection_id UUID NOT NULL REFERENCES spectra_collections(id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS procedures (
	-- The ID of this procedure.
	procedure UUID PRIMARY KEY DEFAULT gen_random_uuid(),
	-- The procedure template of this procedure.
	procedure_template INTEGER NOT NULL REFERENCES procedure_templates(procedure_template),
	-- The parent procedure (if any) of this procedure.
	parent_procedure UUID REFERENCES procedures(procedure) ON DELETE CASCADE CHECK (
		must_be_distinct_uuid(procedure, parent_procedure)
	),
	-- The parent procedure template (if any) of this procedure.
	parent_procedure_template INTEGER REFERENCES procedure_templates(procedure_template) CHECK (
		must_be_distinct_i32(procedure_template, parent_procedure_template)
	),
	-- The predecessor procedure (if any) of this procedure.
	predecessor_procedure UUID REFERENCES procedures(procedure) ON DELETE CASCADE CHECK (
		must_be_distinct_uuid(procedure, predecessor_procedure)
	),
	-- The predecessor procedure template (if any) of this procedure.
	predecessor_procedure_template INTEGER REFERENCES procedure_templates(procedure_template) CHECK (
		must_be_distinct_i32(
			procedure_template,
			predecessor_procedure_template
		)
	),
	-- The name of the most concrete table this procedure is associated with.
	most_concrete_table TEXT NOT NULL,
	-- User who created this procedure.
	created_by INTEGER NOT NULL REFERENCES users(id),
	-- Timestamp when this procedure was created.
	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	-- User who last updated this procedure.
	updated_by INTEGER NOT NULL REFERENCES users(id),
	-- Timestamp when this procedure was last updated.
	updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	-- We check that the created_at is before or equal to updated_at.
	CHECK (must_be_smaller_than_utc(created_at, updated_at)),
	-- We create an index on (procedure_template, parent_procedure_template) to allow for foreign
	-- keys from the concrete procedures to check that the procedure template is correctly aligned.
	UNIQUE (procedure, procedure_template),
	-- We enforce that if a parent procedure and parent procedure template are specified,
	-- then the parent procedure must indeed be of the specified parent procedure template.
	FOREIGN KEY (parent_procedure, parent_procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- We enforce that if a predecessor procedure and predecessor procedure template are specified,
	-- then the predecessor procedure must indeed be of the specified predecessor procedure template.
	FOREIGN KEY (
		predecessor_procedure,
		predecessor_procedure_template
	) REFERENCES procedures(procedure, procedure_template),
	-- We enforce that if a parent procedure template is specified, then the parent procedure template
	-- must indeed be a valid parent procedure template for the specified procedure template.
	FOREIGN KEY (parent_procedure_template, procedure_template) REFERENCES parent_procedure_templates(parent, child),
	-- We enforce that if both a predecessor procedure template and a parent procedure template are specified,
	-- then there must exist a row in `next_procedure_templates`
	FOREIGN KEY (
		parent_procedure_template,
		predecessor_procedure_template,
		procedure_template
	) REFERENCES next_procedure_templates(parent, predecessor, successor),
	-- We check that either both parent_procedure and parent_procedure_template are NULL,
	-- or neither is NULL.
	CHECK (
		(
			parent_procedure IS NULL
			AND parent_procedure_template IS NULL
		)
		OR (
			parent_procedure IS NOT NULL
			AND parent_procedure_template IS NOT NULL
		)
	),
	-- We check that either both predecessor_procedure and predecessor_procedure_template are NULL,
	-- or neither is NULL.
	CHECK (
		(
			predecessor_procedure IS NULL
			AND predecessor_procedure_template IS NULL
		)
		OR (
			predecessor_procedure IS NOT NULL
			AND predecessor_procedure_template IS NOT NULL
		)
	),
	-- We check that if the previous procedure is specified, then the parent procedure must also be specified.
	CHECK (
		(predecessor_procedure IS NULL)
		OR (parent_procedure IS NOT NULL)
	)
);
CREATE TABLE IF NOT EXISTS procedure_assets (
	-- The ID of this procedure asset.
	id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
	-- The ID of the procedure this asset is used in.
	procedure UUID NOT NULL REFERENCES procedures(procedure),
	-- The procedure template of the procedure this asset is used in.
	procedure_template INTEGER NOT NULL REFERENCES procedure_templates(procedure_template),
	-- The asset model of the asset used in this procedure.
	asset_model INTEGER NOT NULL REFERENCES asset_models(id),
	-- The specific asset used in this procedure (if any).
	asset UUID REFERENCES assets(id),
	-- We enforce that there must be a procedure template asset for this asset.
	procedure_template_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The ancestor asset model defined in the procedure template asset.
	ancestor_model INTEGER NOT NULL REFERENCES asset_models(id),
	-- The procedure template must match the procedure template of the procedure.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The procedure template asset must must be compatible with the procedure template of the procedure.
	FOREIGN KEY (
		procedure_template_asset_model,
		procedure_template
	) REFERENCES procedure_template_asset_models(id, procedure_template),
	-- We check that the ancestor asset is indeed the one defined in the procedure template asset.
	FOREIGN KEY (
		procedure_template_asset_model,
		ancestor_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the asset is indeed a descendant of the ancestor asset defined in the procedure template asset.
	FOREIGN KEY (asset_model, ancestor_model) REFERENCES asset_model_ancestors(descendant_model, ancestor_model),
	-- We check that the specified asset (if any) is indeed of the specified asset model.
	FOREIGN KEY (asset, asset_model) REFERENCES assets(id, model),
	-- We create a unique index to allow for foreign keys checking that the current procedure asset
	-- corresponds to a specific procedure template asset model in the procedure template.
	UNIQUE (id, procedure_template_asset_model),
	-- We create a unique index to allow for foreign keys checking that the current procedure asset
	-- corresponds to a specific asset model.
	UNIQUE (id, asset_model),
	-- We create a unique index to allow for foreign keys checking that the current procedure asset
	-- corresponds to a specific asset (if any).
	UNIQUE (id, asset)
);
-- When we insert a procedure assets, the parent procedure if any
-- must also receive its own version of the procedure asset. The
-- parent procedure's procedure asset will reference many of the
-- same fields, but the `procedure_template_asset_model` will be
-- the one defined in the parent procedure template which is characterized
-- by being `based_on` the current procedure template asset model.
CREATE OR REPLACE FUNCTION inherit_procedure_assets() RETURNS TRIGGER AS $$ BEGIN
INSERT INTO procedure_assets (
		procedure,
		procedure_template,
		asset_model,
		asset,
		procedure_template_asset_model,
		ancestor_model
	)
SELECT p.parent_procedure,
	p.parent_procedure_template,
	NEW.asset_model,
	NEW.asset,
	ptam.id,
	NEW.ancestor_model
FROM procedures p
	JOIN procedure_template_asset_models ptam ON ptam.based_on = NEW.procedure_template_asset_model
	AND ptam.procedure_template = p.parent_procedure_template
WHERE p.procedure = NEW.procedure
	AND p.parent_procedure IS NOT NULL;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER trg_inherit_procedure_assets
AFTER
INSERT ON procedure_assets FOR EACH ROW EXECUTE FUNCTION inherit_procedure_assets();CREATE TABLE IF NOT EXISTS commercial_products (
	id INTEGER PRIMARY KEY REFERENCES asset_models(id),
	deprecation_date TIMESTAMP WITH TIME ZONE,
	brand_id INTEGER NOT NULL REFERENCES brands(id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS commercial_weighing_device_models (
	id INTEGER PRIMARY KEY,
	weighing_device_model INTEGER NOT NULL REFERENCES weighing_device_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES weighing_device_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, weighing_device_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_volume_measuring_device_models (
	id INTEGER PRIMARY KEY,
	volume_measuring_device_model INTEGER NOT NULL REFERENCES volume_measuring_device_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES volume_measuring_device_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, volume_measuring_device_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_pipette_models (
	id INTEGER PRIMARY KEY,
	pipette_model INTEGER NOT NULL REFERENCES pipette_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES pipette_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, pipette_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_pipette_tip_models (
	id INTEGER PRIMARY KEY,
	pipette_tip_model INTEGER NOT NULL REFERENCES pipette_tip_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES pipette_tip_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, pipette_tip_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_packaging_models (
	id INTEGER PRIMARY KEY,
	packaging_model INTEGER NOT NULL REFERENCES packaging_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES packaging_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, packaging_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_bead_models (
	id INTEGER PRIMARY KEY,
	bead_model INTEGER NOT NULL REFERENCES bead_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES bead_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, bead_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_cap_models (
	id INTEGER PRIMARY KEY,
	cap_model INTEGER NOT NULL REFERENCES cap_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES cap_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, cap_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_ball_mill_machine_models (
	id INTEGER PRIMARY KEY,
	ball_mill_machine_model INTEGER NOT NULL REFERENCES ball_mill_machine_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES ball_mill_machine_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, ball_mill_machine_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_centrifuge_models (
	id INTEGER PRIMARY KEY,
	centrifuge_model INTEGER NOT NULL REFERENCES centrifuge_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES centrifuge_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, centrifuge_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_freezer_models (
	id INTEGER PRIMARY KEY,
	freezer_model INTEGER NOT NULL REFERENCES freezer_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES freezer_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, freezer_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_freeze_dryer_models (
	id INTEGER PRIMARY KEY,
	freeze_dryer_model INTEGER NOT NULL REFERENCES freeze_dryer_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES freeze_dryer_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, freeze_dryer_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_positioning_device_models (
	id INTEGER PRIMARY KEY,
	positioning_device_model INTEGER NOT NULL REFERENCES positioning_device_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES positioning_device_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, positioning_device_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_camera_models (
	id INTEGER PRIMARY KEY,
	camera_model INTEGER NOT NULL REFERENCES camera_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES camera_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, camera_model) REFERENCES asset_models(id, parent_model)
);CREATE TABLE IF NOT EXISTS organism_models (
  id INTEGER PRIMARY KEY REFERENCES sample_source_models(id)
);
CREATE TABLE IF NOT EXISTS organisms (
  id UUID PRIMARY KEY REFERENCES sample_sources(id),
  model INTEGER NOT NULL REFERENCES organism_models(id),
  FOREIGN KEY (id, model) REFERENCES assets(id, model)
);CREATE TABLE IF NOT EXISTS sample_models (
  id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id),
  sample_source_model INTEGER NOT NULL REFERENCES sample_source_models(id),
	-- We create a unique index to allow for foreign keys checking that there exist a `sample_source_model`
	-- for the current `sample_model`.
  UNIQUE (id, sample_source_model)
);

CREATE TABLE IF NOT EXISTS samples (
  id UUID PRIMARY KEY REFERENCES physical_assets(id),
  model INTEGER NOT NULL REFERENCES sample_models(id),
  sample_source UUID REFERENCES sample_sources(id),
  sample_source_model INTEGER NOT NULL REFERENCES sample_source_models(id),
  FOREIGN KEY (id, model) REFERENCES assets(id, model),
  FOREIGN KEY (model, sample_source_model) REFERENCES sample_models(id, sample_source_model),
  FOREIGN KEY (sample_source, sample_source_model) REFERENCES assets(id, model)
);CREATE TABLE IF NOT EXISTS storage_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The storage temperature in Kelvin.
	kelvin REAL NOT NULL DEFAULT 293.15 CHECK (must_be_strictly_positive_f32(kelvin)),
	-- Tolerance percentage for the storage temperature.
	kelvin_tolerance_percentage REAL NOT NULL DEFAULT 1.0 CHECK (
		must_be_strictly_positive_f32(kelvin_tolerance_percentage)
		AND must_be_smaller_than_f32(kelvin_tolerance_percentage, 100.0)
	),
	-- The container that will be used for storage.
	stored_into_model INTEGER NOT NULL REFERENCES container_models(id),
	procedure_template_stored_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The asset that is being stored.
	stored_asset_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	procedure_template_stored_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- We check that the `stored_into_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_stored_into_model,
		stored_into_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `stored_asset_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_stored_asset_model,
		stored_asset_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `stored_into_model` is indeed a container that can hold the `stored_asset_model`.
	FOREIGN KEY (stored_into_model, stored_asset_model) REFERENCES container_compatibility_rules(container_model, contained_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_stored_into_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_stored_into_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_stored_asset_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_stored_asset_model
	)
);
CREATE TABLE IF NOT EXISTS storage_procedures (
	-- Identifier of the storage procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a storage procedure template.
	procedure_template INTEGER NOT NULL REFERENCES storage_procedure_templates(procedure_template),
	-- The asset being stored, which must be a physical asset.
	stored_asset UUID NOT NULL REFERENCES physical_assets(id),
	-- The model of the asset being stored, which must be a physical asset model.
	stored_asset_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	-- The procedure template asset model describing the `stored_asset`.
	procedure_template_stored_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset describing the `stored_asset`.
	procedure_stored_asset UUID NOT NULL REFERENCES procedure_assets(id),
	-- The container into which the asset is being stored.
	stored_into UUID NOT NULL REFERENCES containers(id),
	-- The model of the container into which the asset is being stored.
	stored_into_model INTEGER NOT NULL REFERENCES container_models(id),
	-- The procedure template asset model describing the `stored_into`.
	procedure_template_stored_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset describing the `stored_into`.
	procedure_stored_into UUID NOT NULL REFERENCES procedure_assets(id),
	-- The current procedure must be a storage procedure.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The procedure template asset model describing the `stored_asset` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_stored_asset_model
	) REFERENCES storage_procedure_templates(
		procedure_template,
		procedure_template_stored_asset_model
	),
	-- The procedure template asset model describing the `stored_into` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_stored_into_model
	) REFERENCES storage_procedure_templates(
		procedure_template,
		procedure_template_stored_into_model
	),
	-- The procedure template asset model and the procedure asset describing the `stored_asset`
	-- must be compatible.
	FOREIGN KEY (
		procedure_stored_asset,
		procedure_template_stored_asset_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- The procedure template asset model and the procedure asset describing the `stored_into`
	-- must be compatible.
	FOREIGN KEY (
		procedure_stored_into,
		procedure_template_stored_into_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- Check the compatibility between the `stored_asset` and the `stored_into_model`.
	FOREIGN KEY (stored_into_model, stored_asset_model) REFERENCES container_compatibility_rules(container_model, contained_asset_model),
	-- We check that the `procedure_stored_asset` is associated to the `stored_asset_model`.
	FOREIGN KEY (procedure_stored_asset, stored_asset_model) REFERENCES procedure_assets(id, asset_model),
	-- We check that the `procedure_stored_into` is associated to the `stored_into_model`.
	FOREIGN KEY (procedure_stored_into, stored_into_model) REFERENCES procedure_assets(id, asset_model),
	-- We check that the `procedure_stored_asset` is associated to the `stored_asset`.
	FOREIGN KEY (procedure_stored_asset, stored_asset) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_stored_into` is associated to the `stored_into`.
	FOREIGN KEY (procedure_stored_into, stored_into) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS capping_procedure_templates (
	-- Identifier of the capping procedure template, which is also a foreign key to the general procedure template.
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The container to be capped.
	capped_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The procedure template associated with the container model.
	procedure_template_capped_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The cap to be used for the container.
	capped_with_model INTEGER NOT NULL REFERENCES cap_models(id),
	-- The procedure template associated with the cap model.
	procedure_template_capped_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- We check that the `container_model` is indeed the trackable that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_capped_container_model,
		capped_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `capped_with_model` is indeed a trackable that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_capped_with_model,
		capped_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `capped_with_model` is indeed a cap that can be used with the `capped_container_model`.
	FOREIGN KEY (capped_container_model, capped_with_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_capped_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_capped_container_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_capped_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_capped_with_model
	)
);
CREATE TABLE IF NOT EXISTS capping_procedures (
	-- Identifier of the capping procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- We enforce that the model of this procedure must be a capping procedure template.
	procedure_template INTEGER NOT NULL REFERENCES capping_procedure_templates(procedure_template),
	-- The container being capped, which must be a volumetric container.
	capped_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The model of the container being capped.
	capped_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The procedure template asset model describing the `capped_container`.
	procedure_template_capped_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset describing the `capped_container`.
	procedure_capped_container UUID NOT NULL REFERENCES procedure_assets(id),
	-- The cap being used, which must be a cap model.
	capped_with_model INTEGER NOT NULL REFERENCES cap_models(id),
	-- The procedure template asset model describing the `capped_with_model`.
	procedure_template_capped_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset describing the `capped_with_model`.
	procedure_capped_with UUID NOT NULL REFERENCES procedure_assets(id),
	-- The current procedure must be a capping procedure.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The procedure template asset model describing the `capped_container` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_capped_container_model
	) REFERENCES capping_procedure_templates(
		procedure_template,
		procedure_template_capped_container_model
	),
	-- The procedure template asset model describing the `capped_with_model` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_capped_with_model
	) REFERENCES capping_procedure_templates(
		procedure_template,
		procedure_template_capped_with_model
	),
	-- The procedure template asset model and the procedure asset describing the `capped_container`
	-- must be compatible.
	FOREIGN KEY (
		procedure_capped_container,
		procedure_template_capped_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- The procedure template asset model and the procedure asset describing the `capped_with_model`
	-- must be compatible.
	FOREIGN KEY (
		procedure_capped_with,
		procedure_template_capped_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We ensure that the `procedure_capped_container` is associated with the `capped_container_model`.
	FOREIGN KEY (
		procedure_capped_container,
		capped_container_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We ensure that the `procedure_capped_with` is associated with the `capped_with_model`.
	FOREIGN KEY (procedure_capped_with, capped_with_model) REFERENCES procedure_assets(id, asset_model),
	-- We ensure that the `procedure_capped_container` is associated with the `capped_container`.
	FOREIGN KEY (procedure_capped_container, capped_container) REFERENCES procedure_assets(id, asset),
	-- We check that the `capped_container_model` is compatible with the `capped_with_model`.
	FOREIGN KEY (capped_container_model, capped_with_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model)
);CREATE TABLE IF NOT EXISTS disposal_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The disposed asset asset model being disposed of.
	disposed_asset_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	-- The associated procedure asset model for the disposed asset.
	procedure_template_disposed_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The disposed asset model must match the procedure template of the procedure.
	FOREIGN KEY (
		procedure_template_disposed_asset_model,
		disposed_asset_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_disposed_asset_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_disposed_asset_model
	)
);
CREATE TABLE IF NOT EXISTS disposal_procedures (
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The model of the procedure.
	procedure_template INTEGER NOT NULL REFERENCES disposal_procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The disposed asset is the one that is being disposed_asset of.
	disposed_asset UUID REFERENCES physical_assets(id),
	-- The procedure template asset model associated to the `disposed_asset`.
	procedure_template_disposed_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `disposed_asset`.
	procedure_disposed_asset UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We ensure that the parent table's procedure_template is indeed a disposal_procedure_template.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The procedure template asset model describing the `disposed_asset` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_disposed_asset_model
	) REFERENCES disposal_procedure_templates(
		procedure_template,
		procedure_template_disposed_asset_model
	),
	-- We enforce that the `procedure_disposed_asset` is associated with the `procedure_template_disposed_asset_model`.
	FOREIGN KEY (
		procedure_disposed_asset,
		procedure_template_disposed_asset_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the `procedure_disposed_asset` is associated with the `disposed_asset`.
	FOREIGN KEY (procedure_disposed_asset, disposed_asset) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS packaging_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	packaged_with_model INTEGER NOT NULL REFERENCES packaging_models(id),
	procedure_template_packaged_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	sample_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	procedure_template_sample_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- We check that the `packaged_with_model` is indeed an asset model that is compatible with the procedure template asset model.
	FOREIGN KEY (
		procedure_template_packaged_with_model,
		packaged_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `sample_model` is indeed an asset model that is compatible with the procedure template asset model.
	FOREIGN KEY (
		procedure_template_sample_model,
		sample_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- The `sample_model` must be compatible with the `packaged_with_model`.
	FOREIGN KEY (packaged_with_model, sample_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_packaged_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_packaged_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_sample_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_sample_model
	)
);
CREATE TABLE IF NOT EXISTS packaging_procedures (
	-- The extended `procedure`.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The procedure template of the extended `procedure`.
	procedure_template INTEGER NOT NULL REFERENCES packaging_procedure_templates(procedure_template),
	-- The sample being packaged, which must be a physical asset.
	sample UUID NOT NULL REFERENCES physical_assets(id),
	-- The model of the sample being packaged, which must be a physical asset model.
	sample_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	-- The procedure template asset model associated to the `sample`.
	procedure_template_sample_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `sample`.
	procedure_sample UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The packaging used for packaging, which must be a packaging model.
	packaged_with_model INTEGER NOT NULL REFERENCES packaging_models(id),
	-- The procedure template asset model associated to the `packaged_with_model`.
	procedure_template_packaged_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `packaged_with_model`.
	procedure_packaged_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is a packaging procedure.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_packaged_with_model` must be the same as in the `packaging_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_packaged_with_model
	) REFERENCES packaging_procedure_templates(
		procedure_template,
		procedure_template_packaged_with_model
	),
	-- The `procedure_template_sample_model` must be the same as in the `packaging_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_sample_model
	) REFERENCES packaging_procedure_templates(
		procedure_template,
		procedure_template_sample_model
	),
	-- We check that the `procedure_sample` is associated to the `sample`.
	FOREIGN KEY (procedure_sample, sample) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_packaged_with` is associated to the `packaged_with_model`.
	FOREIGN KEY (procedure_packaged_with, packaged_with_model) REFERENCES procedure_assets(id, asset_model),
	-- We check that the `procedure_sample` is indeed associated to the `procedure_template_sample_model`.
	FOREIGN KEY (
		procedure_sample,
		procedure_template_sample_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_packaged_with` is indeed associated to the `procedure_template_packaged_with_model`.
	FOREIGN KEY (
		procedure_packaged_with,
		procedure_template_packaged_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `sample` is indeed compatible with the `packaged_with_model`.
	FOREIGN KEY (packaged_with_model, sample_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We check that the `procedure_sample` is associated to the `sample_model`.
	FOREIGN KEY (procedure_sample, sample_model) REFERENCES procedure_assets(id, asset_model)
);CREATE TABLE IF NOT EXISTS commercial_product_lots (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id) ON DELETE CASCADE,
	lot TEXT NOT NULL,
	product_model INTEGER NOT NULL REFERENCES commercial_products(id) ON DELETE CASCADE,
	-- A lot must be unique within the scope of a product model.
	UNIQUE (lot, product_model),
	-- The parent product model must be a commercial product.
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_weighing_device_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES weighing_device_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_weighing_device_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_volume_measuring_device_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES volume_measuring_device_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_volume_measuring_device_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_pipette_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES pipette_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_pipette_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_pipette_tip_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES pipette_tip_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_pipette_tip_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_packaging_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES packaging_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_packaging_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_bead_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES bead_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_bead_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_cap_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES cap_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_cap_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_ball_mill_machine_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES ball_mill_machine_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_ball_mill_machine_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_centrifuge_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES centrifuge_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_centrifuge_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_freezer_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES freezer_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_freezer_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_freeze_dryer_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES freeze_dryer_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_freeze_dryer_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_positioning_device_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES positioning_device_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_positioning_device_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_camera_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES camera_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_camera_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);-- Your SQL goes here
-- A migration to create the organism_taxa table.
-- This is a N to M relationship between organisms and taxa.
-- An organism can be associated to no or more taxa, and a taxon can be found in multiple organisms.
--
CREATE TABLE IF NOT EXISTS organism_taxa (
  created_by INTEGER NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  organism_id UUID NOT NULL,
  taxon_id INTEGER NOT NULL,
  PRIMARY KEY (organism_id, taxon_id),
  FOREIGN KEY (created_by) REFERENCES users(id),
  FOREIGN KEY (organism_id) REFERENCES organisms(id) ON DELETE CASCADE,
  FOREIGN KEY (taxon_id) REFERENCES taxa(id)
);CREATE TABLE IF NOT EXISTS weighing_devices (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_weighing_device_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS volume_measuring_devices (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_volume_measuring_device_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS pipettes (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_pipette_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS ball_mill_machines (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_ball_mill_machine_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS centrifuges (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_centrifuge_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS freezers (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_freezer_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS freeze_dryers (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_freeze_dryer_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS positioning_devices (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_positioning_device_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS cameras (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_camera_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);CREATE TABLE IF NOT EXISTS photograph_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The device used for photograph.
	photographed_with_model INTEGER NOT NULL REFERENCES camera_models(id),
	procedure_template_photographed_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	photographed_asset_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	procedure_template_photographed_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	photograph_model INTEGER NOT NULL REFERENCES digital_asset_models(id),
	procedure_template_photograph_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- We check that the `photographed_with_model` is indeed a trackable that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_photographed_with_model,
		photographed_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_photographed_asset_model,
		photographed_asset_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_photograph_model,
		photograph_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_photographed_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_photographed_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_photographed_asset_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_photographed_asset_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_photograph_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_photograph_model
	)
);
CREATE TABLE IF NOT EXISTS photograph_procedures (
	-- Identifier of the photograph procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a photograph procedure template.
	procedure_template INTEGER NOT NULL REFERENCES photograph_procedure_templates(procedure_template),
	-- The asset being photographed, which must be a physical asset.
	photographed_asset UUID REFERENCES physical_assets(id),
	-- The procedure template asset model associated to the `photographed_asset`.
	procedure_template_photographed_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `photographed_asset`.
	procedure_photographed_asset UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The positioning device used for photograph. This field is optional, as the positioning device might not necessarily be tracked.
	photographed_with UUID REFERENCES cameras(id),
	-- The procedure template asset model associated to the `photographed_with_model`.
	procedure_template_photographed_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `photographed_with`.
	procedure_photographed_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The resulting photograph.
	photograph UUID NOT NULL REFERENCES photographs(id) ON DELETE CASCADE,
	-- The procedure template asset model associated to the `photograph_model`.
	procedure_template_photograph_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `photograph`.
	procedure_photograph UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the current `photograph` has indeed the same `photograph_template`.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_photographed_with_model` must be the same as in the `photograph_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_photographed_with_model
	) REFERENCES photograph_procedure_templates(
		procedure_template,
		procedure_template_photographed_with_model
	),
	-- The `procedure_template_photographed_asset_model` must be the same as in the `photograph_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_photographed_asset_model
	) REFERENCES photograph_procedure_templates(
		procedure_template,
		procedure_template_photographed_asset_model
	),
	-- The `procedure_template_photograph_model` must be the same as in the `photograph_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_photograph_model
	) REFERENCES photograph_procedure_templates(
		procedure_template,
		procedure_template_photograph_model
	),
	-- We check that the `procedure_photographed_with` is associated to the same `procedure_template_photographed_with_model`.
	FOREIGN KEY (
		procedure_photographed_with,
		procedure_template_photographed_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_photographed_asset` is associated to the same `procedure_template_photographed_asset_model`.
	FOREIGN KEY (
		procedure_photographed_asset,
		procedure_template_photographed_asset_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_photograph` is associated to the same `procedure_template_photograph_model`.
	FOREIGN KEY (
		procedure_photograph,
		procedure_template_photograph_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_photographed_asset` is associated to the `photographed_asset`.
	FOREIGN KEY (procedure_photographed_asset, photographed_asset) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_photographed_with` is associated to the `photographed_with`.
	FOREIGN KEY (procedure_photographed_with, photographed_with) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_photograph` is associated to the `photograph`.
	FOREIGN KEY (procedure_photograph, photograph) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS geolocation_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The device used for geolocation.
	geolocated_with_model INTEGER NOT NULL REFERENCES positioning_device_models(id),
	procedure_template_geolocated_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	geolocated_asset_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	procedure_template_geolocated_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- We check that the `geolocated_with_model` is indeed an asset model that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_geolocated_with_model,
		geolocated_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the asset model is indeed a procedure asset model.
	FOREIGN KEY (
		procedure_template_geolocated_asset_model,
		geolocated_asset_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_geolocated_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_geolocated_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_geolocated_asset_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_geolocated_asset_model
	)
);
CREATE TABLE IF NOT EXISTS geolocation_procedures (
	-- Identifier of the geolocation procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a geolocation procedure template.
	procedure_template INTEGER NOT NULL REFERENCES geolocation_procedure_templates(procedure_template),
	-- The asset being geolocated, which must be a physical asset.
	geolocated_asset UUID NOT NULL REFERENCES physical_assets(id),
	-- The procedure template asset model associated to the `geolocated_asset`.
	procedure_template_geolocated_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `geolocated_asset`.
	procedure_geolocated_asset UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The positioning device used for geolocation. This field is optional, as the positioning device might not necessarily be tracked.
	geolocated_with UUID REFERENCES positioning_devices(id),
	-- The procedure asset associated to the `geolocated_with`.
	procedure_geolocated_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The procedure template asset model associated to the `geolocated_with_model`.
	procedure_template_geolocated_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The latitude and longitude of the geolocation.
	location GEOGRAPHY(POINT, 4326) NOT NULL,
	-- We enforce that the current `geolocation` has indeed the same `geolocation_template`.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_geolocated_with_model` must be the same as in the `geolocation_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_geolocated_with_model
	) REFERENCES geolocation_procedure_templates(
		procedure_template,
		procedure_template_geolocated_with_model
	),
	-- The `procedure_template_geolocated_asset_model` must be the same as in the `geolocation_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_geolocated_asset_model
	) REFERENCES geolocation_procedure_templates(
		procedure_template,
		procedure_template_geolocated_asset_model
	),
	-- We check that the `procedure_geolocated_asset` has the same `procedure_template_geolocated_asset_model`.
	FOREIGN KEY (
		procedure_geolocated_asset,
		procedure_template_geolocated_asset_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_geolocated_with` has the same `procedure_template_geolocated_with_model`.
	FOREIGN KEY (
		procedure_geolocated_with,
		procedure_template_geolocated_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_geolocated_asset` is associated to the `geolocated_asset`.
	FOREIGN KEY (procedure_geolocated_asset, geolocated_asset) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_geolocated_with` is associated to the `geolocated_with`.
	FOREIGN KEY (procedure_geolocated_with, geolocated_with) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS freeze_drying_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The storage temperature in Kelvin.
	kelvin REAL NOT NULL DEFAULT 203.15 CHECK (must_be_strictly_positive_f32(kelvin)),
	-- Tolerance percentage for the storage temperature.
	kelvin_tolerance_percentage REAL NOT NULL DEFAULT 5.0 CHECK (
		must_be_strictly_positive_f32(kelvin_tolerance_percentage)
		AND must_be_smaller_than_f32(kelvin_tolerance_percentage, 100.0)
	),
	-- We use a default of 4 Pa for the pressure in the freeze-drying chamber.
	pascal REAL NOT NULL DEFAULT 4.0 CHECK (
		must_be_strictly_positive_f32(pascal)
		AND must_be_smaller_than_f32(pascal, 500.0)
	),
	-- We use a default of 3 days (259200 seconds) for the freeze-drying procedure.
	seconds REAL NOT NULL DEFAULT 259200.0 CHECK (
		must_be_strictly_greater_than_f32(seconds, 7200.0)
		AND must_be_strictly_smaller_than_f32(seconds, 604800.0)
	),
	-- The device used for the freeze drying procedure.
	freeze_dried_with_model INTEGER NOT NULL REFERENCES freeze_dryer_models(id),
	procedure_template_freeze_dried_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The container that is being freeze_dried.
	freeze_dried_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_freeze_dried_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- We check that the `freeze_dried_with_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_freeze_dried_with_model,
		freeze_dried_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `freeze_dried_container_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_freeze_dried_container_model,
		freeze_dried_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `freeze_dried_container_model` is indeed a freeze drier that can hold the `freeze_dried_with_model`.
	FOREIGN KEY (
		freeze_dried_with_model,
		freeze_dried_container_model
	) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_freeze_dried_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_freeze_dried_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_freeze_dried_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_freeze_dried_container_model
	)
);
CREATE TABLE IF NOT EXISTS freeze_drying_procedures (
	-- Identifier of the freeze drying procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a freeze drying procedure template.
	procedure_template INTEGER NOT NULL REFERENCES freeze_drying_procedure_templates(procedure_template),
	-- The container that is being freeze dried, which must be a volumetric container.
	freeze_dried_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The container model that is being freeze dried, which must be a volumetric container model.
	freeze_dried_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The procedure template asset model associated to the `freeze_dried_container`.
	procedure_template_freeze_dried_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `freeze_dried_container`.
	procedure_freeze_dried_container UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The freeze drier used for the freeze drying procedure. This field is optional, as the freeze drier might not necessarily be tracked.
	freeze_dried_with UUID REFERENCES freeze_dryers(id),
	-- The model of the freeze drier used, which must be a freeze drier model.
	freeze_dried_with_model INTEGER NOT NULL REFERENCES freeze_dryer_models(id),
	-- The procedure template asset model associated to the `freeze_dried_with`.
	procedure_template_freeze_dried_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `freeze_dried_with`.
	procedure_freeze_dried_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the current `freeze_drying_procedures` has indeed the same `freeze_drying_procedures_template`.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- We enforce that the `freeze_dried_with` is indeed a weighing device of the correct model.
	FOREIGN KEY (freeze_dried_with, freeze_dried_with_model) REFERENCES assets(id, model),
	-- We enforce that the `procedure_template_freeze_dried_with_model` is the same as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_freeze_dried_with_model
	) REFERENCES freeze_drying_procedure_templates(
		procedure_template,
		procedure_template_freeze_dried_with_model
	),
	-- We enforce that the `procedure_template_freeze_dried_container_model` is the same as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_freeze_dried_container_model
	) REFERENCES freeze_drying_procedure_templates(
		procedure_template,
		procedure_template_freeze_dried_container_model
	),
	-- We enforce that the `procedure_freeze_dried_container` is associated with `procedure_template_freeze_dried_container_model`.
	FOREIGN KEY (
		procedure_freeze_dried_container,
		procedure_template_freeze_dried_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the `procedure_freeze_dried_with` is associated with `procedure_template_freeze_dried_with_model`.
	FOREIGN KEY (
		procedure_freeze_dried_with,
		procedure_template_freeze_dried_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- The compatibility rules between the freeze drier and the container being freeze dried must be respected.
	FOREIGN KEY (
		freeze_dried_with_model,
		freeze_dried_container_model
	) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We enforce that the `procedure_freeze_dried_container` is associated with the `freeze_dried_container_model`.
	FOREIGN KEY (
		procedure_freeze_dried_container,
		freeze_dried_container_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We enforce that the `procedure_freeze_dried_with` is associated with the `freeze_dried_with_model`.
	FOREIGN KEY (
		procedure_freeze_dried_with,
		freeze_dried_with_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We enforce that the `procedure_freeze_dried_container` is associated with the `freeze_dried_container`.
	FOREIGN KEY (
		procedure_freeze_dried_container,
		freeze_dried_container
	) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_freeze_dried_with` is associated with the `freeze_dried_with`.
	FOREIGN KEY (procedure_freeze_dried_with, freeze_dried_with) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS freezing_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The storage temperature in Kelvin.
	kelvin REAL NOT NULL DEFAULT 203.15 CHECK (must_be_strictly_positive_f32(kelvin)),
	-- Tolerance percentage for the storage temperature.
	kelvin_tolerance_percentage REAL NOT NULL DEFAULT 5.0 CHECK (
		must_be_strictly_positive_f32(kelvin_tolerance_percentage)
		AND must_be_smaller_than_f32(kelvin_tolerance_percentage, 100.0)
	),
	-- We use a default of 43200 seconds (12 hours) for the freezing procedure.
	seconds REAL DEFAULT 43200.0 CHECK (
		must_be_strictly_positive_f32(seconds)
		AND must_be_strictly_greater_than_f32(seconds, 1800.0)
	),
	-- The device used for freezing.
	frozen_with_model INTEGER NOT NULL REFERENCES freezer_models(id),
	procedure_template_frozen_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The container that is being stored in the freezer.
	frozen_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_frozen_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- We check that the `frozen_with_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_frozen_with_model,
		frozen_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `frozen_container_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_frozen_container_model,
		frozen_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `frozen_with_model` is indeed a container that can hold the `frozen_container_model`.
	FOREIGN KEY (frozen_with_model, frozen_container_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_frozen_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_frozen_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_frozen_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_frozen_container_model
	)
);
CREATE TABLE IF NOT EXISTS freezing_procedures (
	-- Identifier of the freezing procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a freezing procedure template.
	procedure_template INTEGER NOT NULL REFERENCES freezing_procedure_templates(procedure_template),
	-- The container that is being frozen, which must be a volumetric container.
	frozen_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The model of the container being frozen, which must be a container model.
	frozen_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The procedure template asset model associated to the `frozen_container`.
	procedure_template_frozen_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `frozen_container`.
	procedure_frozen_container UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The freezer used for the freezing procedure. This field is optional, as the freezer might not necessarily be tracked.
	frozen_with UUID REFERENCES freezers(id),
	-- The model of the freezer used, which must be a freezer model.
	frozen_with_model INTEGER NOT NULL REFERENCES freezer_models(id),
	-- The procedure template asset model associated to the `frozen_with_model`.
	procedure_template_frozen_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `frozen_with`.
	procedure_frozen_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the current `freezing_procedure_templates` has indeed the same `freezing_procedure_templates_template`.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_frozen_with_model` must be the same as in the `freezing_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_frozen_with_model
	) REFERENCES freezing_procedure_templates(
		procedure_template,
		procedure_template_frozen_with_model
	),
	-- The `procedure_template_frozen_container_model` must be the same as in the `freezing_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_frozen_container_model
	) REFERENCES freezing_procedure_templates(
		procedure_template,
		procedure_template_frozen_container_model
	),
	-- We check that the `frozen_with_model` is compatible with the `frozen_container_model`.
	FOREIGN KEY (frozen_with_model, frozen_container_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We ensure that the `procedure_frozen_container` is associated with the `procedure_template_frozen_container_model`.
	FOREIGN KEY (
		procedure_frozen_container,
		procedure_template_frozen_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We ensure that the `procedure_frozen_with` is associated with the `procedure_template_frozen_with_model`.
	FOREIGN KEY (
		procedure_frozen_with,
		procedure_template_frozen_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We ensure that the `procedure_frozen_container` is associated to the `frozen_container_model`.
	FOREIGN KEY (
		procedure_frozen_container,
		frozen_container_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We ensure that the `procedure_frozen_with` is associated to the `frozen_with_model`.
	FOREIGN KEY (procedure_frozen_with, frozen_with_model) REFERENCES procedure_assets(id, asset_model),
	-- We ensure that the `procedure_frozen_container` is associated to the `frozen_container`.
	FOREIGN KEY (procedure_frozen_container, frozen_container) REFERENCES procedure_assets(id, asset),
	-- We ensure that the `procedure_frozen_with` is associated to the `frozen_with`.
	FOREIGN KEY (procedure_frozen_with, frozen_with) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS fractioning_procedure_templates (
	-- Identifier of the fractioning procedure template, which is also a foreign key to the general procedure template.
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- Expected amount of the fraction to be collected in kilograms.
	kilograms REAL NOT NULL CHECK (must_be_strictly_positive_f32(kilograms)),
	-- The tolerance percentage of the fraction in kilograms.
	tolerance_percentage REAL NOT NULL CHECK (
		must_be_strictly_positive_f32(tolerance_percentage)
		AND must_be_smaller_than_f32(tolerance_percentage, 100.0)
	),
	-- The model of the scale used to measure the fraction in kilograms.
	weighed_with_model INTEGER NOT NULL REFERENCES weighing_device_models(id),
	-- The model of the instrument used for weighing should always be an asset model that is compatible with the procedure template.
	procedure_template_weighed_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- Source container model from which the fraction is taken.
	fragment_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_fragment_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- Destination container model to which the fraction is transferred.
	fragment_placed_into_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_fragment_placed_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- Foreign key to ensure that the `weighed_with_model` is indeed a weighing instrument.
	FOREIGN KEY (
		procedure_template_weighed_with_model,
		weighed_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We enforce that the `fragment_container_model` is indeed a procedure asset model.
	FOREIGN KEY (
		procedure_template_fragment_container_model,
		fragment_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_fragment_placed_into_model,
		fragment_placed_into_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_weighed_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_weighed_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_fragment_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_fragment_container_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_fragment_placed_into_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_fragment_placed_into_model
	)
);
CREATE TABLE IF NOT EXISTS fractioning_procedures (
	-- Identifier of the fractioning procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a fractioning procedure template.
	procedure_template INTEGER NOT NULL REFERENCES fractioning_procedure_templates(procedure_template),
	-- The source container from which the fraction is taken, which must be a volumetric container model.
	fragment_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `fragment_container`.
	procedure_template_fragment_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `fragment_container`.
	procedure_fragment_container UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The destination container to which the fraction is transferred, which must be a volumetric container model.
	fragment_placed_into UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `fragment_placed_into`.
	procedure_template_fragment_placed_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `fragment_placed_into`.
	procedure_fragment_placed_into UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The actual amount of the fraction collected in kilograms.
	kilograms REAL NOT NULL CHECK (must_be_strictly_positive_f32(kilograms)),
	-- The scale used to measure the fraction in kilograms. This field is optional, 
	-- as the weighing device might not necessarily be tracked.
	weighed_with UUID REFERENCES weighing_devices(id),
	-- The procedure template asset model associated to the `weighed_with_model`.
	procedure_template_weighed_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `weighed_with`.
	procedure_weighed_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the current `fractioning_procedures` has indeed the same `fractioning_procedures_template`.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- We enforce that the `procedure_template_weighed_with_model` is associated with the `procedure_template`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_weighed_with_model
	) REFERENCES fractioning_procedure_templates(
		procedure_template,
		procedure_template_weighed_with_model
	),
	-- We enforce that the `procedure_template_fragment_container_model` is associated with the `procedure_template`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_fragment_container_model
	) REFERENCES fractioning_procedure_templates(
		procedure_template,
		procedure_template_fragment_container_model
	),
	-- We enforce that the `procedure_template_fragment_placed_into_model` is associated with the `procedure_template`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_fragment_placed_into_model
	) REFERENCES fractioning_procedure_templates(
		procedure_template,
		procedure_template_fragment_placed_into_model
	),
	-- We enforce that the `procedure_fragment_container` is associated with the `fragment_container`.
	FOREIGN KEY (
		procedure_fragment_container,
		fragment_container
	) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_fragment_placed_into` is associated with the `fragment_placed_into`.
	FOREIGN KEY (
		procedure_fragment_placed_into,
		fragment_placed_into
	) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_weighed_with` is associated with the `weighed_with`.
	FOREIGN KEY (procedure_weighed_with, weighed_with) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_fragment_container` is associated with `procedure_template_fragment_container_model`.
	FOREIGN KEY (
		procedure_fragment_container,
		procedure_template_fragment_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the `procedure_fragment_placed_into` is associated with `procedure_template_fragment_placed_into_model`.
	FOREIGN KEY (
		procedure_fragment_placed_into,
		procedure_template_fragment_placed_into_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the `procedure_weighed_with` is associated with `procedure_template_weighed_with_model`.
	FOREIGN KEY (
		procedure_weighed_with,
		procedure_template_weighed_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model)
);CREATE TABLE IF NOT EXISTS centrifuge_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The storage temperature in Kelvin.
	kelvin REAL NOT NULL DEFAULT 293.15 CHECK (must_be_strictly_positive_f32(kelvin)),
	-- Tolerance percentage for the storage temperature.
	kelvin_tolerance_percentage REAL NOT NULL DEFAULT 1.0 CHECK (
		must_be_strictly_positive_f32(kelvin_tolerance_percentage)
		AND must_be_smaller_than_f32(kelvin_tolerance_percentage, 100.0)
	),
	-- The time in seconds that the centrifuge should be used for the procedure.
	seconds REAL NOT NULL DEFAULT 120.0 CHECK (
		must_be_greater_than_f32(seconds, 30.0)
		AND must_be_smaller_than_f32(seconds, 1800.0)
	),
	-- The RPMs (rotations per minute) of the centrifuge.
	rotation_per_minute REAL NOT NULL DEFAULT 13000.0 CHECK (
		must_be_greater_than_f32(rotation_per_minute, 5000.0)
		AND must_be_smaller_than_f32(rotation_per_minute, 30000.0)
	),
	-- The device used for the centrifuge procedure.
	centrifuged_with_model INTEGER NOT NULL REFERENCES centrifuge_models(id),
	procedure_template_centrifuged_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The container that is being centrifuged.
	centrifuged_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The centrifuged container model should allways be an asset model that is compatible with the procedure template.
	procedure_template_centrifuged_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- We check that the `centrifuged_with_model` is indeed a instrument that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_centrifuged_with_model,
		centrifuged_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `procedure_template_centrifuged_container_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_centrifuged_container_model,
		centrifuged_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `centrifuged_with_model` is indeed a container that can hold the `centrifuged_with_model`.
	CONSTRAINT centrifuge_pm_compatibility_rules FOREIGN KEY (
		centrifuged_with_model,
		centrifuged_container_model
	) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_centrifuged_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_centrifuged_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_centrifuged_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_centrifuged_container_model
	)
);
CREATE TABLE IF NOT EXISTS centrifuge_procedures (
	-- Identifier of the centrifuge procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- We enforce that the model of this procedure must be a centrifuge procedure template.
	procedure_template INTEGER NOT NULL REFERENCES centrifuge_procedure_templates(procedure_template),
	-- The container that is being centrifuged, which must be a volumetric container.
	centrifuged_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The model of the container that is being centrifuged.
	centrifuged_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The procedure template asset model associated to the `centrifuged_container`.
	procedure_template_centrifuged_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `centrifuged_container`.
	procedure_centrifuged_container UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The centrifuge model used for the centrifuge procedure.
	centrifuged_with_model INTEGER NOT NULL REFERENCES centrifuge_models(id),
	-- The centrifuge used for the procedure. This field is optional because the centrifuge
	-- might not have been recorded at the time of performing the procedure.
	centrifuged_with UUID REFERENCES centrifuges(id),
	-- The procedure template asset model associated to the `centrifuged_with_model`.
	procedure_template_centrifuged_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `centrifuged_with`.
	procedure_centrifuged_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is a centrifugating procedure.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- We enforce that the specified `centrifuged_with` is of the specified `centrifuged_with_model`.
	FOREIGN KEY (centrifuged_with, centrifuged_with_model) REFERENCES assets(id, model),
	-- The procedure template asset model describing the `centrifuged_container` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_centrifuged_container_model
	) REFERENCES centrifuge_procedure_templates(
		procedure_template,
		procedure_template_centrifuged_container_model
	),
	-- The procedure template asset model describing the `centrifuged_with_model` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_centrifuged_with_model
	) REFERENCES centrifuge_procedure_templates(
		procedure_template,
		procedure_template_centrifuged_with_model
	),
	-- We enforce that the specified `procedure_centrifuged_container` is of the specified `procedure_template_centrifuged_container_model`.
	FOREIGN KEY (
		procedure_centrifuged_container,
		procedure_template_centrifuged_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the specified `procedure_centrifuged_with` is of the specified `procedure_template_centrifuged_with_model`.
	FOREIGN KEY (
		procedure_centrifuged_with,
		procedure_template_centrifuged_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `centrifuged_with_model` is indeed a instrument that is compatible with the `centrifuged_container_model`.
	FOREIGN KEY (
		centrifuged_with_model,
		centrifuged_container_model
	) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We ensure that the `procedure_centrifuged_container` is associated with the `centrifuged_container_model`.
	FOREIGN KEY (
		procedure_centrifuged_container,
		centrifuged_container_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We ensure that the `procedure_centrifuged_container` is associated with the `centrifuged_container`.
	FOREIGN KEY (
		procedure_centrifuged_container,
		centrifuged_container
	) REFERENCES procedure_assets(id, asset),
	-- We ensure that the `procedure_centrifuged_with` is associated with the `centrifuged_container`.
	FOREIGN KEY (
		procedure_centrifuged_with,
		centrifuged_with_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We ensure that the `procedure_centrifuged_with` is associated with the `centrifuged_with`.
	FOREIGN KEY (procedure_centrifuged_with, centrifuged_with) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS ball_mill_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The storage temperature in Kelvin.
	kelvin REAL NOT NULL DEFAULT 293.15 CHECK (must_be_strictly_positive_f32(kelvin)),
	-- Tolerance percentage for the storage temperature.
	kelvin_tolerance_percentage REAL NOT NULL DEFAULT 1.0 CHECK (
		must_be_strictly_positive_f32(kelvin_tolerance_percentage)
		AND must_be_smaller_than_f32(kelvin_tolerance_percentage, 100.0)
	),
	-- By default, we set it to 150 seconds (2.5 minutes).
	seconds REAL NOT NULL DEFAULT 150.0 CHECK (
		must_be_strictly_smaller_than_f32(seconds, 900.0)
		AND must_be_strictly_greater_than_f32(seconds, 30.0)
	),
	-- The time in seconds that the ball mill should be used for the procedure.
	hertz REAL NOT NULL DEFAULT 25.0 CHECK (
		must_be_strictly_smaller_than_f32(hertz, 50.0)
		AND must_be_strictly_greater_than_f32(hertz, 15.0)
	),
	-- The beads model used for the procedure.
	bead_model INTEGER NOT NULL REFERENCES bead_models(id),
	procedure_template_bead_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	--- The number of beads used in the procedure.
	number_of_beads SMALLINT NOT NULL DEFAULT 3 CHECK (must_be_strictly_positive_i16(number_of_beads)),
	-- The device used for the ball mill procedure.
	milled_with_model INTEGER NOT NULL REFERENCES ball_mill_machine_models(id),
	procedure_template_milled_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The container that is being milled.
	milled_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_milled_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	FOREIGN KEY (procedure_template_bead_model, bead_model) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `milled_with` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_milled_with_model,
		milled_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `milled_container_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_milled_container_model,
		milled_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `milled_with` is indeed a ball mill machine that can hold the `milled_container_model`.
	FOREIGN KEY (milled_with_model, milled_container_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We check that the `milled_with` is indeed a ball mill machine that can use the `bead_model`.
	FOREIGN KEY (milled_with_model, bead_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We check that the `bead_model` is indeed a beads model that can be used with the `milled_container_model`.
	FOREIGN KEY (bead_model, milled_container_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_bead_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_bead_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_milled_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_milled_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_milled_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_milled_container_model
	)
);
CREATE TABLE IF NOT EXISTS ball_mill_procedures (
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	procedure_template INTEGER NOT NULL REFERENCES ball_mill_procedure_templates(procedure_template),
	-- The beads model used for the procedure.
	bead_model INTEGER NOT NULL REFERENCES bead_models(id),
	-- The procedure template asset model associated to the `bead_model`.
	procedure_template_bead_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `bead_model`.
	procedure_bead UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The device used for the ball mill procedure.
	milled_with_model INTEGER NOT NULL REFERENCES ball_mill_machine_models(id),
	-- The procedure template asset model associated to the `milled_with_model`.
	procedure_template_milled_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `milled_with_model`.
	procedure_milled_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The ball mill machine used for the procedure. This field is optional because the ball mill
	-- machine might not have been recorded at the time of performing the procedure.
	milled_with UUID REFERENCES ball_mill_machines(id),
	-- The container that is being milled.
	milled_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The container model that is being milled.
	milled_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The procedure template asset model associated to the `milled_container`.
	procedure_template_milled_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `milled_container`.
	procedure_milled_container UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is a ball mill procedure without the possibility of a mistake.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The procedure template asset model describing the `bead_model` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_bead_model
	) REFERENCES ball_mill_procedure_templates(
		procedure_template,
		procedure_template_bead_model
	),
	-- The procedure template asset model describing the `milled_with_model` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_milled_with_model
	) REFERENCES ball_mill_procedure_templates(
		procedure_template,
		procedure_template_milled_with_model
	),
	-- The procedure template asset model describing the `milled_container_model` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_milled_container_model
	) REFERENCES ball_mill_procedure_templates(
		procedure_template,
		procedure_template_milled_container_model
	),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset model `bead_model`.
	FOREIGN KEY (procedure_bead, procedure_template_bead_model) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset model `milled_with_model`.
	FOREIGN KEY (
		procedure_milled_with,
		procedure_template_milled_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset model `milled_container_model`.
	FOREIGN KEY (
		procedure_milled_container,
		procedure_template_milled_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the `procedure_milled_container` procedure asset is indeed associated to the `milled_container_model`.
	FOREIGN KEY (
		procedure_milled_container,
		milled_container_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We enforce that the `procedure_milled_with` procedure asset is indeed associated to the `milled_with_model`.
	FOREIGN KEY (procedure_milled_with, milled_with_model) REFERENCES procedure_assets(id, asset_model),
	-- We enforce that the `procedure_milled_with` procedure asset is indeed associated to the `milled_with`.
	FOREIGN KEY (procedure_milled_with, milled_with) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_bead` procedure asset is indeed associated to the `bead_model`.
	FOREIGN KEY (procedure_bead, bead_model) REFERENCES procedure_assets(id, asset_model),
	-- We enforce that the `procedure_milled_container` procedure asset is indeed associated to the `milled_container`.
	FOREIGN KEY (procedure_milled_container, milled_container) REFERENCES procedure_assets(id, asset),
	-- We check that the `milled_with` is indeed a ball mill machine that can hold the `milled_container_model`.
	FOREIGN KEY (milled_with_model, milled_container_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We check that the `milled_with` is indeed a ball mill machine that can use the `bead_model`.
	FOREIGN KEY (milled_with_model, bead_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We check that the `bead_model` is indeed a beads model that can be used with the `milled_container_model`.
	FOREIGN KEY (bead_model, milled_container_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model)
);CREATE TABLE IF NOT EXISTS pouring_procedure_templates (
	-- Identifier of the pouring procedure template, which is also a foreign key to the general procedure template.
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The device model used to measure the liquid volume.
	measured_with_model INTEGER NOT NULL REFERENCES volume_measuring_device_models(id),
	-- The associated procedure asset model for the measuring device.
	procedure_template_measured_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The source container from which the liquid is poured.
	poured_from_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The associated procedure asset model for the source container. It may be associated
	-- to any type of other procedure templates (e.g., fractioning, packaging, etc.).
	procedure_template_poured_from_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The volumetric container into which the liquid is poured.
	poured_into_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The associated procedure asset model for the destination container. It is always associated
	-- to the same procedure template of this pouring procedure template.
	procedure_template_poured_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The amount of liquid that is poured into the container.
	liters REAL NOT NULL CHECK (must_be_strictly_positive_f32(liters)),
	-- The measuring device must match the procedure template of the procedure.
	FOREIGN KEY (
		procedure_template_measured_with_model,
		measured_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_poured_into_model,
		poured_into_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_poured_from_model,
		poured_from_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_measured_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_measured_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_poured_from_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_poured_from_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_poured_into_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_poured_into_model
	)
);
CREATE TABLE IF NOT EXISTS pouring_procedures (
	-- The extended `procedure`.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The procedure template of the extended `procedure`.
	procedure_template INTEGER NOT NULL REFERENCES pouring_procedure_templates(procedure_template),
	-- The container from which the liquid is poured.
	poured_from UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `poured_from`.
	procedure_template_poured_from_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `poured_from`.
	procedure_poured_from UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The actual measuring device (if known) used to measure the liquid volume.
	measured_with UUID REFERENCES volume_measuring_devices(id),
	-- The procedure template asset model associated to the `measured_with_model`.
	procedure_template_measured_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `measured_with`.
	procedure_measured_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The container into which the liquid is poured.
	poured_into UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `poured_into`.
	procedure_template_poured_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `poured_into`.
	procedure_poured_into UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is a packaging procedure.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_measured_with_model` must be the same as in the `pouring_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_measured_with_model
	) REFERENCES pouring_procedure_templates(
		procedure_template,
		procedure_template_measured_with_model
	),
	-- The `procedure_template_poured_from_model` must be the same as in the `pouring_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_poured_from_model
	) REFERENCES pouring_procedure_templates(
		procedure_template,
		procedure_template_poured_from_model
	),
	-- The `procedure_template_poured_into_model` must be the same as in the `pouring_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_poured_into_model
	) REFERENCES pouring_procedure_templates(
		procedure_template,
		procedure_template_poured_into_model
	),
	-- We check that the `procedure_poured_from` is associated to the `poured_from`.
	FOREIGN KEY (procedure_poured_from, poured_from) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_poured_into` is associated to the `poured_into`.
	FOREIGN KEY (procedure_poured_into, poured_into) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_poured_from` is indeed associated to the `procedure_template_poured_from_model`.
	FOREIGN KEY (
		procedure_poured_from,
		procedure_template_poured_from_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_measured_with` is indeed associated to the `procedure_template_measured_with_model`.
	FOREIGN KEY (
		procedure_measured_with,
		procedure_template_measured_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_poured_into` is indeed associated to the `procedure_template_poured_into_model`.
	FOREIGN KEY (
		procedure_poured_into,
		procedure_template_poured_into_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_measured_with` is associated to the `measured_with` asset (if any).
	FOREIGN KEY (procedure_measured_with, measured_with) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS aliquoting_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The amount of liters that should be aliquoted.
	liters REAL NOT NULL CHECK (must_be_strictly_positive_f32(liters)),
	-- Source container from which the aliquot is taken.
	aliquoted_from_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_aliquoted_from_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- Destination container to which the aliquot is transferred.
	aliquoted_into_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_aliquoted_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The device used for the aliquoting procedure.
	aliquoted_with_model INTEGER NOT NULL REFERENCES pipette_models(id),
	procedure_template_aliquoted_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The pipette tip to be mounted on the pipette.
	pipette_tip_model INTEGER NOT NULL REFERENCES pipette_tip_models(id),
	procedure_template_pipette_tip_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	FOREIGN KEY (
		procedure_template_aliquoted_with_model,
		aliquoted_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_pipette_tip_model,
		pipette_tip_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `aliquoted_with_model` is compatible with the `pipette_tip_model`.
	FOREIGN KEY (aliquoted_with_model, pipette_tip_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	FOREIGN KEY (
		procedure_template_aliquoted_from_model,
		aliquoted_from_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_aliquoted_into_model,
		aliquoted_into_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_aliquoted_from_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_aliquoted_from_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_aliquoted_into_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_aliquoted_into_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_aliquoted_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_aliquoted_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_pipette_tip_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_pipette_tip_model
	)
);
CREATE TABLE IF NOT EXISTS aliquoting_procedures (
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- We enforce that the model of this procedure must be an aliquoting procedure template.
	procedure_template INTEGER NOT NULL REFERENCES aliquoting_procedure_templates(procedure_template),
	-- The identifier of the instrument used for aliquoting.
	aliquoted_with UUID REFERENCES pipettes(id),
	-- The identifier of the instrument model used for aliquoting.
	aliquoted_with_model INTEGER NOT NULL REFERENCES pipette_models(id),
	-- The procedure template asset model associated to the `aliquoted_with`.
	procedure_template_aliquoted_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `aliquoted_with`.
	procedure_aliquoted_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The pipette tip model mounted on the pipette.
	pipette_tip_model INTEGER NOT NULL REFERENCES pipette_tip_models(id),
	-- The procedure template asset model associated to the `pipette_tip_model`.
	procedure_template_pipette_tip_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `pipette_tip_model`.
	procedure_pipette_tip UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The container being aliquoted, which must be a volumetric container model.
	aliquoted_from UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `aliquoted_from`.
	procedure_template_aliquoted_from_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `aliquoted_from`.
	procedure_aliquoted_from UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The container receiving the aliquot, which must be a volumetric container model.
	aliquoted_into UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `aliquoted_into`.
	procedure_template_aliquoted_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `aliquoted_into`.
	procedure_aliquoted_into UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is an aliquoting procedure without the possibility of a mistake.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The procedure template asset model describing the `aliquoted_with` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_aliquoted_with_model
	) REFERENCES aliquoting_procedure_templates(
		procedure_template,
		procedure_template_aliquoted_with_model
	),
	-- The procedure template asset model describing the `pipette_tip_model` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_pipette_tip_model
	) REFERENCES aliquoting_procedure_templates(
		procedure_template,
		procedure_template_pipette_tip_model
	),
	-- The procedure template asset model describing the `aliquoted_from` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_aliquoted_from_model
	) REFERENCES aliquoting_procedure_templates(
		procedure_template,
		procedure_template_aliquoted_from_model
	),
	-- The procedure template asset model describing the `aliquoted_into` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_aliquoted_into_model
	) REFERENCES aliquoting_procedure_templates(
		procedure_template,
		procedure_template_aliquoted_into_model
	),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset `aliquoted_with`.
	FOREIGN KEY (
		procedure_aliquoted_with,
		procedure_template_aliquoted_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset model `pipette_tip_model`.
	FOREIGN KEY (
		procedure_pipette_tip,
		procedure_template_pipette_tip_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset `aliquoted_from`.
	FOREIGN KEY (
		procedure_aliquoted_from,
		procedure_template_aliquoted_from_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset `aliquoted_into`.
	FOREIGN KEY (
		procedure_aliquoted_into,
		procedure_template_aliquoted_into_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enfore that the `aliquoted_with_model` asset model is correctly associated to the `aliquoted_with` procedure asset.
	FOREIGN KEY (procedure_aliquoted_with, aliquoted_with_model) REFERENCES procedure_assets(id, asset_model),
	-- We enfore that the `aliquoted_with` asset is correctly associated to the `aliquoted_with` procedure asset.
	FOREIGN KEY (procedure_aliquoted_with, aliquoted_with) REFERENCES procedure_assets(id, asset),
	-- We enfore that the `aliquoted_from` asset is correctly associated to the `aliquoted_from` procedure asset.
	FOREIGN KEY (procedure_aliquoted_from, aliquoted_from) REFERENCES procedure_assets(id, asset),
	-- We enfore that the `aliquoted_into` asset is correctly associated to the `aliquoted_into` procedure asset.
	FOREIGN KEY (procedure_aliquoted_into, aliquoted_into) REFERENCES procedure_assets(id, asset),
	-- We enfore that the `pipette_tip_model` asset model is correctly associated to the `pipette_tip` procedure asset.
	FOREIGN KEY (procedure_pipette_tip, pipette_tip_model) REFERENCES procedure_assets(id, asset_model),
	-- We enfore that the `pipette_tip_model` is compatible with the `aliquoted_with_model`.
	FOREIGN KEY (aliquoted_with_model, pipette_tip_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model)
);CREATE TABLE IF NOT EXISTS supernatant_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The amount of liters that should be transferred
	liters REAL NOT NULL CHECK (must_be_strictly_positive_f32(liters)),
	-- The source container from which the supernatant is taken.
	stratified_source_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_stratified_source_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- Destination container to which the supernatant is transferred.
	supernatant_destination_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_supernatant_destination_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The device used for the aliquoting procedure.
	transferred_with_model INTEGER NOT NULL REFERENCES pipette_models(id),
	procedure_template_transferred_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The pipette tip to be mounted on the pipette.
	pipette_tip_model INTEGER NOT NULL REFERENCES pipette_tip_models(id),
	procedure_template_pipette_tip_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	FOREIGN KEY (
		procedure_template_transferred_with_model,
		transferred_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_pipette_tip_model,
		pipette_tip_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `transferred_with_model` is compatible with the `pipette_tip_model`.
	CONSTRAINT supernatant_pm_compatibility_rules FOREIGN KEY (transferred_with_model, pipette_tip_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model) ON DELETE CASCADE,
	FOREIGN KEY (
		procedure_template_stratified_source_model,
		stratified_source_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_supernatant_destination_model,
		supernatant_destination_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_stratified_source_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_stratified_source_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_supernatant_destination_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_supernatant_destination_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_transferred_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_transferred_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_pipette_tip_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_pipette_tip_model
	)
);
CREATE TABLE IF NOT EXISTS supernatant_procedures (
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- We enforce that the model of this procedure must be a supernatant procedure template.
	procedure_template INTEGER NOT NULL REFERENCES supernatant_procedure_templates(procedure_template),
	-- The source container from which the supernatant is taken.
	stratified_source UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `stratified_source`.
	procedure_template_stratified_source_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `stratified_source`.
	procedure_stratified_source UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The destination container to which the supernatant is transferred.
	supernatant_destination UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `supernatant_destination`.
	procedure_template_supernatant_destination_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `supernatant_destination`.
	procedure_supernatant_destination UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The device used for the aliquoting procedure.
	transferred_with UUID NOT NULL REFERENCES pipettes(id),
	-- The model of the device used for the aliquoting procedure.
	transferred_with_model INTEGER NOT NULL REFERENCES pipette_models(id),
	-- The procedure template asset model associated to the `transferred_with`.
	procedure_template_transferred_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `transferred_with`.
	procedure_transferred_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The pipette tip to be mounted on the pipette.
	pipette_tip_model INTEGER NOT NULL REFERENCES pipette_tip_models(id),
	-- The procedure template asset model associated to the `pipette_tip_model`.
	procedure_template_pipette_tip_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `pipette_tip_model`.
	procedure_pipette_tip UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is a supernatant procedure without the possibility of a mistake.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_stratified_source_model` must be the same as in the `supernatant_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_stratified_source_model
	) REFERENCES supernatant_procedure_templates(
		procedure_template,
		procedure_template_stratified_source_model
	),
	-- The `procedure_template_supernatant_destination_model` must be the same as in the `supernatant_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_supernatant_destination_model
	) REFERENCES supernatant_procedure_templates(
		procedure_template,
		procedure_template_supernatant_destination_model
	),
	-- The `procedure_template_transferred_with_model` must be the same as in the `supernatant_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_transferred_with_model
	) REFERENCES supernatant_procedure_templates(
		procedure_template,
		procedure_template_transferred_with_model
	),
	-- The `procedure_template_pipette_tip_model` must be the same as in the `supernatant_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_pipette_tip_model
	) REFERENCES supernatant_procedure_templates(
		procedure_template,
		procedure_template_pipette_tip_model
	),
	-- We check that the `procedure_stratified_source` is associated to the `stratified_source`.
	FOREIGN KEY (procedure_stratified_source, stratified_source) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_supernatant_destination` is associated to the `supernatant_destination`.
	FOREIGN KEY (
		procedure_supernatant_destination,
		supernatant_destination
	) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_transferred_with` is associated to the `transferred_with_model`.
	FOREIGN KEY (procedure_transferred_with, transferred_with) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_pipette_tip` is associated to the `pipette_tip_model`.
	FOREIGN KEY (procedure_pipette_tip, pipette_tip_model) REFERENCES procedure_assets(id, asset_model),
	-- We check that the `procedure_stratified_source` is indeed associated to the `procedure_template_stratified_source_model`.
	FOREIGN KEY (
		procedure_stratified_source,
		procedure_template_stratified_source_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_supernatant_destination` is indeed associated to the `procedure_template_supernatant_destination_model`.
	FOREIGN KEY (
		procedure_supernatant_destination,
		procedure_template_supernatant_destination_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_transferred_with` is indeed associated to the `procedure_template_transferred_with_model`.
	FOREIGN KEY (
		procedure_transferred_with,
		procedure_template_transferred_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_pipette_tip` is indeed associated to the `procedure_template_pipette_tip_model`.
	FOREIGN KEY (
		procedure_pipette_tip,
		procedure_template_pipette_tip_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `transferred_with_model` is compatible with the `pipette_tip_model`.
	FOREIGN KEY (transferred_with_model, pipette_tip_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We check that the `procedure_transferred_with` is associated to the `transferred_with_model`.
	FOREIGN KEY (
		procedure_transferred_with,
		transferred_with_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We check that the `procedure_pipette_tip` is associated to the `pipette_tip_model`.
	FOREIGN KEY (procedure_pipette_tip, pipette_tip_model) REFERENCES procedure_assets(id, asset_model)
);CREATE TABLE IF NOT EXISTS weighing_procedure_templates (
	-- Identifier of the weighing procedure template, which is also a a foreign key to the general procedure template table.
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The sample container model is the one that is being weighed.
	weighed_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The sample container model should always be an asset model that is compatible with the procedure template.
	procedure_template_weighed_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The model of the instrument to be used for weighing.
	weighed_with_model INTEGER NOT NULL REFERENCES weighing_device_models(id),
	-- The instrument model used for weighing should always be an asset model that is compatible with the procedure template.
	procedure_template_weighed_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- We check that the `weighed_with` is indeed an asset model that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_weighed_with_model,
		weighed_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We enforce that the `weighed_container_model` is indeed a procedure asset model.
	FOREIGN KEY (
		procedure_template_weighed_container_model,
		weighed_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_weighed_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_weighed_container_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_weighed_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_weighed_with_model
	)
);
CREATE TABLE IF NOT EXISTS weighing_procedures(
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- We enforce that the model of this procedure must be a weighing procedure template.
	procedure_template INTEGER NOT NULL REFERENCES weighing_procedure_templates(procedure_template),
	-- The container being weighed, which must be a volumetric container model.
	weighed_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `weighed_container`.
	procedure_template_weighed_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `weighed_container`.
	procedure_weighed_container UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The measured weight, which must be strictly positive.
	kilograms REAL NOT NULL CHECK (must_be_strictly_positive_f32(kilograms)),
	-- The weighing device used for weighing. This field is optional as there
	-- are several situations where the weighing device is not tracked.
	weighed_with UUID REFERENCES weighing_devices(id),
	-- The procedure template asset model associated to the `weighed_with_model`.
	procedure_template_weighed_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The procedure asset associated to the `weighed_with_model`.
	procedure_weighed_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is a weighing procedure without the possibility of a mistake.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_weighed_with_model` must be the same as in the `weighing_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_weighed_container_model
	) REFERENCES weighing_procedure_templates(
		procedure_template,
		procedure_template_weighed_container_model
	),
	-- The `procedure_template_weighed_container_model` must be the same as in the `weighing_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_weighed_with_model
	) REFERENCES weighing_procedure_templates(
		procedure_template,
		procedure_template_weighed_with_model
	),
	-- We check that the `procedure_weighed_container` is associated to the `weighed_container`.
	FOREIGN KEY (procedure_weighed_container, weighed_container) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_weighed_with` is associated to the `procedure_template_weighed_container_model`.
	FOREIGN KEY (
		procedure_weighed_container,
		procedure_template_weighed_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_weighed_with` is associated to the `procedure_template_weighed_with_model`.
	FOREIGN KEY (
		procedure_weighed_with,
		procedure_template_weighed_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_weighed_with` is associated to the `weighed_with` asset (if any).
	FOREIGN KEY (procedure_weighed_with, weighed_with) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS harvesting_procedure_templates (
	-- Identifier of the harvesting procedure template, which is also a foreign key to the general procedure template.
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- Sample source model from which the sample is taken.
	sample_source_model INTEGER NOT NULL REFERENCES sample_source_models(id),
	procedure_template_sample_source_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- Sample model harvested from the sample source model.
	sample_model INTEGER NOT NULL REFERENCES sample_models(id),
	procedure_template_sample_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- We enforce that the `sample_source_model` is indeed a procedure asset model.
	FOREIGN KEY (
		procedure_template_sample_source_model,
		sample_source_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_sample_model,
		sample_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We enforce that the `sample_model` is associated with the `sample_source_model`.
	FOREIGN KEY (sample_model, sample_source_model) REFERENCES sample_models(id, sample_source_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_sample_source_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_sample_source_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_sample_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_sample_model
	)
);

CREATE TABLE IF NOT EXISTS harvesting_procedures (
	-- Identifier of the harvesting procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a harvesting procedure template.
	procedure_template INTEGER NOT NULL REFERENCES harvesting_procedure_templates(procedure_template),
	-- The sample source from which the sample is harvested, which must be a sample source asset.
	sample_source UUID NOT NULL REFERENCES sample_sources(id),
	-- The procedure template asset model associated to the `sample_source`.
	procedure_template_sample_source_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `sample_source`.
	procedure_sample_source UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The sample harvetsed from the sample source, which must be a sample asset.
	sample UUID NOT NULL REFERENCES samples(id),
	-- The procedure template asset model associated to the `sample`.
	procedure_template_sample_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `sample`.
	procedure_sample UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- We enforce that the `procedure_template_sample_source_model` is associated with the `procedure_template`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_sample_source_model
	) REFERENCES harvesting_procedure_templates(
		procedure_template,
		procedure_template_sample_source_model
	),
	-- We enforce that the `procedure_template_sample_model` is associated with the `procedure_template`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_sample_model
	) REFERENCES harvesting_procedure_templates(
		procedure_template,
		procedure_template_sample_model
	),
	-- We enforce that the `procedure_sample_source` is associated with the `sample_source`.
	FOREIGN KEY (procedure_sample_source, sample_source) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_sample` is associated with the `sample`.
	FOREIGN KEY (procedure_sample, sample) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_sample_source` is associated with `procedure_template_sample_source_model`.
	FOREIGN KEY (
		procedure_sample_source,
		procedure_template_sample_source_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the `procedure_sample` is associated with `procedure_template_sample_model`.
	FOREIGN KEY (
		procedure_sample,
		procedure_template_sample_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model)
);CREATE TABLE IF NOT EXISTS soil_models (
  id INTEGER PRIMARY KEY REFERENCES sample_source_models(id)
);
CREATE TABLE IF NOT EXISTS soils (
  id UUID PRIMARY KEY REFERENCES sample_sources(id),
  model INTEGER NOT NULL REFERENCES soil_models(id),
  FOREIGN KEY (id, model) REFERENCES assets(id, model)
);/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::CAS
CREATE TYPE CAS;

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_in
CREATE  FUNCTION "cas_in"(
	"input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS CAS /* core::option::Option<cas_codes::CAS> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_in_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_out
CREATE  FUNCTION "cas_out"(
	"input" CAS /* cas_codes::CAS */
) RETURNS cstring /* alloc::ffi::c_str::CString */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_out_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_recv
CREATE  FUNCTION "cas_recv"(
	"internal" internal /* pgrx::datum::internal::Internal */
) RETURNS CAS /* cas_codes::CAS */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_recv_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_send
CREATE  FUNCTION "cas_send"(
	"input" CAS /* cas_codes::CAS */
) RETURNS bytea /* alloc::vec::Vec<u8> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_send_wrapper';


-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::CAS
CREATE TYPE CAS (
	INTERNALLENGTH = variable,
	INPUT = cas_in, /* cas_codes::cas_in */
	OUTPUT = cas_out, /* cas_codes::cas_out */
	RECEIVE = cas_recv, /* cas_codes::cas_recv */
	SEND = cas_send, /* cas_codes::cas_send */
	STORAGE = extended
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_cmp
CREATE  FUNCTION "cas_cmp"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_cmp_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_eq
CREATE  FUNCTION "cas_eq"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_eq_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_eq
CREATE OPERATOR = (
	PROCEDURE="cas_eq",
	LEFTARG=CAS, /* cas_codes::CAS */
	RIGHTARG=CAS, /* cas_codes::CAS */
	COMMUTATOR = =,
	NEGATOR = <>,
	RESTRICT = eqsel,
	JOIN = eqjoinsel,
	HASHES,
	MERGES
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_ge
CREATE  FUNCTION "cas_ge"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_ge_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_ge
CREATE OPERATOR >= (
	PROCEDURE="cas_ge",
	LEFTARG=CAS, /* cas_codes::CAS */
	RIGHTARG=CAS, /* cas_codes::CAS */
	COMMUTATOR = <=,
	NEGATOR = <,
	RESTRICT = scalargesel,
	JOIN = scalargejoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_gt
CREATE  FUNCTION "cas_gt"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_gt_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_gt
CREATE OPERATOR > (
	PROCEDURE="cas_gt",
	LEFTARG=CAS, /* cas_codes::CAS */
	RIGHTARG=CAS, /* cas_codes::CAS */
	COMMUTATOR = <,
	NEGATOR = <=,
	RESTRICT = scalargtsel,
	JOIN = scalargtjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_hash
CREATE  FUNCTION "cas_hash"(
	"value" CAS /* cas_codes::CAS */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_hash_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_le
CREATE  FUNCTION "cas_le"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_le_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_le
CREATE OPERATOR <= (
	PROCEDURE="cas_le",
	LEFTARG=CAS, /* cas_codes::CAS */
	RIGHTARG=CAS, /* cas_codes::CAS */
	COMMUTATOR = >=,
	NEGATOR = >,
	RESTRICT = scalarlesel,
	JOIN = scalarlejoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_lt
CREATE  FUNCTION "cas_lt"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_lt_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_lt
CREATE OPERATOR < (
	PROCEDURE="cas_lt",
	LEFTARG=CAS, /* cas_codes::CAS */
	RIGHTARG=CAS, /* cas_codes::CAS */
	COMMUTATOR = >,
	NEGATOR = >=,
	RESTRICT = scalarltsel,
	JOIN = scalarltjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_ne
CREATE  FUNCTION "cas_ne"(
	"left" CAS, /* cas_codes::CAS */
	"right" CAS /* cas_codes::CAS */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'cas_ne_wrapper';

-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::cas_ne
CREATE OPERATOR <> (
	PROCEDURE="cas_ne",
	LEFTARG=CAS, /* cas_codes::CAS */
	RIGHTARG=CAS, /* cas_codes::CAS */
	COMMUTATOR = <>,
	NEGATOR = =,
	RESTRICT = neqsel,
	JOIN = neqjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::CAS
CREATE OPERATOR FAMILY CAS_btree_ops USING btree;
CREATE OPERATOR CLASS CAS_btree_ops DEFAULT FOR TYPE CAS USING btree FAMILY CAS_btree_ops AS
	OPERATOR 1 <,
	OPERATOR 2 <=,
	OPERATOR 3 =,
	OPERATOR 4 >=,
	OPERATOR 5 >,
	FUNCTION 1 cas_cmp(CAS, CAS);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/cas_codes/src/lib.rs:23
-- cas_codes::CAS
CREATE OPERATOR FAMILY CAS_hash_ops USING hash;
CREATE OPERATOR CLASS CAS_hash_ops DEFAULT FOR TYPE CAS USING hash FAMILY CAS_hash_ops AS
	OPERATOR    1   =  (CAS, CAS),
	FUNCTION    1   cas_hash(CAS);
/* </end connected objects> */

/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/actinium.rs:4
-- elements::isotopes::actinium::ActiniumIsotope
CREATE TYPE ActiniumIsotope AS ENUM (
	'Ac206',
	'Ac207',
	'Ac208',
	'Ac209',
	'Ac210',
	'Ac211',
	'Ac212',
	'Ac213',
	'Ac214',
	'Ac215',
	'Ac216',
	'Ac217',
	'Ac218',
	'Ac219',
	'Ac220',
	'Ac221',
	'Ac222',
	'Ac223',
	'Ac224',
	'Ac225',
	'Ac226',
	'Ac227',
	'Ac228',
	'Ac229',
	'Ac230',
	'Ac231',
	'Ac232',
	'Ac233',
	'Ac234',
	'Ac235',
	'Ac236',
	'Ac237'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/aluminium.rs:4
-- elements::isotopes::aluminium::AluminiumIsotope
CREATE TYPE AluminiumIsotope AS ENUM (
	'Al21',
	'Al22',
	'Al23',
	'Al24',
	'Al25',
	'Al26',
	'Al27',
	'Al28',
	'Al29',
	'Al30',
	'Al31',
	'Al32',
	'Al33',
	'Al34',
	'Al35',
	'Al36',
	'Al37',
	'Al38',
	'Al39',
	'Al40',
	'Al41',
	'Al42',
	'Al43'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/americium.rs:4
-- elements::isotopes::americium::AmericiumIsotope
CREATE TYPE AmericiumIsotope AS ENUM (
	'Am230',
	'Am231',
	'Am232',
	'Am233',
	'Am234',
	'Am235',
	'Am236',
	'Am237',
	'Am238',
	'Am239',
	'Am240',
	'Am241',
	'Am242',
	'Am243',
	'Am244',
	'Am245',
	'Am246',
	'Am247',
	'Am248',
	'Am249'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/antimony.rs:4
-- elements::isotopes::antimony::AntimonyIsotope
CREATE TYPE AntimonyIsotope AS ENUM (
	'Sb103',
	'Sb104',
	'Sb105',
	'Sb106',
	'Sb107',
	'Sb108',
	'Sb109',
	'Sb110',
	'Sb111',
	'Sb112',
	'Sb113',
	'Sb114',
	'Sb115',
	'Sb116',
	'Sb117',
	'Sb118',
	'Sb119',
	'Sb120',
	'Sb121',
	'Sb122',
	'Sb123',
	'Sb124',
	'Sb125',
	'Sb126',
	'Sb127',
	'Sb128',
	'Sb129',
	'Sb130',
	'Sb131',
	'Sb132',
	'Sb133',
	'Sb134',
	'Sb135',
	'Sb136',
	'Sb137',
	'Sb138',
	'Sb139',
	'Sb140'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/argon.rs:4
-- elements::isotopes::argon::ArgonIsotope
CREATE TYPE ArgonIsotope AS ENUM (
	'Ar30',
	'Ar31',
	'Ar32',
	'Ar33',
	'Ar34',
	'Ar35',
	'Ar36',
	'Ar37',
	'Ar38',
	'Ar39',
	'Ar40',
	'Ar41',
	'Ar42',
	'Ar43',
	'Ar44',
	'Ar45',
	'Ar46',
	'Ar47',
	'Ar48',
	'Ar49',
	'Ar50',
	'Ar51',
	'Ar52',
	'Ar53'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/arsenic.rs:4
-- elements::isotopes::arsenic::ArsenicIsotope
CREATE TYPE ArsenicIsotope AS ENUM (
	'As60',
	'As61',
	'As62',
	'As63',
	'As64',
	'As65',
	'As66',
	'As67',
	'As68',
	'As69',
	'As70',
	'As71',
	'As72',
	'As73',
	'As74',
	'As75',
	'As76',
	'As77',
	'As78',
	'As79',
	'As80',
	'As81',
	'As82',
	'As83',
	'As84',
	'As85',
	'As86',
	'As87',
	'As88',
	'As89',
	'As90',
	'As91',
	'As92'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/astatine.rs:4
-- elements::isotopes::astatine::AstatineIsotope
CREATE TYPE AstatineIsotope AS ENUM (
	'At191',
	'At192',
	'At193',
	'At194',
	'At195',
	'At196',
	'At197',
	'At198',
	'At199',
	'At200',
	'At201',
	'At202',
	'At203',
	'At204',
	'At205',
	'At206',
	'At207',
	'At208',
	'At209',
	'At210',
	'At211',
	'At212',
	'At213',
	'At214',
	'At215',
	'At216',
	'At217',
	'At218',
	'At219',
	'At220',
	'At221',
	'At222',
	'At223',
	'At224',
	'At225',
	'At226',
	'At227',
	'At228',
	'At229'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/barium.rs:4
-- elements::isotopes::barium::BariumIsotope
CREATE TYPE BariumIsotope AS ENUM (
	'Ba114',
	'Ba115',
	'Ba116',
	'Ba117',
	'Ba118',
	'Ba119',
	'Ba120',
	'Ba121',
	'Ba122',
	'Ba123',
	'Ba124',
	'Ba125',
	'Ba126',
	'Ba127',
	'Ba128',
	'Ba129',
	'Ba130',
	'Ba131',
	'Ba132',
	'Ba133',
	'Ba134',
	'Ba135',
	'Ba136',
	'Ba137',
	'Ba138',
	'Ba139',
	'Ba140',
	'Ba141',
	'Ba142',
	'Ba143',
	'Ba144',
	'Ba145',
	'Ba146',
	'Ba147',
	'Ba148',
	'Ba149',
	'Ba150',
	'Ba151',
	'Ba152',
	'Ba153'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/berkelium.rs:4
-- elements::isotopes::berkelium::BerkeliumIsotope
CREATE TYPE BerkeliumIsotope AS ENUM (
	'Bk234',
	'Bk235',
	'Bk236',
	'Bk237',
	'Bk238',
	'Bk239',
	'Bk240',
	'Bk241',
	'Bk242',
	'Bk243',
	'Bk244',
	'Bk245',
	'Bk246',
	'Bk247',
	'Bk248',
	'Bk249',
	'Bk250',
	'Bk251',
	'Bk252',
	'Bk253',
	'Bk254'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/beryllium.rs:4
-- elements::isotopes::beryllium::BerylliumIsotope
CREATE TYPE BerylliumIsotope AS ENUM (
	'Be5',
	'Be6',
	'Be7',
	'Be8',
	'Be9',
	'Be10',
	'Be11',
	'Be12',
	'Be13',
	'Be14',
	'Be15',
	'Be16'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/bismuth.rs:4
-- elements::isotopes::bismuth::BismuthIsotope
CREATE TYPE BismuthIsotope AS ENUM (
	'Bi184',
	'Bi185',
	'Bi186',
	'Bi187',
	'Bi188',
	'Bi189',
	'Bi190',
	'Bi191',
	'Bi192',
	'Bi193',
	'Bi194',
	'Bi195',
	'Bi196',
	'Bi197',
	'Bi198',
	'Bi199',
	'Bi200',
	'Bi201',
	'Bi202',
	'Bi203',
	'Bi204',
	'Bi205',
	'Bi206',
	'Bi207',
	'Bi208',
	'Bi209',
	'Bi210',
	'Bi211',
	'Bi212',
	'Bi213',
	'Bi214',
	'Bi215',
	'Bi216',
	'Bi217',
	'Bi218',
	'Bi219',
	'Bi220',
	'Bi221',
	'Bi222',
	'Bi223',
	'Bi224'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/bohrium.rs:4
-- elements::isotopes::bohrium::BohriumIsotope
CREATE TYPE BohriumIsotope AS ENUM (
	'Bh260',
	'Bh261',
	'Bh262',
	'Bh263',
	'Bh264',
	'Bh265',
	'Bh266',
	'Bh267',
	'Bh268',
	'Bh269',
	'Bh270',
	'Bh271',
	'Bh272',
	'Bh273',
	'Bh274',
	'Bh275'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/boron.rs:4
-- elements::isotopes::boron::BoronIsotope
CREATE TYPE BoronIsotope AS ENUM (
	'B6',
	'B7',
	'B8',
	'B9',
	'B10',
	'B11',
	'B12',
	'B13',
	'B14',
	'B15',
	'B16',
	'B17',
	'B18',
	'B19',
	'B20',
	'B21'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/bromine.rs:4
-- elements::isotopes::bromine::BromineIsotope
CREATE TYPE BromineIsotope AS ENUM (
	'Br67',
	'Br68',
	'Br69',
	'Br70',
	'Br71',
	'Br72',
	'Br73',
	'Br74',
	'Br75',
	'Br76',
	'Br77',
	'Br78',
	'Br79',
	'Br80',
	'Br81',
	'Br82',
	'Br83',
	'Br84',
	'Br85',
	'Br86',
	'Br87',
	'Br88',
	'Br89',
	'Br90',
	'Br91',
	'Br92',
	'Br93',
	'Br94',
	'Br95',
	'Br96',
	'Br97',
	'Br98'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/cadmium.rs:4
-- elements::isotopes::cadmium::CadmiumIsotope
CREATE TYPE CadmiumIsotope AS ENUM (
	'Cd95',
	'Cd96',
	'Cd97',
	'Cd98',
	'Cd99',
	'Cd100',
	'Cd101',
	'Cd102',
	'Cd103',
	'Cd104',
	'Cd105',
	'Cd106',
	'Cd107',
	'Cd108',
	'Cd109',
	'Cd110',
	'Cd111',
	'Cd112',
	'Cd113',
	'Cd114',
	'Cd115',
	'Cd116',
	'Cd117',
	'Cd118',
	'Cd119',
	'Cd120',
	'Cd121',
	'Cd122',
	'Cd123',
	'Cd124',
	'Cd125',
	'Cd126',
	'Cd127',
	'Cd128',
	'Cd129',
	'Cd130',
	'Cd131',
	'Cd132',
	'Cd133'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/caesium.rs:4
-- elements::isotopes::caesium::CaesiumIsotope
CREATE TYPE CaesiumIsotope AS ENUM (
	'Cs112',
	'Cs113',
	'Cs114',
	'Cs115',
	'Cs116',
	'Cs117',
	'Cs118',
	'Cs119',
	'Cs120',
	'Cs121',
	'Cs122',
	'Cs123',
	'Cs124',
	'Cs125',
	'Cs126',
	'Cs127',
	'Cs128',
	'Cs129',
	'Cs130',
	'Cs131',
	'Cs132',
	'Cs133',
	'Cs134',
	'Cs135',
	'Cs136',
	'Cs137',
	'Cs138',
	'Cs139',
	'Cs140',
	'Cs141',
	'Cs142',
	'Cs143',
	'Cs144',
	'Cs145',
	'Cs146',
	'Cs147',
	'Cs148',
	'Cs149',
	'Cs150',
	'Cs151'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/calcium.rs:4
-- elements::isotopes::calcium::CalciumIsotope
CREATE TYPE CalciumIsotope AS ENUM (
	'Ca34',
	'Ca35',
	'Ca36',
	'Ca37',
	'Ca38',
	'Ca39',
	'Ca40',
	'Ca41',
	'Ca42',
	'Ca43',
	'Ca44',
	'Ca45',
	'Ca46',
	'Ca47',
	'Ca48',
	'Ca49',
	'Ca50',
	'Ca51',
	'Ca52',
	'Ca53',
	'Ca54',
	'Ca55',
	'Ca56',
	'Ca57',
	'Ca58'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/californium.rs:4
-- elements::isotopes::californium::CaliforniumIsotope
CREATE TYPE CaliforniumIsotope AS ENUM (
	'Cf237',
	'Cf238',
	'Cf239',
	'Cf240',
	'Cf241',
	'Cf242',
	'Cf243',
	'Cf244',
	'Cf245',
	'Cf246',
	'Cf247',
	'Cf248',
	'Cf249',
	'Cf250',
	'Cf251',
	'Cf252',
	'Cf253',
	'Cf254',
	'Cf255',
	'Cf256'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/carbon.rs:4
-- elements::isotopes::carbon::CarbonIsotope
CREATE TYPE CarbonIsotope AS ENUM (
	'C8',
	'C9',
	'C10',
	'C11',
	'C12',
	'C13',
	'C14',
	'C15',
	'C16',
	'C17',
	'C18',
	'C19',
	'C20',
	'C21',
	'C22',
	'C23'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/cerium.rs:4
-- elements::isotopes::cerium::CeriumIsotope
CREATE TYPE CeriumIsotope AS ENUM (
	'Ce119',
	'Ce120',
	'Ce121',
	'Ce122',
	'Ce123',
	'Ce124',
	'Ce125',
	'Ce126',
	'Ce127',
	'Ce128',
	'Ce129',
	'Ce130',
	'Ce131',
	'Ce132',
	'Ce133',
	'Ce134',
	'Ce135',
	'Ce136',
	'Ce137',
	'Ce138',
	'Ce139',
	'Ce140',
	'Ce141',
	'Ce142',
	'Ce143',
	'Ce144',
	'Ce145',
	'Ce146',
	'Ce147',
	'Ce148',
	'Ce149',
	'Ce150',
	'Ce151',
	'Ce152',
	'Ce153',
	'Ce154',
	'Ce155',
	'Ce156',
	'Ce157'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/chlorine.rs:4
-- elements::isotopes::chlorine::ChlorineIsotope
CREATE TYPE ChlorineIsotope AS ENUM (
	'Cl28',
	'Cl29',
	'Cl30',
	'Cl31',
	'Cl32',
	'Cl33',
	'Cl34',
	'Cl35',
	'Cl36',
	'Cl37',
	'Cl38',
	'Cl39',
	'Cl40',
	'Cl41',
	'Cl42',
	'Cl43',
	'Cl44',
	'Cl45',
	'Cl46',
	'Cl47',
	'Cl48',
	'Cl49',
	'Cl50',
	'Cl51'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/chromium.rs:4
-- elements::isotopes::chromium::ChromiumIsotope
CREATE TYPE ChromiumIsotope AS ENUM (
	'Cr42',
	'Cr43',
	'Cr44',
	'Cr45',
	'Cr46',
	'Cr47',
	'Cr48',
	'Cr49',
	'Cr50',
	'Cr51',
	'Cr52',
	'Cr53',
	'Cr54',
	'Cr55',
	'Cr56',
	'Cr57',
	'Cr58',
	'Cr59',
	'Cr60',
	'Cr61',
	'Cr62',
	'Cr63',
	'Cr64',
	'Cr65',
	'Cr66',
	'Cr67',
	'Cr68'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/cobalt.rs:4
-- elements::isotopes::cobalt::CobaltIsotope
CREATE TYPE CobaltIsotope AS ENUM (
	'Co47',
	'Co48',
	'Co49',
	'Co50',
	'Co51',
	'Co52',
	'Co53',
	'Co54',
	'Co55',
	'Co56',
	'Co57',
	'Co58',
	'Co59',
	'Co60',
	'Co61',
	'Co62',
	'Co63',
	'Co64',
	'Co65',
	'Co66',
	'Co67',
	'Co68',
	'Co69',
	'Co70',
	'Co71',
	'Co72',
	'Co73',
	'Co74',
	'Co75',
	'Co76'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/copernicium.rs:4
-- elements::isotopes::copernicium::CoperniciumIsotope
CREATE TYPE CoperniciumIsotope AS ENUM (
	'Cn276',
	'Cn277',
	'Cn278',
	'Cn279',
	'Cn280',
	'Cn281',
	'Cn282',
	'Cn283',
	'Cn284',
	'Cn285'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/copper.rs:4
-- elements::isotopes::copper::CopperIsotope
CREATE TYPE CopperIsotope AS ENUM (
	'Cu52',
	'Cu53',
	'Cu54',
	'Cu55',
	'Cu56',
	'Cu57',
	'Cu58',
	'Cu59',
	'Cu60',
	'Cu61',
	'Cu62',
	'Cu63',
	'Cu64',
	'Cu65',
	'Cu66',
	'Cu67',
	'Cu68',
	'Cu69',
	'Cu70',
	'Cu71',
	'Cu72',
	'Cu73',
	'Cu74',
	'Cu75',
	'Cu76',
	'Cu77',
	'Cu78',
	'Cu79',
	'Cu80',
	'Cu81',
	'Cu82'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/curium.rs:4
-- elements::isotopes::curium::CuriumIsotope
CREATE TYPE CuriumIsotope AS ENUM (
	'Cm232',
	'Cm233',
	'Cm234',
	'Cm235',
	'Cm236',
	'Cm237',
	'Cm238',
	'Cm239',
	'Cm240',
	'Cm241',
	'Cm242',
	'Cm243',
	'Cm244',
	'Cm245',
	'Cm246',
	'Cm247',
	'Cm248',
	'Cm249',
	'Cm250',
	'Cm251',
	'Cm252'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/darmstadtium.rs:4
-- elements::isotopes::darmstadtium::DarmstadtiumIsotope
CREATE TYPE DarmstadtiumIsotope AS ENUM (
	'Ds267',
	'Ds268',
	'Ds269',
	'Ds270',
	'Ds271',
	'Ds272',
	'Ds273',
	'Ds274',
	'Ds275',
	'Ds276',
	'Ds277',
	'Ds278',
	'Ds279',
	'Ds280',
	'Ds281'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/dubnium.rs:4
-- elements::isotopes::dubnium::DubniumIsotope
CREATE TYPE DubniumIsotope AS ENUM (
	'Db255',
	'Db256',
	'Db257',
	'Db258',
	'Db259',
	'Db260',
	'Db261',
	'Db262',
	'Db263',
	'Db264',
	'Db265',
	'Db266',
	'Db267',
	'Db268',
	'Db269',
	'Db270'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/dysprosium.rs:4
-- elements::isotopes::dysprosium::DysprosiumIsotope
CREATE TYPE DysprosiumIsotope AS ENUM (
	'Dy138',
	'Dy139',
	'Dy140',
	'Dy141',
	'Dy142',
	'Dy143',
	'Dy144',
	'Dy145',
	'Dy146',
	'Dy147',
	'Dy148',
	'Dy149',
	'Dy150',
	'Dy151',
	'Dy152',
	'Dy153',
	'Dy154',
	'Dy155',
	'Dy156',
	'Dy157',
	'Dy158',
	'Dy159',
	'Dy160',
	'Dy161',
	'Dy162',
	'Dy163',
	'Dy164',
	'Dy165',
	'Dy166',
	'Dy167',
	'Dy168',
	'Dy169',
	'Dy170',
	'Dy171',
	'Dy172',
	'Dy173'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/einsteinium.rs:4
-- elements::isotopes::einsteinium::EinsteiniumIsotope
CREATE TYPE EinsteiniumIsotope AS ENUM (
	'Es239',
	'Es240',
	'Es241',
	'Es242',
	'Es243',
	'Es244',
	'Es245',
	'Es246',
	'Es247',
	'Es248',
	'Es249',
	'Es250',
	'Es251',
	'Es252',
	'Es253',
	'Es254',
	'Es255',
	'Es256',
	'Es257',
	'Es258'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/erbium.rs:4
-- elements::isotopes::erbium::ErbiumIsotope
CREATE TYPE ErbiumIsotope AS ENUM (
	'Er142',
	'Er143',
	'Er144',
	'Er145',
	'Er146',
	'Er147',
	'Er148',
	'Er149',
	'Er150',
	'Er151',
	'Er152',
	'Er153',
	'Er154',
	'Er155',
	'Er156',
	'Er157',
	'Er158',
	'Er159',
	'Er160',
	'Er161',
	'Er162',
	'Er163',
	'Er164',
	'Er165',
	'Er166',
	'Er167',
	'Er168',
	'Er169',
	'Er170',
	'Er171',
	'Er172',
	'Er173',
	'Er174',
	'Er175',
	'Er176',
	'Er177'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/europium.rs:4
-- elements::isotopes::europium::EuropiumIsotope
CREATE TYPE EuropiumIsotope AS ENUM (
	'Eu130',
	'Eu131',
	'Eu132',
	'Eu133',
	'Eu134',
	'Eu135',
	'Eu136',
	'Eu137',
	'Eu138',
	'Eu139',
	'Eu140',
	'Eu141',
	'Eu142',
	'Eu143',
	'Eu144',
	'Eu145',
	'Eu146',
	'Eu147',
	'Eu148',
	'Eu149',
	'Eu150',
	'Eu151',
	'Eu152',
	'Eu153',
	'Eu154',
	'Eu155',
	'Eu156',
	'Eu157',
	'Eu158',
	'Eu159',
	'Eu160',
	'Eu161',
	'Eu162',
	'Eu163',
	'Eu164',
	'Eu165',
	'Eu166',
	'Eu167'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/fermium.rs:4
-- elements::isotopes::fermium::FermiumIsotope
CREATE TYPE FermiumIsotope AS ENUM (
	'Fm241',
	'Fm242',
	'Fm243',
	'Fm244',
	'Fm245',
	'Fm246',
	'Fm247',
	'Fm248',
	'Fm249',
	'Fm250',
	'Fm251',
	'Fm252',
	'Fm253',
	'Fm254',
	'Fm255',
	'Fm256',
	'Fm257',
	'Fm258',
	'Fm259',
	'Fm260'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/flerovium.rs:4
-- elements::isotopes::flerovium::FleroviumIsotope
CREATE TYPE FleroviumIsotope AS ENUM (
	'Fl285',
	'Fl286',
	'Fl287',
	'Fl288',
	'Fl289'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/fluorine.rs:4
-- elements::isotopes::fluorine::FluorineIsotope
CREATE TYPE FluorineIsotope AS ENUM (
	'F14',
	'F15',
	'F16',
	'F17',
	'F18',
	'F19',
	'F20',
	'F21',
	'F22',
	'F23',
	'F24',
	'F25',
	'F26',
	'F27',
	'F28',
	'F29',
	'F30',
	'F31'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/francium.rs:4
-- elements::isotopes::francium::FranciumIsotope
CREATE TYPE FranciumIsotope AS ENUM (
	'Fr199',
	'Fr200',
	'Fr201',
	'Fr202',
	'Fr203',
	'Fr204',
	'Fr205',
	'Fr206',
	'Fr207',
	'Fr208',
	'Fr209',
	'Fr210',
	'Fr211',
	'Fr212',
	'Fr213',
	'Fr214',
	'Fr215',
	'Fr216',
	'Fr217',
	'Fr218',
	'Fr219',
	'Fr220',
	'Fr221',
	'Fr222',
	'Fr223',
	'Fr224',
	'Fr225',
	'Fr226',
	'Fr227',
	'Fr228',
	'Fr229',
	'Fr230',
	'Fr231',
	'Fr232',
	'Fr233'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/gadolinium.rs:4
-- elements::isotopes::gadolinium::GadoliniumIsotope
CREATE TYPE GadoliniumIsotope AS ENUM (
	'Gd133',
	'Gd134',
	'Gd135',
	'Gd136',
	'Gd137',
	'Gd138',
	'Gd139',
	'Gd140',
	'Gd141',
	'Gd142',
	'Gd143',
	'Gd144',
	'Gd145',
	'Gd146',
	'Gd147',
	'Gd148',
	'Gd149',
	'Gd150',
	'Gd151',
	'Gd152',
	'Gd153',
	'Gd154',
	'Gd155',
	'Gd156',
	'Gd157',
	'Gd158',
	'Gd159',
	'Gd160',
	'Gd161',
	'Gd162',
	'Gd163',
	'Gd164',
	'Gd165',
	'Gd166',
	'Gd167',
	'Gd168',
	'Gd169'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/gallium.rs:4
-- elements::isotopes::gallium::GalliumIsotope
CREATE TYPE GalliumIsotope AS ENUM (
	'Ga56',
	'Ga57',
	'Ga58',
	'Ga59',
	'Ga60',
	'Ga61',
	'Ga62',
	'Ga63',
	'Ga64',
	'Ga65',
	'Ga66',
	'Ga67',
	'Ga68',
	'Ga69',
	'Ga70',
	'Ga71',
	'Ga72',
	'Ga73',
	'Ga74',
	'Ga75',
	'Ga76',
	'Ga77',
	'Ga78',
	'Ga79',
	'Ga80',
	'Ga81',
	'Ga82',
	'Ga83',
	'Ga84',
	'Ga85',
	'Ga86',
	'Ga87'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/germanium.rs:4
-- elements::isotopes::germanium::GermaniumIsotope
CREATE TYPE GermaniumIsotope AS ENUM (
	'Ge58',
	'Ge59',
	'Ge60',
	'Ge61',
	'Ge62',
	'Ge63',
	'Ge64',
	'Ge65',
	'Ge66',
	'Ge67',
	'Ge68',
	'Ge69',
	'Ge70',
	'Ge71',
	'Ge72',
	'Ge73',
	'Ge74',
	'Ge75',
	'Ge76',
	'Ge77',
	'Ge78',
	'Ge79',
	'Ge80',
	'Ge81',
	'Ge82',
	'Ge83',
	'Ge84',
	'Ge85',
	'Ge86',
	'Ge87',
	'Ge88',
	'Ge89',
	'Ge90'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/gold.rs:4
-- elements::isotopes::gold::GoldIsotope
CREATE TYPE GoldIsotope AS ENUM (
	'Au169',
	'Au170',
	'Au171',
	'Au172',
	'Au173',
	'Au174',
	'Au175',
	'Au176',
	'Au177',
	'Au178',
	'Au179',
	'Au180',
	'Au181',
	'Au182',
	'Au183',
	'Au184',
	'Au185',
	'Au186',
	'Au187',
	'Au188',
	'Au189',
	'Au190',
	'Au191',
	'Au192',
	'Au193',
	'Au194',
	'Au195',
	'Au196',
	'Au197',
	'Au198',
	'Au199',
	'Au200',
	'Au201',
	'Au202',
	'Au203',
	'Au204',
	'Au205',
	'Au206',
	'Au207',
	'Au208',
	'Au209',
	'Au210'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/hafnium.rs:4
-- elements::isotopes::hafnium::HafniumIsotope
CREATE TYPE HafniumIsotope AS ENUM (
	'Hf153',
	'Hf154',
	'Hf155',
	'Hf156',
	'Hf157',
	'Hf158',
	'Hf159',
	'Hf160',
	'Hf161',
	'Hf162',
	'Hf163',
	'Hf164',
	'Hf165',
	'Hf166',
	'Hf167',
	'Hf168',
	'Hf169',
	'Hf170',
	'Hf171',
	'Hf172',
	'Hf173',
	'Hf174',
	'Hf175',
	'Hf176',
	'Hf177',
	'Hf178',
	'Hf179',
	'Hf180',
	'Hf181',
	'Hf182',
	'Hf183',
	'Hf184',
	'Hf185',
	'Hf186',
	'Hf187',
	'Hf188',
	'Hf189'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/hassium.rs:4
-- elements::isotopes::hassium::HassiumIsotope
CREATE TYPE HassiumIsotope AS ENUM (
	'Hs263',
	'Hs264',
	'Hs265',
	'Hs266',
	'Hs267',
	'Hs268',
	'Hs269',
	'Hs270',
	'Hs271',
	'Hs272',
	'Hs273',
	'Hs274',
	'Hs275',
	'Hs276',
	'Hs277'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/helium.rs:4
-- elements::isotopes::helium::HeliumIsotope
CREATE TYPE HeliumIsotope AS ENUM (
	'He3',
	'He4',
	'He5',
	'He6',
	'He7',
	'He8',
	'He9',
	'He10'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/holmium.rs:4
-- elements::isotopes::holmium::HolmiumIsotope
CREATE TYPE HolmiumIsotope AS ENUM (
	'Ho140',
	'Ho141',
	'Ho142',
	'Ho143',
	'Ho144',
	'Ho145',
	'Ho146',
	'Ho147',
	'Ho148',
	'Ho149',
	'Ho150',
	'Ho151',
	'Ho152',
	'Ho153',
	'Ho154',
	'Ho155',
	'Ho156',
	'Ho157',
	'Ho158',
	'Ho159',
	'Ho160',
	'Ho161',
	'Ho162',
	'Ho163',
	'Ho164',
	'Ho165',
	'Ho166',
	'Ho167',
	'Ho168',
	'Ho169',
	'Ho170',
	'Ho171',
	'Ho172',
	'Ho173',
	'Ho174',
	'Ho175'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/hydrogen.rs:4
-- elements::isotopes::hydrogen::HydrogenIsotope
CREATE TYPE HydrogenIsotope AS ENUM (
	'H1',
	'D2',
	'T3',
	'H4',
	'H5',
	'H6',
	'H7'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/indium.rs:4
-- elements::isotopes::indium::IndiumIsotope
CREATE TYPE IndiumIsotope AS ENUM (
	'In97',
	'In98',
	'In99',
	'In100',
	'In101',
	'In102',
	'In103',
	'In104',
	'In105',
	'In106',
	'In107',
	'In108',
	'In109',
	'In110',
	'In111',
	'In112',
	'In113',
	'In114',
	'In115',
	'In116',
	'In117',
	'In118',
	'In119',
	'In120',
	'In121',
	'In122',
	'In123',
	'In124',
	'In125',
	'In126',
	'In127',
	'In128',
	'In129',
	'In130',
	'In131',
	'In132',
	'In133',
	'In134',
	'In135'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/iodine.rs:4
-- elements::isotopes::iodine::IodineIsotope
CREATE TYPE IodineIsotope AS ENUM (
	'I107',
	'I108',
	'I109',
	'I110',
	'I111',
	'I112',
	'I113',
	'I114',
	'I115',
	'I116',
	'I117',
	'I118',
	'I119',
	'I120',
	'I121',
	'I122',
	'I123',
	'I124',
	'I125',
	'I126',
	'I127',
	'I128',
	'I129',
	'I130',
	'I131',
	'I132',
	'I133',
	'I134',
	'I135',
	'I136',
	'I137',
	'I138',
	'I139',
	'I140',
	'I141',
	'I142',
	'I143',
	'I144',
	'I145'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/iridium.rs:4
-- elements::isotopes::iridium::IridiumIsotope
CREATE TYPE IridiumIsotope AS ENUM (
	'Ir164',
	'Ir165',
	'Ir166',
	'Ir167',
	'Ir168',
	'Ir169',
	'Ir170',
	'Ir171',
	'Ir172',
	'Ir173',
	'Ir174',
	'Ir175',
	'Ir176',
	'Ir177',
	'Ir178',
	'Ir179',
	'Ir180',
	'Ir181',
	'Ir182',
	'Ir183',
	'Ir184',
	'Ir185',
	'Ir186',
	'Ir187',
	'Ir188',
	'Ir189',
	'Ir190',
	'Ir191',
	'Ir192',
	'Ir193',
	'Ir194',
	'Ir195',
	'Ir196',
	'Ir197',
	'Ir198',
	'Ir199',
	'Ir200',
	'Ir201',
	'Ir202',
	'Ir203',
	'Ir204'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/iron.rs:4
-- elements::isotopes::iron::IronIsotope
CREATE TYPE IronIsotope AS ENUM (
	'Fe45',
	'Fe46',
	'Fe47',
	'Fe48',
	'Fe49',
	'Fe50',
	'Fe51',
	'Fe52',
	'Fe53',
	'Fe54',
	'Fe55',
	'Fe56',
	'Fe57',
	'Fe58',
	'Fe59',
	'Fe60',
	'Fe61',
	'Fe62',
	'Fe63',
	'Fe64',
	'Fe65',
	'Fe66',
	'Fe67',
	'Fe68',
	'Fe69',
	'Fe70',
	'Fe71',
	'Fe72',
	'Fe73',
	'Fe74'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/krypton.rs:4
-- elements::isotopes::krypton::KryptonIsotope
CREATE TYPE KryptonIsotope AS ENUM (
	'Kr69',
	'Kr70',
	'Kr71',
	'Kr72',
	'Kr73',
	'Kr74',
	'Kr75',
	'Kr76',
	'Kr77',
	'Kr78',
	'Kr79',
	'Kr80',
	'Kr81',
	'Kr82',
	'Kr83',
	'Kr84',
	'Kr85',
	'Kr86',
	'Kr87',
	'Kr88',
	'Kr89',
	'Kr90',
	'Kr91',
	'Kr92',
	'Kr93',
	'Kr94',
	'Kr95',
	'Kr96',
	'Kr97',
	'Kr98',
	'Kr99',
	'Kr100',
	'Kr101'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/lanthanum.rs:4
-- elements::isotopes::lanthanum::LanthanumIsotope
CREATE TYPE LanthanumIsotope AS ENUM (
	'La116',
	'La117',
	'La118',
	'La119',
	'La120',
	'La121',
	'La122',
	'La123',
	'La124',
	'La125',
	'La126',
	'La127',
	'La128',
	'La129',
	'La130',
	'La131',
	'La132',
	'La133',
	'La134',
	'La135',
	'La136',
	'La137',
	'La138',
	'La139',
	'La140',
	'La141',
	'La142',
	'La143',
	'La144',
	'La145',
	'La146',
	'La147',
	'La148',
	'La149',
	'La150',
	'La151',
	'La152',
	'La153',
	'La154',
	'La155'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/lawrencium.rs:4
-- elements::isotopes::lawrencium::LawrenciumIsotope
CREATE TYPE LawrenciumIsotope AS ENUM (
	'Lr251',
	'Lr252',
	'Lr253',
	'Lr254',
	'Lr255',
	'Lr256',
	'Lr257',
	'Lr258',
	'Lr259',
	'Lr260',
	'Lr261',
	'Lr262',
	'Lr263',
	'Lr264',
	'Lr265',
	'Lr266'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/lead.rs:4
-- elements::isotopes::lead::LeadIsotope
CREATE TYPE LeadIsotope AS ENUM (
	'Pb178',
	'Pb179',
	'Pb180',
	'Pb181',
	'Pb182',
	'Pb183',
	'Pb184',
	'Pb185',
	'Pb186',
	'Pb187',
	'Pb188',
	'Pb189',
	'Pb190',
	'Pb191',
	'Pb192',
	'Pb193',
	'Pb194',
	'Pb195',
	'Pb196',
	'Pb197',
	'Pb198',
	'Pb199',
	'Pb200',
	'Pb201',
	'Pb202',
	'Pb203',
	'Pb204',
	'Pb205',
	'Pb206',
	'Pb207',
	'Pb208',
	'Pb209',
	'Pb210',
	'Pb211',
	'Pb212',
	'Pb213',
	'Pb214',
	'Pb215',
	'Pb216',
	'Pb217',
	'Pb218',
	'Pb219',
	'Pb220'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/lithium.rs:4
-- elements::isotopes::lithium::LithiumIsotope
CREATE TYPE LithiumIsotope AS ENUM (
	'Li3',
	'Li4',
	'Li5',
	'Li6',
	'Li7',
	'Li8',
	'Li9',
	'Li10',
	'Li11',
	'Li12',
	'Li13'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/livermorium.rs:4
-- elements::isotopes::livermorium::LivermoriumIsotope
CREATE TYPE LivermoriumIsotope AS ENUM (
	'Lv289',
	'Lv290',
	'Lv291',
	'Lv292',
	'Lv293'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/lutetium.rs:4
-- elements::isotopes::lutetium::LutetiumIsotope
CREATE TYPE LutetiumIsotope AS ENUM (
	'Lu150',
	'Lu151',
	'Lu152',
	'Lu153',
	'Lu154',
	'Lu155',
	'Lu156',
	'Lu157',
	'Lu158',
	'Lu159',
	'Lu160',
	'Lu161',
	'Lu162',
	'Lu163',
	'Lu164',
	'Lu165',
	'Lu166',
	'Lu167',
	'Lu168',
	'Lu169',
	'Lu170',
	'Lu171',
	'Lu172',
	'Lu173',
	'Lu174',
	'Lu175',
	'Lu176',
	'Lu177',
	'Lu178',
	'Lu179',
	'Lu180',
	'Lu181',
	'Lu182',
	'Lu183',
	'Lu184',
	'Lu185'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/magnesium.rs:4
-- elements::isotopes::magnesium::MagnesiumIsotope
CREATE TYPE MagnesiumIsotope AS ENUM (
	'Mg19',
	'Mg20',
	'Mg21',
	'Mg22',
	'Mg23',
	'Mg24',
	'Mg25',
	'Mg26',
	'Mg27',
	'Mg28',
	'Mg29',
	'Mg30',
	'Mg31',
	'Mg32',
	'Mg33',
	'Mg34',
	'Mg35',
	'Mg36',
	'Mg37',
	'Mg38',
	'Mg39',
	'Mg40'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/manganese.rs:4
-- elements::isotopes::manganese::ManganeseIsotope
CREATE TYPE ManganeseIsotope AS ENUM (
	'Mn44',
	'Mn45',
	'Mn46',
	'Mn47',
	'Mn48',
	'Mn49',
	'Mn50',
	'Mn51',
	'Mn52',
	'Mn53',
	'Mn54',
	'Mn55',
	'Mn56',
	'Mn57',
	'Mn58',
	'Mn59',
	'Mn60',
	'Mn61',
	'Mn62',
	'Mn63',
	'Mn64',
	'Mn65',
	'Mn66',
	'Mn67',
	'Mn68',
	'Mn69',
	'Mn70',
	'Mn71'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/meitnerium.rs:4
-- elements::isotopes::meitnerium::MeitneriumIsotope
CREATE TYPE MeitneriumIsotope AS ENUM (
	'Mt265',
	'Mt266',
	'Mt267',
	'Mt268',
	'Mt269',
	'Mt270',
	'Mt271',
	'Mt272',
	'Mt273',
	'Mt274',
	'Mt275',
	'Mt276',
	'Mt277',
	'Mt278',
	'Mt279'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/mendelevium.rs:4
-- elements::isotopes::mendelevium::MendeleviumIsotope
CREATE TYPE MendeleviumIsotope AS ENUM (
	'Md245',
	'Md246',
	'Md247',
	'Md248',
	'Md249',
	'Md250',
	'Md251',
	'Md252',
	'Md253',
	'Md254',
	'Md255',
	'Md256',
	'Md257',
	'Md258',
	'Md259',
	'Md260',
	'Md261',
	'Md262'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/mercury.rs:4
-- elements::isotopes::mercury::MercuryIsotope
CREATE TYPE MercuryIsotope AS ENUM (
	'Hg171',
	'Hg172',
	'Hg173',
	'Hg174',
	'Hg175',
	'Hg176',
	'Hg177',
	'Hg178',
	'Hg179',
	'Hg180',
	'Hg181',
	'Hg182',
	'Hg183',
	'Hg184',
	'Hg185',
	'Hg186',
	'Hg187',
	'Hg188',
	'Hg189',
	'Hg190',
	'Hg191',
	'Hg192',
	'Hg193',
	'Hg194',
	'Hg195',
	'Hg196',
	'Hg197',
	'Hg198',
	'Hg199',
	'Hg200',
	'Hg201',
	'Hg202',
	'Hg203',
	'Hg204',
	'Hg205',
	'Hg206',
	'Hg207',
	'Hg208',
	'Hg209',
	'Hg210',
	'Hg211',
	'Hg212',
	'Hg213',
	'Hg214',
	'Hg215',
	'Hg216'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/molybdenum.rs:4
-- elements::isotopes::molybdenum::MolybdenumIsotope
CREATE TYPE MolybdenumIsotope AS ENUM (
	'Mo83',
	'Mo84',
	'Mo85',
	'Mo86',
	'Mo87',
	'Mo88',
	'Mo89',
	'Mo90',
	'Mo91',
	'Mo92',
	'Mo93',
	'Mo94',
	'Mo95',
	'Mo96',
	'Mo97',
	'Mo98',
	'Mo99',
	'Mo100',
	'Mo101',
	'Mo102',
	'Mo103',
	'Mo104',
	'Mo105',
	'Mo106',
	'Mo107',
	'Mo108',
	'Mo109',
	'Mo110',
	'Mo111',
	'Mo112',
	'Mo113',
	'Mo114',
	'Mo115',
	'Mo116',
	'Mo117'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/moscovium.rs:4
-- elements::isotopes::moscovium::MoscoviumIsotope
CREATE TYPE MoscoviumIsotope AS ENUM (
	'Mc287',
	'Mc288',
	'Mc289',
	'Mc290',
	'Mc291'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/neodymium.rs:4
-- elements::isotopes::neodymium::NeodymiumIsotope
CREATE TYPE NeodymiumIsotope AS ENUM (
	'Nd124',
	'Nd125',
	'Nd126',
	'Nd127',
	'Nd128',
	'Nd129',
	'Nd130',
	'Nd131',
	'Nd132',
	'Nd133',
	'Nd134',
	'Nd135',
	'Nd136',
	'Nd137',
	'Nd138',
	'Nd139',
	'Nd140',
	'Nd141',
	'Nd142',
	'Nd143',
	'Nd144',
	'Nd145',
	'Nd146',
	'Nd147',
	'Nd148',
	'Nd149',
	'Nd150',
	'Nd151',
	'Nd152',
	'Nd153',
	'Nd154',
	'Nd155',
	'Nd156',
	'Nd157',
	'Nd158',
	'Nd159',
	'Nd160',
	'Nd161'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/neon.rs:4
-- elements::isotopes::neon::NeonIsotope
CREATE TYPE NeonIsotope AS ENUM (
	'Ne16',
	'Ne17',
	'Ne18',
	'Ne19',
	'Ne20',
	'Ne21',
	'Ne22',
	'Ne23',
	'Ne24',
	'Ne25',
	'Ne26',
	'Ne27',
	'Ne28',
	'Ne29',
	'Ne30',
	'Ne31',
	'Ne32',
	'Ne33',
	'Ne34'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/neptunium.rs:4
-- elements::isotopes::neptunium::NeptuniumIsotope
CREATE TYPE NeptuniumIsotope AS ENUM (
	'Np219',
	'Np220',
	'Np221',
	'Np222',
	'Np223',
	'Np224',
	'Np225',
	'Np226',
	'Np227',
	'Np228',
	'Np229',
	'Np230',
	'Np231',
	'Np232',
	'Np233',
	'Np234',
	'Np235',
	'Np236',
	'Np237',
	'Np238',
	'Np239',
	'Np240',
	'Np241',
	'Np242',
	'Np243',
	'Np244',
	'Np245'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/nickel.rs:4
-- elements::isotopes::nickel::NickelIsotope
CREATE TYPE NickelIsotope AS ENUM (
	'Ni48',
	'Ni49',
	'Ni50',
	'Ni51',
	'Ni52',
	'Ni53',
	'Ni54',
	'Ni55',
	'Ni56',
	'Ni57',
	'Ni58',
	'Ni59',
	'Ni60',
	'Ni61',
	'Ni62',
	'Ni63',
	'Ni64',
	'Ni65',
	'Ni66',
	'Ni67',
	'Ni68',
	'Ni69',
	'Ni70',
	'Ni71',
	'Ni72',
	'Ni73',
	'Ni74',
	'Ni75',
	'Ni76',
	'Ni77',
	'Ni78',
	'Ni79'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/nihonium.rs:4
-- elements::isotopes::nihonium::NihoniumIsotope
CREATE TYPE NihoniumIsotope AS ENUM (
	'Nh278',
	'Nh279',
	'Nh280',
	'Nh281',
	'Nh282',
	'Nh283',
	'Nh284',
	'Nh285',
	'Nh286',
	'Nh287'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/niobium.rs:4
-- elements::isotopes::niobium::NiobiumIsotope
CREATE TYPE NiobiumIsotope AS ENUM (
	'Nb81',
	'Nb82',
	'Nb83',
	'Nb84',
	'Nb85',
	'Nb86',
	'Nb87',
	'Nb88',
	'Nb89',
	'Nb90',
	'Nb91',
	'Nb92',
	'Nb93',
	'Nb94',
	'Nb95',
	'Nb96',
	'Nb97',
	'Nb98',
	'Nb99',
	'Nb100',
	'Nb101',
	'Nb102',
	'Nb103',
	'Nb104',
	'Nb105',
	'Nb106',
	'Nb107',
	'Nb108',
	'Nb109',
	'Nb110',
	'Nb111',
	'Nb112',
	'Nb113',
	'Nb114',
	'Nb115'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/nitrogen.rs:4
-- elements::isotopes::nitrogen::NitrogenIsotope
CREATE TYPE NitrogenIsotope AS ENUM (
	'N10',
	'N11',
	'N12',
	'N13',
	'N14',
	'N15',
	'N16',
	'N17',
	'N18',
	'N19',
	'N20',
	'N21',
	'N22',
	'N23',
	'N24',
	'N25'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/nobelium.rs:4
-- elements::isotopes::nobelium::NobeliumIsotope
CREATE TYPE NobeliumIsotope AS ENUM (
	'No248',
	'No249',
	'No250',
	'No251',
	'No252',
	'No253',
	'No254',
	'No255',
	'No256',
	'No257',
	'No258',
	'No259',
	'No260',
	'No261',
	'No262',
	'No263',
	'No264'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/oganesson.rs:4
-- elements::isotopes::oganesson::OganessonIsotope
CREATE TYPE OganessonIsotope AS ENUM (
	'Og293',
	'Og294',
	'Og295'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/osmium.rs:4
-- elements::isotopes::osmium::OsmiumIsotope
CREATE TYPE OsmiumIsotope AS ENUM (
	'Os161',
	'Os162',
	'Os163',
	'Os164',
	'Os165',
	'Os166',
	'Os167',
	'Os168',
	'Os169',
	'Os170',
	'Os171',
	'Os172',
	'Os173',
	'Os174',
	'Os175',
	'Os176',
	'Os177',
	'Os178',
	'Os179',
	'Os180',
	'Os181',
	'Os182',
	'Os183',
	'Os184',
	'Os185',
	'Os186',
	'Os187',
	'Os188',
	'Os189',
	'Os190',
	'Os191',
	'Os192',
	'Os193',
	'Os194',
	'Os195',
	'Os196',
	'Os197',
	'Os198',
	'Os199',
	'Os200',
	'Os201',
	'Os202'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/oxygen.rs:4
-- elements::isotopes::oxygen::OxygenIsotope
CREATE TYPE OxygenIsotope AS ENUM (
	'O12',
	'O13',
	'O14',
	'O15',
	'O16',
	'O17',
	'O18',
	'O19',
	'O20',
	'O21',
	'O22',
	'O23',
	'O24',
	'O25',
	'O26',
	'O27',
	'O28'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/palladium.rs:4
-- elements::isotopes::palladium::PalladiumIsotope
CREATE TYPE PalladiumIsotope AS ENUM (
	'Pd91',
	'Pd92',
	'Pd93',
	'Pd94',
	'Pd95',
	'Pd96',
	'Pd97',
	'Pd98',
	'Pd99',
	'Pd100',
	'Pd101',
	'Pd102',
	'Pd103',
	'Pd104',
	'Pd105',
	'Pd106',
	'Pd107',
	'Pd108',
	'Pd109',
	'Pd110',
	'Pd111',
	'Pd112',
	'Pd113',
	'Pd114',
	'Pd115',
	'Pd116',
	'Pd117',
	'Pd118',
	'Pd119',
	'Pd120',
	'Pd121',
	'Pd122',
	'Pd123',
	'Pd124',
	'Pd125',
	'Pd126',
	'Pd127',
	'Pd128'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/phosphorus.rs:4
-- elements::isotopes::phosphorus::PhosphorusIsotope
CREATE TYPE PhosphorusIsotope AS ENUM (
	'P24',
	'P25',
	'P26',
	'P27',
	'P28',
	'P29',
	'P30',
	'P31',
	'P32',
	'P33',
	'P34',
	'P35',
	'P36',
	'P37',
	'P38',
	'P39',
	'P40',
	'P41',
	'P42',
	'P43',
	'P44',
	'P45',
	'P46',
	'P47'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/platinum.rs:4
-- elements::isotopes::platinum::PlatinumIsotope
CREATE TYPE PlatinumIsotope AS ENUM (
	'Pt166',
	'Pt167',
	'Pt168',
	'Pt169',
	'Pt170',
	'Pt171',
	'Pt172',
	'Pt173',
	'Pt174',
	'Pt175',
	'Pt176',
	'Pt177',
	'Pt178',
	'Pt179',
	'Pt180',
	'Pt181',
	'Pt182',
	'Pt183',
	'Pt184',
	'Pt185',
	'Pt186',
	'Pt187',
	'Pt188',
	'Pt189',
	'Pt190',
	'Pt191',
	'Pt192',
	'Pt193',
	'Pt194',
	'Pt195',
	'Pt196',
	'Pt197',
	'Pt198',
	'Pt199',
	'Pt200',
	'Pt201',
	'Pt202',
	'Pt203',
	'Pt204',
	'Pt205',
	'Pt206'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/plutonium.rs:4
-- elements::isotopes::plutonium::PlutoniumIsotope
CREATE TYPE PlutoniumIsotope AS ENUM (
	'Pu228',
	'Pu229',
	'Pu230',
	'Pu231',
	'Pu232',
	'Pu233',
	'Pu234',
	'Pu235',
	'Pu236',
	'Pu237',
	'Pu238',
	'Pu239',
	'Pu240',
	'Pu241',
	'Pu242',
	'Pu243',
	'Pu244',
	'Pu245',
	'Pu246',
	'Pu247'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/polonium.rs:4
-- elements::isotopes::polonium::PoloniumIsotope
CREATE TYPE PoloniumIsotope AS ENUM (
	'Po186',
	'Po187',
	'Po188',
	'Po189',
	'Po190',
	'Po191',
	'Po192',
	'Po193',
	'Po194',
	'Po195',
	'Po196',
	'Po197',
	'Po198',
	'Po199',
	'Po200',
	'Po201',
	'Po202',
	'Po203',
	'Po204',
	'Po205',
	'Po206',
	'Po207',
	'Po208',
	'Po209',
	'Po210',
	'Po211',
	'Po212',
	'Po213',
	'Po214',
	'Po215',
	'Po216',
	'Po217',
	'Po218',
	'Po219',
	'Po220',
	'Po221',
	'Po222',
	'Po223',
	'Po224',
	'Po225',
	'Po226',
	'Po227'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/potassium.rs:4
-- elements::isotopes::potassium::PotassiumIsotope
CREATE TYPE PotassiumIsotope AS ENUM (
	'K32',
	'K33',
	'K34',
	'K35',
	'K36',
	'K37',
	'K38',
	'K39',
	'K40',
	'K41',
	'K42',
	'K43',
	'K44',
	'K45',
	'K46',
	'K47',
	'K48',
	'K49',
	'K50',
	'K51',
	'K52',
	'K53',
	'K54',
	'K55',
	'K56'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/praseodymium.rs:4
-- elements::isotopes::praseodymium::PraseodymiumIsotope
CREATE TYPE PraseodymiumIsotope AS ENUM (
	'Pr121',
	'Pr122',
	'Pr123',
	'Pr124',
	'Pr125',
	'Pr126',
	'Pr127',
	'Pr128',
	'Pr129',
	'Pr130',
	'Pr131',
	'Pr132',
	'Pr133',
	'Pr134',
	'Pr135',
	'Pr136',
	'Pr137',
	'Pr138',
	'Pr139',
	'Pr140',
	'Pr141',
	'Pr142',
	'Pr143',
	'Pr144',
	'Pr145',
	'Pr146',
	'Pr147',
	'Pr148',
	'Pr149',
	'Pr150',
	'Pr151',
	'Pr152',
	'Pr153',
	'Pr154',
	'Pr155',
	'Pr156',
	'Pr157',
	'Pr158',
	'Pr159'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/promethium.rs:4
-- elements::isotopes::promethium::PromethiumIsotope
CREATE TYPE PromethiumIsotope AS ENUM (
	'Pm126',
	'Pm127',
	'Pm128',
	'Pm129',
	'Pm130',
	'Pm131',
	'Pm132',
	'Pm133',
	'Pm134',
	'Pm135',
	'Pm136',
	'Pm137',
	'Pm138',
	'Pm139',
	'Pm140',
	'Pm141',
	'Pm142',
	'Pm143',
	'Pm144',
	'Pm145',
	'Pm146',
	'Pm147',
	'Pm148',
	'Pm149',
	'Pm150',
	'Pm151',
	'Pm152',
	'Pm153',
	'Pm154',
	'Pm155',
	'Pm156',
	'Pm157',
	'Pm158',
	'Pm159',
	'Pm160',
	'Pm161',
	'Pm162',
	'Pm163'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/protactinium.rs:4
-- elements::isotopes::protactinium::ProtactiniumIsotope
CREATE TYPE ProtactiniumIsotope AS ENUM (
	'Pa212',
	'Pa213',
	'Pa214',
	'Pa215',
	'Pa216',
	'Pa217',
	'Pa218',
	'Pa219',
	'Pa220',
	'Pa221',
	'Pa222',
	'Pa223',
	'Pa224',
	'Pa225',
	'Pa226',
	'Pa227',
	'Pa228',
	'Pa229',
	'Pa230',
	'Pa231',
	'Pa232',
	'Pa233',
	'Pa234',
	'Pa235',
	'Pa236',
	'Pa237',
	'Pa238',
	'Pa239',
	'Pa240',
	'Pa241'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/radium.rs:4
-- elements::isotopes::radium::RadiumIsotope
CREATE TYPE RadiumIsotope AS ENUM (
	'Ra201',
	'Ra202',
	'Ra203',
	'Ra204',
	'Ra205',
	'Ra206',
	'Ra207',
	'Ra208',
	'Ra209',
	'Ra210',
	'Ra211',
	'Ra212',
	'Ra213',
	'Ra214',
	'Ra215',
	'Ra216',
	'Ra217',
	'Ra218',
	'Ra219',
	'Ra220',
	'Ra221',
	'Ra222',
	'Ra223',
	'Ra224',
	'Ra225',
	'Ra226',
	'Ra227',
	'Ra228',
	'Ra229',
	'Ra230',
	'Ra231',
	'Ra232',
	'Ra233',
	'Ra234',
	'Ra235'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/radon.rs:4
-- elements::isotopes::radon::RadonIsotope
CREATE TYPE RadonIsotope AS ENUM (
	'Rn193',
	'Rn194',
	'Rn195',
	'Rn196',
	'Rn197',
	'Rn198',
	'Rn199',
	'Rn200',
	'Rn201',
	'Rn202',
	'Rn203',
	'Rn204',
	'Rn205',
	'Rn206',
	'Rn207',
	'Rn208',
	'Rn209',
	'Rn210',
	'Rn211',
	'Rn212',
	'Rn213',
	'Rn214',
	'Rn215',
	'Rn216',
	'Rn217',
	'Rn218',
	'Rn219',
	'Rn220',
	'Rn221',
	'Rn222',
	'Rn223',
	'Rn224',
	'Rn225',
	'Rn226',
	'Rn227',
	'Rn228',
	'Rn229',
	'Rn230',
	'Rn231'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/rhenium.rs:4
-- elements::isotopes::rhenium::RheniumIsotope
CREATE TYPE RheniumIsotope AS ENUM (
	'Re159',
	'Re160',
	'Re161',
	'Re162',
	'Re163',
	'Re164',
	'Re165',
	'Re166',
	'Re167',
	'Re168',
	'Re169',
	'Re170',
	'Re171',
	'Re172',
	'Re173',
	'Re174',
	'Re175',
	'Re176',
	'Re177',
	'Re178',
	'Re179',
	'Re180',
	'Re181',
	'Re182',
	'Re183',
	'Re184',
	'Re185',
	'Re186',
	'Re187',
	'Re188',
	'Re189',
	'Re190',
	'Re191',
	'Re192',
	'Re193',
	'Re194',
	'Re195',
	'Re196',
	'Re197',
	'Re198'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/rhodium.rs:4
-- elements::isotopes::rhodium::RhodiumIsotope
CREATE TYPE RhodiumIsotope AS ENUM (
	'Rh89',
	'Rh90',
	'Rh91',
	'Rh92',
	'Rh93',
	'Rh94',
	'Rh95',
	'Rh96',
	'Rh97',
	'Rh98',
	'Rh99',
	'Rh100',
	'Rh101',
	'Rh102',
	'Rh103',
	'Rh104',
	'Rh105',
	'Rh106',
	'Rh107',
	'Rh108',
	'Rh109',
	'Rh110',
	'Rh111',
	'Rh112',
	'Rh113',
	'Rh114',
	'Rh115',
	'Rh116',
	'Rh117',
	'Rh118',
	'Rh119',
	'Rh120',
	'Rh121',
	'Rh122',
	'Rh123',
	'Rh124',
	'Rh125',
	'Rh126'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/roentgenium.rs:4
-- elements::isotopes::roentgenium::RoentgeniumIsotope
CREATE TYPE RoentgeniumIsotope AS ENUM (
	'Rg272',
	'Rg273',
	'Rg274',
	'Rg275',
	'Rg276',
	'Rg277',
	'Rg278',
	'Rg279',
	'Rg280',
	'Rg281',
	'Rg282',
	'Rg283'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/rubidium.rs:4
-- elements::isotopes::rubidium::RubidiumIsotope
CREATE TYPE RubidiumIsotope AS ENUM (
	'Rb71',
	'Rb72',
	'Rb73',
	'Rb74',
	'Rb75',
	'Rb76',
	'Rb77',
	'Rb78',
	'Rb79',
	'Rb80',
	'Rb81',
	'Rb82',
	'Rb83',
	'Rb84',
	'Rb85',
	'Rb86',
	'Rb87',
	'Rb88',
	'Rb89',
	'Rb90',
	'Rb91',
	'Rb92',
	'Rb93',
	'Rb94',
	'Rb95',
	'Rb96',
	'Rb97',
	'Rb98',
	'Rb99',
	'Rb100',
	'Rb101',
	'Rb102',
	'Rb103'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/ruthenium.rs:4
-- elements::isotopes::ruthenium::RutheniumIsotope
CREATE TYPE RutheniumIsotope AS ENUM (
	'Ru87',
	'Ru88',
	'Ru89',
	'Ru90',
	'Ru91',
	'Ru92',
	'Ru93',
	'Ru94',
	'Ru95',
	'Ru96',
	'Ru97',
	'Ru98',
	'Ru99',
	'Ru100',
	'Ru101',
	'Ru102',
	'Ru103',
	'Ru104',
	'Ru105',
	'Ru106',
	'Ru107',
	'Ru108',
	'Ru109',
	'Ru110',
	'Ru111',
	'Ru112',
	'Ru113',
	'Ru114',
	'Ru115',
	'Ru116',
	'Ru117',
	'Ru118',
	'Ru119',
	'Ru120',
	'Ru121',
	'Ru122',
	'Ru123',
	'Ru124'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/rutherfordium.rs:4
-- elements::isotopes::rutherfordium::RutherfordiumIsotope
CREATE TYPE RutherfordiumIsotope AS ENUM (
	'Rf253',
	'Rf254',
	'Rf255',
	'Rf256',
	'Rf257',
	'Rf258',
	'Rf259',
	'Rf260',
	'Rf261',
	'Rf262',
	'Rf263',
	'Rf264',
	'Rf265',
	'Rf266',
	'Rf267',
	'Rf268'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/samarium.rs:4
-- elements::isotopes::samarium::SamariumIsotope
CREATE TYPE SamariumIsotope AS ENUM (
	'Sm128',
	'Sm129',
	'Sm130',
	'Sm131',
	'Sm132',
	'Sm133',
	'Sm134',
	'Sm135',
	'Sm136',
	'Sm137',
	'Sm138',
	'Sm139',
	'Sm140',
	'Sm141',
	'Sm142',
	'Sm143',
	'Sm144',
	'Sm145',
	'Sm146',
	'Sm147',
	'Sm148',
	'Sm149',
	'Sm150',
	'Sm151',
	'Sm152',
	'Sm153',
	'Sm154',
	'Sm155',
	'Sm156',
	'Sm157',
	'Sm158',
	'Sm159',
	'Sm160',
	'Sm161',
	'Sm162',
	'Sm163',
	'Sm164',
	'Sm165'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/scandium.rs:4
-- elements::isotopes::scandium::ScandiumIsotope
CREATE TYPE ScandiumIsotope AS ENUM (
	'Sc36',
	'Sc37',
	'Sc38',
	'Sc39',
	'Sc40',
	'Sc41',
	'Sc42',
	'Sc43',
	'Sc44',
	'Sc45',
	'Sc46',
	'Sc47',
	'Sc48',
	'Sc49',
	'Sc50',
	'Sc51',
	'Sc52',
	'Sc53',
	'Sc54',
	'Sc55',
	'Sc56',
	'Sc57',
	'Sc58',
	'Sc59',
	'Sc60',
	'Sc61'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/seaborgium.rs:4
-- elements::isotopes::seaborgium::SeaborgiumIsotope
CREATE TYPE SeaborgiumIsotope AS ENUM (
	'Sg258',
	'Sg259',
	'Sg260',
	'Sg261',
	'Sg262',
	'Sg263',
	'Sg264',
	'Sg265',
	'Sg266',
	'Sg267',
	'Sg268',
	'Sg269',
	'Sg270',
	'Sg271',
	'Sg272',
	'Sg273'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/selenium.rs:4
-- elements::isotopes::selenium::SeleniumIsotope
CREATE TYPE SeleniumIsotope AS ENUM (
	'Se64',
	'Se65',
	'Se66',
	'Se67',
	'Se68',
	'Se69',
	'Se70',
	'Se71',
	'Se72',
	'Se73',
	'Se74',
	'Se75',
	'Se76',
	'Se77',
	'Se78',
	'Se79',
	'Se80',
	'Se81',
	'Se82',
	'Se83',
	'Se84',
	'Se85',
	'Se86',
	'Se87',
	'Se88',
	'Se89',
	'Se90',
	'Se91',
	'Se92',
	'Se93',
	'Se94',
	'Se95'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/silicon.rs:4
-- elements::isotopes::silicon::SiliconIsotope
CREATE TYPE SiliconIsotope AS ENUM (
	'Si22',
	'Si23',
	'Si24',
	'Si25',
	'Si26',
	'Si27',
	'Si28',
	'Si29',
	'Si30',
	'Si31',
	'Si32',
	'Si33',
	'Si34',
	'Si35',
	'Si36',
	'Si37',
	'Si38',
	'Si39',
	'Si40',
	'Si41',
	'Si42',
	'Si43',
	'Si44',
	'Si45'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/silver.rs:4
-- elements::isotopes::silver::SilverIsotope
CREATE TYPE SilverIsotope AS ENUM (
	'Ag93',
	'Ag94',
	'Ag95',
	'Ag96',
	'Ag97',
	'Ag98',
	'Ag99',
	'Ag100',
	'Ag101',
	'Ag102',
	'Ag103',
	'Ag104',
	'Ag105',
	'Ag106',
	'Ag107',
	'Ag108',
	'Ag109',
	'Ag110',
	'Ag111',
	'Ag112',
	'Ag113',
	'Ag114',
	'Ag115',
	'Ag116',
	'Ag117',
	'Ag118',
	'Ag119',
	'Ag120',
	'Ag121',
	'Ag122',
	'Ag123',
	'Ag124',
	'Ag125',
	'Ag126',
	'Ag127',
	'Ag128',
	'Ag129',
	'Ag130'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/sodium.rs:4
-- elements::isotopes::sodium::SodiumIsotope
CREATE TYPE SodiumIsotope AS ENUM (
	'Na18',
	'Na19',
	'Na20',
	'Na21',
	'Na22',
	'Na23',
	'Na24',
	'Na25',
	'Na26',
	'Na27',
	'Na28',
	'Na29',
	'Na30',
	'Na31',
	'Na32',
	'Na33',
	'Na34',
	'Na35',
	'Na36',
	'Na37'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/strontium.rs:4
-- elements::isotopes::strontium::StrontiumIsotope
CREATE TYPE StrontiumIsotope AS ENUM (
	'Sr73',
	'Sr74',
	'Sr75',
	'Sr76',
	'Sr77',
	'Sr78',
	'Sr79',
	'Sr80',
	'Sr81',
	'Sr82',
	'Sr83',
	'Sr84',
	'Sr85',
	'Sr86',
	'Sr87',
	'Sr88',
	'Sr89',
	'Sr90',
	'Sr91',
	'Sr92',
	'Sr93',
	'Sr94',
	'Sr95',
	'Sr96',
	'Sr97',
	'Sr98',
	'Sr99',
	'Sr100',
	'Sr101',
	'Sr102',
	'Sr103',
	'Sr104',
	'Sr105',
	'Sr106',
	'Sr107'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/sulfur.rs:4
-- elements::isotopes::sulfur::SulfurIsotope
CREATE TYPE SulfurIsotope AS ENUM (
	'S26',
	'S27',
	'S28',
	'S29',
	'S30',
	'S31',
	'S32',
	'S33',
	'S34',
	'S35',
	'S36',
	'S37',
	'S38',
	'S39',
	'S40',
	'S41',
	'S42',
	'S43',
	'S44',
	'S45',
	'S46',
	'S47',
	'S48',
	'S49'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/tantalum.rs:4
-- elements::isotopes::tantalum::TantalumIsotope
CREATE TYPE TantalumIsotope AS ENUM (
	'Ta155',
	'Ta156',
	'Ta157',
	'Ta158',
	'Ta159',
	'Ta160',
	'Ta161',
	'Ta162',
	'Ta163',
	'Ta164',
	'Ta165',
	'Ta166',
	'Ta167',
	'Ta168',
	'Ta169',
	'Ta170',
	'Ta171',
	'Ta172',
	'Ta173',
	'Ta174',
	'Ta175',
	'Ta176',
	'Ta177',
	'Ta178',
	'Ta179',
	'Ta180',
	'Ta181',
	'Ta182',
	'Ta183',
	'Ta184',
	'Ta185',
	'Ta186',
	'Ta187',
	'Ta188',
	'Ta189',
	'Ta190',
	'Ta191',
	'Ta192'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/technetium.rs:4
-- elements::isotopes::technetium::TechnetiumIsotope
CREATE TYPE TechnetiumIsotope AS ENUM (
	'Tc85',
	'Tc86',
	'Tc87',
	'Tc88',
	'Tc89',
	'Tc90',
	'Tc91',
	'Tc92',
	'Tc93',
	'Tc94',
	'Tc95',
	'Tc96',
	'Tc97',
	'Tc98',
	'Tc99',
	'Tc100',
	'Tc101',
	'Tc102',
	'Tc103',
	'Tc104',
	'Tc105',
	'Tc106',
	'Tc107',
	'Tc108',
	'Tc109',
	'Tc110',
	'Tc111',
	'Tc112',
	'Tc113',
	'Tc114',
	'Tc115',
	'Tc116',
	'Tc117',
	'Tc118',
	'Tc119',
	'Tc120'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/tellurium.rs:4
-- elements::isotopes::tellurium::TelluriumIsotope
CREATE TYPE TelluriumIsotope AS ENUM (
	'Te105',
	'Te106',
	'Te107',
	'Te108',
	'Te109',
	'Te110',
	'Te111',
	'Te112',
	'Te113',
	'Te114',
	'Te115',
	'Te116',
	'Te117',
	'Te118',
	'Te119',
	'Te120',
	'Te121',
	'Te122',
	'Te123',
	'Te124',
	'Te125',
	'Te126',
	'Te127',
	'Te128',
	'Te129',
	'Te130',
	'Te131',
	'Te132',
	'Te133',
	'Te134',
	'Te135',
	'Te136',
	'Te137',
	'Te138',
	'Te139',
	'Te140',
	'Te141',
	'Te142',
	'Te143'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/tennessine.rs:4
-- elements::isotopes::tennessine::TennessineIsotope
CREATE TYPE TennessineIsotope AS ENUM (
	'Ts291',
	'Ts292',
	'Ts293',
	'Ts294'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/terbium.rs:4
-- elements::isotopes::terbium::TerbiumIsotope
CREATE TYPE TerbiumIsotope AS ENUM (
	'Tb135',
	'Tb136',
	'Tb137',
	'Tb138',
	'Tb139',
	'Tb140',
	'Tb141',
	'Tb142',
	'Tb143',
	'Tb144',
	'Tb145',
	'Tb146',
	'Tb147',
	'Tb148',
	'Tb149',
	'Tb150',
	'Tb151',
	'Tb152',
	'Tb153',
	'Tb154',
	'Tb155',
	'Tb156',
	'Tb157',
	'Tb158',
	'Tb159',
	'Tb160',
	'Tb161',
	'Tb162',
	'Tb163',
	'Tb164',
	'Tb165',
	'Tb166',
	'Tb167',
	'Tb168',
	'Tb169',
	'Tb170',
	'Tb171'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/thallium.rs:4
-- elements::isotopes::thallium::ThalliumIsotope
CREATE TYPE ThalliumIsotope AS ENUM (
	'Tl176',
	'Tl177',
	'Tl178',
	'Tl179',
	'Tl180',
	'Tl181',
	'Tl182',
	'Tl183',
	'Tl184',
	'Tl185',
	'Tl186',
	'Tl187',
	'Tl188',
	'Tl189',
	'Tl190',
	'Tl191',
	'Tl192',
	'Tl193',
	'Tl194',
	'Tl195',
	'Tl196',
	'Tl197',
	'Tl198',
	'Tl199',
	'Tl200',
	'Tl201',
	'Tl202',
	'Tl203',
	'Tl204',
	'Tl205',
	'Tl206',
	'Tl207',
	'Tl208',
	'Tl209',
	'Tl210',
	'Tl211',
	'Tl212',
	'Tl213',
	'Tl214',
	'Tl215',
	'Tl216',
	'Tl217',
	'Tl218'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/thorium.rs:4
-- elements::isotopes::thorium::ThoriumIsotope
CREATE TYPE ThoriumIsotope AS ENUM (
	'Th208',
	'Th209',
	'Th210',
	'Th211',
	'Th212',
	'Th213',
	'Th214',
	'Th215',
	'Th216',
	'Th217',
	'Th218',
	'Th219',
	'Th220',
	'Th221',
	'Th222',
	'Th223',
	'Th224',
	'Th225',
	'Th226',
	'Th227',
	'Th228',
	'Th229',
	'Th230',
	'Th231',
	'Th232',
	'Th233',
	'Th234',
	'Th235',
	'Th236',
	'Th237',
	'Th238',
	'Th239'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/thulium.rs:4
-- elements::isotopes::thulium::ThuliumIsotope
CREATE TYPE ThuliumIsotope AS ENUM (
	'Tm144',
	'Tm145',
	'Tm146',
	'Tm147',
	'Tm148',
	'Tm149',
	'Tm150',
	'Tm151',
	'Tm152',
	'Tm153',
	'Tm154',
	'Tm155',
	'Tm156',
	'Tm157',
	'Tm158',
	'Tm159',
	'Tm160',
	'Tm161',
	'Tm162',
	'Tm163',
	'Tm164',
	'Tm165',
	'Tm166',
	'Tm167',
	'Tm168',
	'Tm169',
	'Tm170',
	'Tm171',
	'Tm172',
	'Tm173',
	'Tm174',
	'Tm175',
	'Tm176',
	'Tm177',
	'Tm178',
	'Tm179'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/tin.rs:4
-- elements::isotopes::tin::TinIsotope
CREATE TYPE TinIsotope AS ENUM (
	'Sn99',
	'Sn100',
	'Sn101',
	'Sn102',
	'Sn103',
	'Sn104',
	'Sn105',
	'Sn106',
	'Sn107',
	'Sn108',
	'Sn109',
	'Sn110',
	'Sn111',
	'Sn112',
	'Sn113',
	'Sn114',
	'Sn115',
	'Sn116',
	'Sn117',
	'Sn118',
	'Sn119',
	'Sn120',
	'Sn121',
	'Sn122',
	'Sn123',
	'Sn124',
	'Sn125',
	'Sn126',
	'Sn127',
	'Sn128',
	'Sn129',
	'Sn130',
	'Sn131',
	'Sn132',
	'Sn133',
	'Sn134',
	'Sn135',
	'Sn136',
	'Sn137',
	'Sn138'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/titanium.rs:4
-- elements::isotopes::titanium::TitaniumIsotope
CREATE TYPE TitaniumIsotope AS ENUM (
	'Ti38',
	'Ti39',
	'Ti40',
	'Ti41',
	'Ti42',
	'Ti43',
	'Ti44',
	'Ti45',
	'Ti46',
	'Ti47',
	'Ti48',
	'Ti49',
	'Ti50',
	'Ti51',
	'Ti52',
	'Ti53',
	'Ti54',
	'Ti55',
	'Ti56',
	'Ti57',
	'Ti58',
	'Ti59',
	'Ti60',
	'Ti61',
	'Ti62',
	'Ti63'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/tungsten.rs:4
-- elements::isotopes::tungsten::TungstenIsotope
CREATE TYPE TungstenIsotope AS ENUM (
	'W157',
	'W158',
	'W159',
	'W160',
	'W161',
	'W162',
	'W163',
	'W164',
	'W165',
	'W166',
	'W167',
	'W168',
	'W169',
	'W170',
	'W171',
	'W172',
	'W173',
	'W174',
	'W175',
	'W176',
	'W177',
	'W178',
	'W179',
	'W180',
	'W181',
	'W182',
	'W183',
	'W184',
	'W185',
	'W186',
	'W187',
	'W188',
	'W189',
	'W190',
	'W191',
	'W192',
	'W193',
	'W194'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/uranium.rs:4
-- elements::isotopes::uranium::UraniumIsotope
CREATE TYPE UraniumIsotope AS ENUM (
	'U217',
	'U218',
	'U219',
	'U220',
	'U221',
	'U222',
	'U223',
	'U224',
	'U225',
	'U226',
	'U227',
	'U228',
	'U229',
	'U230',
	'U231',
	'U232',
	'U233',
	'U234',
	'U235',
	'U236',
	'U237',
	'U238',
	'U239',
	'U240',
	'U241',
	'U242',
	'U243'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/vanadium.rs:4
-- elements::isotopes::vanadium::VanadiumIsotope
CREATE TYPE VanadiumIsotope AS ENUM (
	'V40',
	'V41',
	'V42',
	'V43',
	'V44',
	'V45',
	'V46',
	'V47',
	'V48',
	'V49',
	'V50',
	'V51',
	'V52',
	'V53',
	'V54',
	'V55',
	'V56',
	'V57',
	'V58',
	'V59',
	'V60',
	'V61',
	'V62',
	'V63',
	'V64',
	'V65',
	'V66'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/xenon.rs:4
-- elements::isotopes::xenon::XenonIsotope
CREATE TYPE XenonIsotope AS ENUM (
	'Xe109',
	'Xe110',
	'Xe111',
	'Xe112',
	'Xe113',
	'Xe114',
	'Xe115',
	'Xe116',
	'Xe117',
	'Xe118',
	'Xe119',
	'Xe120',
	'Xe121',
	'Xe122',
	'Xe123',
	'Xe124',
	'Xe125',
	'Xe126',
	'Xe127',
	'Xe128',
	'Xe129',
	'Xe130',
	'Xe131',
	'Xe132',
	'Xe133',
	'Xe134',
	'Xe135',
	'Xe136',
	'Xe137',
	'Xe138',
	'Xe139',
	'Xe140',
	'Xe141',
	'Xe142',
	'Xe143',
	'Xe144',
	'Xe145',
	'Xe146',
	'Xe147',
	'Xe148'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/ytterbium.rs:4
-- elements::isotopes::ytterbium::YtterbiumIsotope
CREATE TYPE YtterbiumIsotope AS ENUM (
	'Yb148',
	'Yb149',
	'Yb150',
	'Yb151',
	'Yb152',
	'Yb153',
	'Yb154',
	'Yb155',
	'Yb156',
	'Yb157',
	'Yb158',
	'Yb159',
	'Yb160',
	'Yb161',
	'Yb162',
	'Yb163',
	'Yb164',
	'Yb165',
	'Yb166',
	'Yb167',
	'Yb168',
	'Yb169',
	'Yb170',
	'Yb171',
	'Yb172',
	'Yb173',
	'Yb174',
	'Yb175',
	'Yb176',
	'Yb177',
	'Yb178',
	'Yb179',
	'Yb180',
	'Yb181'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/yttrium.rs:4
-- elements::isotopes::yttrium::YttriumIsotope
CREATE TYPE YttriumIsotope AS ENUM (
	'Y76',
	'Y77',
	'Y78',
	'Y79',
	'Y80',
	'Y81',
	'Y82',
	'Y83',
	'Y84',
	'Y85',
	'Y86',
	'Y87',
	'Y88',
	'Y89',
	'Y90',
	'Y91',
	'Y92',
	'Y93',
	'Y94',
	'Y95',
	'Y96',
	'Y97',
	'Y98',
	'Y99',
	'Y100',
	'Y101',
	'Y102',
	'Y103',
	'Y104',
	'Y105',
	'Y106',
	'Y107',
	'Y108',
	'Y109'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/zinc.rs:4
-- elements::isotopes::zinc::ZincIsotope
CREATE TYPE ZincIsotope AS ENUM (
	'Zn54',
	'Zn55',
	'Zn56',
	'Zn57',
	'Zn58',
	'Zn59',
	'Zn60',
	'Zn61',
	'Zn62',
	'Zn63',
	'Zn64',
	'Zn65',
	'Zn66',
	'Zn67',
	'Zn68',
	'Zn69',
	'Zn70',
	'Zn71',
	'Zn72',
	'Zn73',
	'Zn74',
	'Zn75',
	'Zn76',
	'Zn77',
	'Zn78',
	'Zn79',
	'Zn80',
	'Zn81',
	'Zn82',
	'Zn83',
	'Zn84',
	'Zn85'
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/elements/src/isotopes/zirconium.rs:4
-- elements::isotopes::zirconium::ZirconiumIsotope
CREATE TYPE ZirconiumIsotope AS ENUM (
	'Zr78',
	'Zr79',
	'Zr80',
	'Zr81',
	'Zr82',
	'Zr83',
	'Zr84',
	'Zr85',
	'Zr86',
	'Zr87',
	'Zr88',
	'Zr89',
	'Zr90',
	'Zr91',
	'Zr92',
	'Zr93',
	'Zr94',
	'Zr95',
	'Zr96',
	'Zr97',
	'Zr98',
	'Zr99',
	'Zr100',
	'Zr101',
	'Zr102',
	'Zr103',
	'Zr104',
	'Zr105',
	'Zr106',
	'Zr107',
	'Zr108',
	'Zr109',
	'Zr110',
	'Zr111',
	'Zr112'
);
/* </end connected objects> */

/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/iso_codes/src/country_codes.rs:17
-- iso_codes::country_codes::CountryCode
CREATE TYPE CountryCode AS ENUM (
	'AD',
	'AE',
	'AF',
	'AG',
	'AI',
	'AL',
	'AM',
	'AO',
	'AQ',
	'AR',
	'AS',
	'AT',
	'AU',
	'AW',
	'AX',
	'AZ',
	'BA',
	'BB',
	'BD',
	'BE',
	'BF',
	'BG',
	'BH',
	'BI',
	'BJ',
	'BL',
	'BM',
	'BN',
	'BO',
	'BQ',
	'BR',
	'BS',
	'BT',
	'BV',
	'BW',
	'BY',
	'BZ',
	'CA',
	'CC',
	'CD',
	'CF',
	'CG',
	'CH',
	'CI',
	'CK',
	'CL',
	'CM',
	'CN',
	'CO',
	'CR',
	'CU',
	'CV',
	'CW',
	'CX',
	'CY',
	'CZ',
	'DE',
	'DJ',
	'DK',
	'DM',
	'DO',
	'DZ',
	'EC',
	'EE',
	'EG',
	'EH',
	'ER',
	'ES',
	'ET',
	'FI',
	'FJ',
	'FK',
	'FM',
	'FO',
	'FR',
	'GA',
	'GB',
	'GD',
	'GE',
	'GF',
	'GG',
	'GH',
	'GI',
	'GL',
	'GM',
	'GN',
	'GP',
	'GQ',
	'GR',
	'GS',
	'GT',
	'GU',
	'GW',
	'GY',
	'HK',
	'HM',
	'HN',
	'HR',
	'HT',
	'HU',
	'ID',
	'IE',
	'IL',
	'IM',
	'IN',
	'IO',
	'IQ',
	'IR',
	'IS',
	'IT',
	'JE',
	'JM',
	'JO',
	'JP',
	'KE',
	'KG',
	'KH',
	'KI',
	'KM',
	'KN',
	'KP',
	'KR',
	'KW',
	'KY',
	'KZ',
	'LA',
	'LB',
	'LC',
	'LI',
	'LK',
	'LR',
	'LS',
	'LT',
	'LU',
	'LV',
	'LY',
	'MA',
	'MC',
	'MD',
	'ME',
	'MF',
	'MG',
	'MH',
	'MK',
	'ML',
	'MM',
	'MN',
	'MO',
	'MP',
	'MQ',
	'MR',
	'MS',
	'MT',
	'MU',
	'MV',
	'MW',
	'MX',
	'MY',
	'MZ',
	'NA',
	'NC',
	'NE',
	'NF',
	'NG',
	'NI',
	'NL',
	'NO',
	'NP',
	'NR',
	'NU',
	'NZ',
	'OM',
	'PA',
	'PE',
	'PF',
	'PG',
	'PH',
	'PK',
	'PL',
	'PM',
	'PN',
	'PR',
	'PS',
	'PT',
	'PW',
	'PY',
	'QA',
	'RE',
	'RO',
	'RS',
	'RU',
	'RW',
	'SA',
	'SB',
	'SC',
	'SD',
	'SE',
	'SG',
	'SH',
	'SI',
	'SJ',
	'SK',
	'SL',
	'SM',
	'SN',
	'SO',
	'SR',
	'SS',
	'ST',
	'SV',
	'SX',
	'SY',
	'SZ',
	'TC',
	'TD',
	'TF',
	'TG',
	'TH',
	'TJ',
	'TK',
	'TL',
	'TM',
	'TN',
	'TO',
	'TR',
	'TT',
	'TV',
	'TW',
	'TZ',
	'UA',
	'UG',
	'UM',
	'US',
	'UY',
	'UZ',
	'VA',
	'VC',
	'VE',
	'VG',
	'VI',
	'VN',
	'VU',
	'WF',
	'WS',
	'YE',
	'YT',
	'ZA',
	'ZM',
	'ZW',
	'XK'
);
/* </end connected objects> */

/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::MediaType
CREATE TYPE MediaType;

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_in
CREATE  FUNCTION "mediatype_in"(
	"input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS MediaType /* core::option::Option<media_types::MediaType> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_in_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_out
CREATE  FUNCTION "mediatype_out"(
	"input" MediaType /* media_types::MediaType */
) RETURNS cstring /* alloc::ffi::c_str::CString */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_out_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_recv
CREATE  FUNCTION "mediatype_recv"(
	"internal" internal /* pgrx::datum::internal::Internal */
) RETURNS MediaType /* media_types::MediaType */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_recv_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_send
CREATE  FUNCTION "mediatype_send"(
	"input" MediaType /* media_types::MediaType */
) RETURNS bytea /* alloc::vec::Vec<u8> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_send_wrapper';


-- web/web_common/media_types/src/lib.rs:31
-- media_types::MediaType
CREATE TYPE MediaType (
	INTERNALLENGTH = variable,
	INPUT = mediatype_in, /* media_types::mediatype_in */
	OUTPUT = mediatype_out, /* media_types::mediatype_out */
	RECEIVE = mediatype_recv, /* media_types::mediatype_recv */
	SEND = mediatype_send, /* media_types::mediatype_send */
	STORAGE = extended
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_cmp
CREATE  FUNCTION "mediatype_cmp"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_cmp_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_eq
CREATE  FUNCTION "mediatype_eq"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_eq_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_eq
CREATE OPERATOR = (
	PROCEDURE="mediatype_eq",
	LEFTARG=MediaType, /* media_types::MediaType */
	RIGHTARG=MediaType, /* media_types::MediaType */
	COMMUTATOR = =,
	NEGATOR = <>,
	RESTRICT = eqsel,
	JOIN = eqjoinsel,
	HASHES,
	MERGES
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_ge
CREATE  FUNCTION "mediatype_ge"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_ge_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_ge
CREATE OPERATOR >= (
	PROCEDURE="mediatype_ge",
	LEFTARG=MediaType, /* media_types::MediaType */
	RIGHTARG=MediaType, /* media_types::MediaType */
	COMMUTATOR = <=,
	NEGATOR = <,
	RESTRICT = scalargesel,
	JOIN = scalargejoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_gt
CREATE  FUNCTION "mediatype_gt"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_gt_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_gt
CREATE OPERATOR > (
	PROCEDURE="mediatype_gt",
	LEFTARG=MediaType, /* media_types::MediaType */
	RIGHTARG=MediaType, /* media_types::MediaType */
	COMMUTATOR = <,
	NEGATOR = <=,
	RESTRICT = scalargtsel,
	JOIN = scalargtjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_hash
CREATE  FUNCTION "mediatype_hash"(
	"value" MediaType /* media_types::MediaType */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_hash_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_le
CREATE  FUNCTION "mediatype_le"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_le_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_le
CREATE OPERATOR <= (
	PROCEDURE="mediatype_le",
	LEFTARG=MediaType, /* media_types::MediaType */
	RIGHTARG=MediaType, /* media_types::MediaType */
	COMMUTATOR = >=,
	NEGATOR = >,
	RESTRICT = scalarlesel,
	JOIN = scalarlejoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_lt
CREATE  FUNCTION "mediatype_lt"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_lt_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_lt
CREATE OPERATOR < (
	PROCEDURE="mediatype_lt",
	LEFTARG=MediaType, /* media_types::MediaType */
	RIGHTARG=MediaType, /* media_types::MediaType */
	COMMUTATOR = >,
	NEGATOR = >=,
	RESTRICT = scalarltsel,
	JOIN = scalarltjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_ne
CREATE  FUNCTION "mediatype_ne"(
	"left" MediaType, /* media_types::MediaType */
	"right" MediaType /* media_types::MediaType */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'mediatype_ne_wrapper';

-- web/web_common/media_types/src/lib.rs:31
-- media_types::mediatype_ne
CREATE OPERATOR <> (
	PROCEDURE="mediatype_ne",
	LEFTARG=MediaType, /* media_types::MediaType */
	RIGHTARG=MediaType, /* media_types::MediaType */
	COMMUTATOR = <>,
	NEGATOR = =,
	RESTRICT = neqsel,
	JOIN = neqjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::MediaType
CREATE OPERATOR FAMILY MediaType_btree_ops USING btree;
CREATE OPERATOR CLASS MediaType_btree_ops DEFAULT FOR TYPE MediaType USING btree FAMILY MediaType_btree_ops AS
	OPERATOR 1 <,
	OPERATOR 2 <=,
	OPERATOR 3 =,
	OPERATOR 4 >=,
	OPERATOR 5 >,
	FUNCTION 1 mediatype_cmp(MediaType, MediaType);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/media_types/src/lib.rs:31
-- media_types::MediaType
CREATE OPERATOR FAMILY MediaType_hash_ops USING hash;
CREATE OPERATOR CLASS MediaType_hash_ops DEFAULT FOR TYPE MediaType USING hash FAMILY MediaType_hash_ops AS
	OPERATOR    1   =  (MediaType, MediaType),
	FUNCTION    1   mediatype_hash(MediaType);
/* </end connected objects> */

/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::MolecularFormula
CREATE TYPE MolecularFormula;

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_in
CREATE  FUNCTION "molecularformula_in"(
	"input" cstring /* core::option::Option<&core::ffi::c_str::CStr> */
) RETURNS MolecularFormula /* core::option::Option<molecular_formulas::molecular_formula::MolecularFormula> */
IMMUTABLE PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_in_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_out
CREATE  FUNCTION "molecularformula_out"(
	"input" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS cstring /* alloc::ffi::c_str::CString */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_out_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_recv
CREATE  FUNCTION "molecularformula_recv"(
	"internal" internal /* pgrx::datum::internal::Internal */
) RETURNS MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_recv_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_send
CREATE  FUNCTION "molecularformula_send"(
	"input" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bytea /* alloc::vec::Vec<u8> */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_send_wrapper';


-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::MolecularFormula
CREATE TYPE MolecularFormula (
	INTERNALLENGTH = variable,
	INPUT = molecularformula_in, /* molecular_formulas::molecular_formula::molecularformula_in */
	OUTPUT = molecularformula_out, /* molecular_formulas::molecular_formula::molecularformula_out */
	RECEIVE = molecularformula_recv, /* molecular_formulas::molecular_formula::molecularformula_recv */
	SEND = molecularformula_send, /* molecular_formulas::molecular_formula::molecularformula_send */
	STORAGE = extended
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_cmp
CREATE  FUNCTION "molecularformula_cmp"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_cmp_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_eq
CREATE  FUNCTION "molecularformula_eq"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_eq_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_eq
CREATE OPERATOR = (
	PROCEDURE="molecularformula_eq",
	LEFTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	RIGHTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	COMMUTATOR = =,
	NEGATOR = <>,
	RESTRICT = eqsel,
	JOIN = eqjoinsel,
	HASHES,
	MERGES
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_ge
CREATE  FUNCTION "molecularformula_ge"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_ge_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_ge
CREATE OPERATOR >= (
	PROCEDURE="molecularformula_ge",
	LEFTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	RIGHTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	COMMUTATOR = <=,
	NEGATOR = <,
	RESTRICT = scalargesel,
	JOIN = scalargejoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_gt
CREATE  FUNCTION "molecularformula_gt"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_gt_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_gt
CREATE OPERATOR > (
	PROCEDURE="molecularformula_gt",
	LEFTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	RIGHTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	COMMUTATOR = <,
	NEGATOR = <=,
	RESTRICT = scalargtsel,
	JOIN = scalargtjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_hash
CREATE  FUNCTION "molecularformula_hash"(
	"value" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS INT /* i32 */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_hash_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_le
CREATE  FUNCTION "molecularformula_le"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_le_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_le
CREATE OPERATOR <= (
	PROCEDURE="molecularformula_le",
	LEFTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	RIGHTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	COMMUTATOR = >=,
	NEGATOR = >,
	RESTRICT = scalarlesel,
	JOIN = scalarlejoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_lt
CREATE  FUNCTION "molecularformula_lt"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_lt_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_lt
CREATE OPERATOR < (
	PROCEDURE="molecularformula_lt",
	LEFTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	RIGHTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	COMMUTATOR = >,
	NEGATOR = >=,
	RESTRICT = scalarltsel,
	JOIN = scalarltjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_ne
CREATE  FUNCTION "molecularformula_ne"(
	"left" MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	"right" MolecularFormula /* molecular_formulas::molecular_formula::MolecularFormula */
) RETURNS bool /* bool */
IMMUTABLE STRICT PARALLEL SAFE
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'molecularformula_ne_wrapper';

-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::molecularformula_ne
CREATE OPERATOR <> (
	PROCEDURE="molecularformula_ne",
	LEFTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	RIGHTARG=MolecularFormula, /* molecular_formulas::molecular_formula::MolecularFormula */
	COMMUTATOR = <>,
	NEGATOR = =,
	RESTRICT = neqsel,
	JOIN = neqjoinsel
);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::MolecularFormula
CREATE OPERATOR FAMILY MolecularFormula_btree_ops USING btree;
CREATE OPERATOR CLASS MolecularFormula_btree_ops DEFAULT FOR TYPE MolecularFormula USING btree FAMILY MolecularFormula_btree_ops AS
	OPERATOR 1 <,
	OPERATOR 2 <=,
	OPERATOR 3 =,
	OPERATOR 4 >=,
	OPERATOR 5 >,
	FUNCTION 1 molecularformula_cmp(MolecularFormula, MolecularFormula);
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/molecular_formulas/src/molecular_formula.rs:38
-- molecular_formulas::molecular_formula::MolecularFormula
CREATE OPERATOR FAMILY MolecularFormula_hash_ops USING hash;
CREATE OPERATOR CLASS MolecularFormula_hash_ops DEFAULT FOR TYPE MolecularFormula USING hash FAMILY MolecularFormula_hash_ops AS
	OPERATOR    1   =  (MolecularFormula, MolecularFormula),
	FUNCTION    1   molecularformula_hash(MolecularFormula);
/* </end connected objects> */

/* <begin connected objects> */
/*
This file is auto generated by pgrx.

The ordering of items is not stable, it is driven by a dependency graph.
*/
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:40
-- pgrx_validation::str::must_be_distinct
CREATE  FUNCTION "must_be_distinct"(
	"left" TEXT, /* &str */
	"right" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_distinct_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/int.rs:68
-- pgrx_validation::int::must_be_distinct_i16
CREATE  FUNCTION "must_be_distinct_i16"(
	"left" smallint, /* i16 */
	"right" smallint /* i16 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_distinct_i16_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/int.rs:5
-- pgrx_validation::int::must_be_distinct_i32
CREATE  FUNCTION "must_be_distinct_i32"(
	"left" INT, /* i32 */
	"right" INT /* i32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_distinct_i32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/uuid.rs:5
-- pgrx_validation::uuid::must_be_distinct_uuid
CREATE  FUNCTION "must_be_distinct_uuid"(
	"left" uuid, /* rosetta_uuid::Uuid */
	"right" uuid /* rosetta_uuid::Uuid */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_distinct_uuid_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:6
-- pgrx_validation::str::must_be_email
CREATE  FUNCTION "must_be_email"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_email_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/font_awesome_icons.rs:1437
-- pgrx_validation::font_awesome_icons::must_be_font_awesome_class
CREATE  FUNCTION "must_be_font_awesome_class"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_font_awesome_class_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:47
-- pgrx_validation::float::must_be_greater_than_f32
CREATE  FUNCTION "must_be_greater_than_f32"(
	"value" real, /* f32 */
	"lower_bound" real /* f32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_greater_than_f32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:124
-- pgrx_validation::str::must_be_paragraph
CREATE  FUNCTION "must_be_paragraph"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_paragraph_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/int.rs:112
-- pgrx_validation::int::must_be_positive_i16
CREATE  FUNCTION "must_be_positive_i16"(
	"value" smallint /* i16 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_positive_i16_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/int.rs:49
-- pgrx_validation::int::must_be_positive_i32
CREATE  FUNCTION "must_be_positive_i32"(
	"value" INT /* i32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_positive_i32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:70
-- pgrx_validation::float::must_be_smaller_than_f32
CREATE  FUNCTION "must_be_smaller_than_f32"(
	"value" real, /* f32 */
	"lower_bound" real /* f32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_smaller_than_f32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/chrono.rs:5
-- pgrx_validation::chrono::must_be_smaller_than_utc
CREATE  FUNCTION "must_be_smaller_than_utc"(
	"left" timestamp with time zone, /* rosetta_timestamp::TimestampUTC */
	"right" timestamp with time zone /* rosetta_timestamp::TimestampUTC */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_smaller_than_utc_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:93
-- pgrx_validation::float::must_be_strictly_greater_than_f32
CREATE  FUNCTION "must_be_strictly_greater_than_f32"(
	"value" real, /* f32 */
	"lower_bound" real /* f32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_greater_than_f32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:139
-- pgrx_validation::float::must_be_strictly_greater_than_f64
CREATE  FUNCTION "must_be_strictly_greater_than_f64"(
	"value" double precision, /* f64 */
	"lower_bound" double precision /* f64 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_greater_than_f64_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:5
-- pgrx_validation::float::must_be_strictly_positive_f32
CREATE  FUNCTION "must_be_strictly_positive_f32"(
	"value" real /* f32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_positive_f32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:26
-- pgrx_validation::float::must_be_strictly_positive_f64
CREATE  FUNCTION "must_be_strictly_positive_f64"(
	"value" double precision /* f64 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_positive_f64_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/int.rs:91
-- pgrx_validation::int::must_be_strictly_positive_i16
CREATE  FUNCTION "must_be_strictly_positive_i16"(
	"value" smallint /* i16 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_positive_i16_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/int.rs:28
-- pgrx_validation::int::must_be_strictly_positive_i32
CREATE  FUNCTION "must_be_strictly_positive_i32"(
	"value" INT /* i32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_positive_i32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:116
-- pgrx_validation::float::must_be_strictly_smaller_than_f32
CREATE  FUNCTION "must_be_strictly_smaller_than_f32"(
	"value" real, /* f32 */
	"lower_bound" real /* f32 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_smaller_than_f32_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/float.rs:162
-- pgrx_validation::float::must_be_strictly_smaller_than_f64
CREATE  FUNCTION "must_be_strictly_smaller_than_f64"(
	"value" double precision, /* f64 */
	"lower_bound" double precision /* f64 */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_smaller_than_f64_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/chrono.rs:29
-- pgrx_validation::chrono::must_be_strictly_smaller_than_utc
CREATE  FUNCTION "must_be_strictly_smaller_than_utc"(
	"left" timestamp with time zone, /* rosetta_timestamp::TimestampUTC */
	"right" timestamp with time zone /* rosetta_timestamp::TimestampUTC */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_be_strictly_smaller_than_utc_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:26
-- pgrx_validation::str::must_not_be_empty
CREATE  FUNCTION "must_not_be_empty"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_not_be_empty_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:63
-- pgrx_validation::str::must_not_be_padded
CREATE  FUNCTION "must_not_be_padded"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_not_be_padded_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:82
-- pgrx_validation::str::must_not_contain_consecutive_whitespace
CREATE  FUNCTION "must_not_contain_consecutive_whitespace"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_not_contain_consecutive_whitespace_wrapper';
/* </end connected objects> */

/* <begin connected objects> */
-- web/web_common/pgrx_validation/src/str.rs:103
-- pgrx_validation::str::must_not_contain_control_characters
CREATE  FUNCTION "must_not_contain_control_characters"(
	"value" TEXT /* &str */
) RETURNS bool /* bool */
STRICT
LANGUAGE c /* Rust */
AS 'MODULE_PATHNAME', 'must_not_contain_control_characters_wrapper';
/* </end connected objects> */

-- Enables the extension to generate UUIDs
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
-- Purpose: Enable the pg_trgm extension.
CREATE EXTENSION IF NOT EXISTS pg_trgm;
-- Purpose: Enable the pgrx_validation extension.
CREATE EXTENSION IF NOT EXISTS pgrx_validation;
-- Enables the PostGIS extension in the database.
CREATE EXTENSION IF NOT EXISTS postgis;SET TIME ZONE 'UTC';-- Enable the `iso_codes` extension.
CREATE EXTENSION IF NOT EXISTS iso_codes;
-- Enable several of the PGRX extensions.
CREATE EXTENSION IF NOT EXISTS media_types;
CREATE EXTENSION  IF NOT EXISTS "cas_codes";
CREATE EXTENSION  IF NOT EXISTS "molecular_formulas";-- Enables the extension to log execution statistics of SQL statements
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;CREATE TABLE IF NOT EXISTS cities (
	id SERIAL PRIMARY KEY,
	name TEXT NOT NULL,
	iso CountryCode NOT NULL REFERENCES countries(iso)
);CREATE TABLE IF NOT EXISTS login_providers (
  id SMALLSERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL UNIQUE CHECK (must_be_paragraph(name)),
  icon TEXT NOT NULL CHECK (must_be_font_awesome_class(icon)),
  client_id VARCHAR(255) NOT NULL CHECK (must_be_paragraph(client_id)),
  redirect_uri VARCHAR(255) NOT NULL,
  oauth_url VARCHAR(255) NOT NULL,
  scope VARCHAR(255) NOT NULL CHECK (must_be_paragraph(scope))
);
CREATE TABLE IF NOT EXISTS addresses (
	id SERIAL PRIMARY KEY,
	city_id INTEGER NOT NULL REFERENCES cities(id),
	street_name TEXT NOT NULL,
	house_number TEXT NOT NULL,
	postal_code TEXT NOT NULL,
	geolocation GEOGRAPHY(Point, 4326) NOT NULL,
	CONSTRAINT unique_address UNIQUE (city_id, street_name, house_number)
);CREATE TABLE IF NOT EXISTS temporary_user (
    id SERIAL PRIMARY KEY,
    email text NOT NULL CHECK (must_be_email(email)),
    login_provider_id SMALLINT NOT NULL REFERENCES login_providers (id) ON DELETE CASCADE,
    UNIQUE (email, login_provider_id)
);

-- We need to create a table to store users
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    first_name TEXT NOT NULL CHECK (must_be_paragraph(first_name)),
    last_name TEXT NOT NULL CHECK (must_be_paragraph(last_name)),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CHECK (must_be_smaller_than_utc(created_at, updated_at))
);

CREATE INDEX IF NOT EXISTS idx_users_first_name_last_name 
    ON users(first_name, last_name);

-- Since users may have multiple organizations, we need a join table to represent this relationship
CREATE TABLE IF NOT EXISTS user_organizations (
    user_id INTEGER NOT NULL,
    organization_id SMALLINT NOT NULL,
    PRIMARY KEY (user_id, organization_id),
    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
    FOREIGN KEY (organization_id) REFERENCES organizations (id) ON DELETE CASCADE
);CREATE TABLE IF NOT EXISTS brands (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE CHECK (must_be_paragraph(name)),
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER NOT NULL REFERENCES users(id),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CHECK (must_be_smaller_than_utc(created_at, updated_at))
);-- SQL to create the projects table.
CREATE TABLE IF NOT EXISTS projects (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL UNIQUE CHECK (must_be_paragraph(name)),
    description TEXT NOT NULL CHECK (must_be_paragraph(description)),
    state_id SMALLINT NOT NULL DEFAULT 1,
    icon TEXT NOT NULL CHECK (must_be_font_awesome_class(icon)),
    color_id SMALLINT NOT NULL DEFAULT 1,
    parent_project_id INTEGER,
    budget REAL,
    expenses REAL,
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER NOT NULL REFERENCES users(id),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    expected_end_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE NOT NULL,
    FOREIGN KEY (state_id) REFERENCES project_states(id),
    FOREIGN KEY (color_id) REFERENCES colors(id),
    FOREIGN KEY (parent_project_id) REFERENCES projects(id) ON DELETE CASCADE,
    CHECK (must_be_distinct_i32(parent_project_id, id)),
    CHECK (must_be_distinct(name, description)),
    CHECK (must_be_smaller_than_utc(created_at, updated_at))
);
CREATE TABLE IF NOT EXISTS user_emails (
    id SERIAL PRIMARY KEY,
    email text NOT NULL UNIQUE CHECK (must_be_email(email)),
    created_by INTEGER NOT NULL REFERENCES users (id) ON DELETE CASCADE,
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    primary_email BOOLEAN NOT NULL DEFAULT TRUE,
    -- There can only be one user associated with an email address
    UNIQUE (email, created_by),
    -- There can only be one primary email address per user
    UNIQUE (created_by, primary_email)
);

CREATE TABLE IF NOT EXISTS email_providers (
    email_id INTEGER NOT NULL REFERENCES user_emails (id) ON DELETE CASCADE,
    login_provider_id SMALLINT NOT NULL REFERENCES login_providers (id) ON DELETE CASCADE,
    PRIMARY KEY (email_id, login_provider_id)
);
CREATE TABLE IF NOT EXISTS rooms (
	id SERIAL PRIMARY KEY,
	name TEXT NOT NULL  CHECK (must_be_paragraph(name)),
	description TEXT NOT NULL CHECK (must_be_paragraph(description)),
	qrcode UUID NOT NULL UNIQUE,
	addresses_id INTEGER NOT NULL REFERENCES addresses(id),
	geolocation GEOGRAPHY(POINT, 4326) NOT NULL,
	created_by INTEGER NOT NULL REFERENCES users(id),
	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	updated_by INTEGER NOT NULL REFERENCES users(id),
	updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	CHECK (must_be_smaller_than_utc(created_at, updated_at))
);CREATE TABLE IF NOT EXISTS asset_models (
    id SERIAL PRIMARY KEY,
    most_concrete_table TEXT NOT NULL,
    name VARCHAR(255) NOT NULL UNIQUE CHECK (must_be_paragraph(name)),
    description TEXT NOT NULL CHECK (must_be_paragraph(description)),
    parent_model INTEGER REFERENCES asset_models(id) ON DELETE CASCADE,
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER NOT NULL REFERENCES users(id),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CHECK (must_be_distinct(name, description)),
    CHECK (must_be_distinct_i32(id, parent_model)),
    CHECK (must_be_smaller_than_utc(created_at, updated_at)),
    UNIQUE (id, parent_model)
);
CREATE TABLE IF NOT EXISTS assets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    most_concrete_table TEXT NOT NULL,
    name VARCHAR(255) CHECK (must_be_paragraph(name)),
    description TEXT CHECK (must_be_paragraph(description)),
    model INTEGER NOT NULL REFERENCES asset_models(id) ON DELETE CASCADE,
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER NOT NULL REFERENCES users(id),
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CHECK (must_be_distinct(name, description)),
    CHECK (must_be_smaller_than_utc(created_at, updated_at)),
    UNIQUE (id, model),
    -- Assets of different models can have the same name, but not assets of the same model.
    UNIQUE (name, model)
);
CREATE TABLE IF NOT EXISTS physical_asset_models (
    id INTEGER PRIMARY KEY REFERENCES asset_models(id) ON DELETE CASCADE,
    parent_model INTEGER REFERENCES physical_asset_models(id) ON DELETE CASCADE,
    FOREIGN KEY (id, parent_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS physical_assets (
    id UUID PRIMARY KEY REFERENCES assets(id) ON DELETE CASCADE,
    model INTEGER NOT NULL REFERENCES physical_asset_models(id) ON DELETE CASCADE,
    FOREIGN KEY (id, model) REFERENCES assets(id, model)
);
CREATE TABLE IF NOT EXISTS digital_asset_models (
    id INTEGER PRIMARY KEY REFERENCES asset_models(id) ON DELETE CASCADE,
    parent_model INTEGER REFERENCES digital_asset_models(id) ON DELETE CASCADE,
    mime_type MediaType NOT NULL,
    FOREIGN KEY (id, parent_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS digital_assets (
    id UUID PRIMARY KEY REFERENCES assets(id) ON DELETE CASCADE,
    model INTEGER NOT NULL REFERENCES digital_asset_models(id) ON DELETE CASCADE,
    FOREIGN KEY (id, model) REFERENCES assets(id, model)
);
CREATE TABLE IF NOT EXISTS asset_compatibility_rules (
    left_asset_model INTEGER NOT NULL REFERENCES asset_models(id) ON DELETE CASCADE,
    right_asset_model INTEGER NOT NULL REFERENCES asset_models(id) ON DELETE CASCADE,
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (left_asset_model, right_asset_model),
    CHECK (
        must_be_distinct_i32(left_asset_model, right_asset_model)
    )
);
CREATE UNIQUE INDEX unique_asset_compatibility_pair ON asset_compatibility_rules (
    LEAST(left_asset_model, right_asset_model),
    GREATEST(left_asset_model, right_asset_model)
);
CREATE TABLE IF NOT EXISTS asset_model_ancestors (
    descendant_model INTEGER NOT NULL REFERENCES asset_models(id) ON DELETE CASCADE,
    ancestor_model INTEGER NOT NULL REFERENCES asset_models(id) ON DELETE CASCADE,
    PRIMARY KEY (descendant_model, ancestor_model)
);
-- When a new `asset_models` row is inserted, we also populate the `asset_model_ancestors` table
-- with the tautological relationship (a row is an ancestor of itself) and all the ancestors of its parent model.
CREATE OR REPLACE FUNCTION populate_asset_model_ancestors() RETURNS TRIGGER AS $$ BEGIN -- Insert the tautological relationship
INSERT INTO asset_model_ancestors (descendant_model, ancestor_model)
VALUES (NEW.id, NEW.id);
-- Insert all ancestors of the parent model
INSERT INTO asset_model_ancestors (descendant_model, ancestor_model)
SELECT NEW.id,
    ancestor_model
FROM asset_model_ancestors
WHERE descendant_model = NEW.parent_model AND NEW.parent_model IS NOT NULL;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER after_insert_asset_models
AFTER
INSERT ON asset_models FOR EACH ROW EXECUTE FUNCTION populate_asset_model_ancestors();
-- When an `asset_models` row is deleted, we also delete all its descendants.
CREATE OR REPLACE FUNCTION delete_descendant_asset_models() RETURNS TRIGGER AS $$ BEGIN
DELETE FROM asset_models
WHERE id IN (
        SELECT descendant_model
        FROM asset_model_ancestors
        WHERE ancestor_model = OLD.id
            AND descendant_model != OLD.id
    );
RETURN OLD;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER after_delete_asset_models
AFTER DELETE ON asset_models FOR EACH ROW EXECUTE FUNCTION delete_descendant_asset_models();CREATE TABLE IF NOT EXISTS teams (
    -- change to integer and the change it to serial in a new directoy
    id INTEGER PRIMARY KEY,
    -- a name of the team
    name TEXT NOT NULL UNIQUE CHECK (must_be_paragraph(name)),
    -- a description of the team
    description TEXT NOT NULL,
    icon TEXT NOT NULL CHECK (must_be_font_awesome_class(icon)),
    color_id SMALLINT NOT NULL DEFAULT 15,
    state_id SMALLINT NOT NULL DEFAULT 1,
    parent_team_id INTEGER,
    -- The user who created the team
    created_by INTEGER NOT NULL REFERENCES users(id),
    -- The date the team was created
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_by INTEGER NOT NULL REFERENCES users(id),
    -- The date the team was last updated
    updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (color_id) REFERENCES colors(id),
    FOREIGN KEY (state_id) REFERENCES team_states(id),
    FOREIGN KEY (parent_team_id) REFERENCES teams(id) ON DELETE CASCADE,
    CHECK (must_be_distinct_i32(parent_team_id, id)),
    CHECK (must_be_smaller_than_utc(created_at, updated_at))
);

CREATE TABLE IF NOT EXISTS team_members (
  team_id INTEGER NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
  member_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  PRIMARY KEY (team_id, member_id)
);

CREATE TABLE IF NOT EXISTS team_projects (
  team_id INTEGER NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
  project_id INTEGER NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
  PRIMARY KEY (team_id, project_id)
);CREATE TABLE IF NOT EXISTS photographs (
	id UUID PRIMARY KEY REFERENCES digital_assets(id)
);-- Your SQL goes here
CREATE TABLE IF NOT EXISTS spectra_collections (
    id UUID PRIMARY KEY REFERENCES digital_assets(id) ON DELETE CASCADE
);CREATE TABLE IF NOT EXISTS reagent_models (
  id INTEGER PRIMARY KEY REFERENCES asset_models(id) ON DELETE CASCADE,
  purity REAL NOT NULL CHECK (
    must_be_strictly_positive_f32(purity)
    AND must_be_smaller_than_f32(purity, 100.0)
  ),
  cas_code CAS NOT NULL UNIQUE,
  molecular_formula MolecularFormula NOT NULL
);CREATE TABLE IF NOT EXISTS container_models (
    id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id)
);
CREATE TABLE IF NOT EXISTS volumetric_container_models (
    id INTEGER PRIMARY KEY REFERENCES container_models(id),
    -- The maximum volume of the container in liters.
    liters REAL NOT NULL CHECK (must_be_strictly_positive_f32(liters))
);
CREATE TABLE IF NOT EXISTS container_compatibility_rules (
    container_model INTEGER NOT NULL REFERENCES container_models(id),
    contained_asset_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
    -- The maximal quantity of the right trackable that can be associated with the left trackable.
    quantity SMALLINT CHECK (must_be_strictly_positive_i16(quantity)),
    created_by INTEGER NOT NULL REFERENCES users(id),
    created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (container_model, contained_asset_model),
    CHECK (
        must_be_distinct_i32(container_model, contained_asset_model)
    )
);
CREATE TABLE IF NOT EXISTS containers (
    id UUID PRIMARY KEY REFERENCES physical_assets(id) ON DELETE CASCADE,
    container_model INTEGER NOT NULL REFERENCES container_models(id),
    FOREIGN KEY (id, container_model) REFERENCES assets(id, model)
);
CREATE TABLE IF NOT EXISTS volumetric_containers (
    id UUID PRIMARY KEY REFERENCES containers(id) ON DELETE CASCADE,
    volumetric_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
    -- We ensure that the parent table's container_model is indeed a volumetric_container_model.
    FOREIGN KEY (id, volumetric_container_model) REFERENCES assets(id, model)
);CREATE TABLE IF NOT EXISTS weighing_device_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS volume_measuring_device_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS positioning_device_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS camera_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS pipette_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS pipette_tip_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS phone_models (
	id INTEGER PRIMARY KEY,
	CONSTRAINT phone_models_camera FOREIGN KEY (id) REFERENCES camera_models (id) ON DELETE CASCADE,
	CONSTRAINT phone_models_positioning FOREIGN KEY (id) REFERENCES positioning_device_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS freezer_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS freeze_dryer_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS centrifuge_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS ball_mill_machine_models (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models (id) ON DELETE CASCADE
);CREATE TABLE IF NOT EXISTS procedure_templates (
	-- Identifier of the procedure template
	procedure_template SERIAL PRIMARY KEY,
	-- The most concrete table variant descendant of this procedure template,
	-- which allows for rapidly determining the type of a procedure template
	-- without having to execute multiple queries.
	most_concrete_table TEXT NOT NULL,
	-- Human-readable name of the procedure template
	name TEXT UNIQUE NOT NULL CHECK (must_be_paragraph(name)),
	-- Human-readable description of the procedure template
	description TEXT NOT NULL CHECK (must_be_paragraph(description)),
	-- The user who created this procedure template
	created_by INTEGER NOT NULL REFERENCES users(id),
	-- The timestamp when this procedure template was created
	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	-- The user who last updated this procedure template
	updated_by INTEGER NOT NULL REFERENCES users(id),
	-- The timestamp when this procedure template was last updated
	updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP CHECK (must_be_smaller_than_utc(created_at, updated_at)),
	-- Whether this procedure template is deprecated and should not be used for new procedures
	deprecated BOOLEAN NOT NULL DEFAULT FALSE,
	-- We enforce that the name and description are distinct to avoid lazy duplicates
	CHECK (must_be_distinct(name, description))
);
CREATE TABLE IF NOT EXISTS parent_procedure_templates (
	PRIMARY KEY (parent, child),
	-- The parent procedure template
	parent INTEGER NOT NULL REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The child procedure template
	child INTEGER NOT NULL REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE CHECK (must_be_distinct_i32(parent, child)),
	-- The user who created this relationship
	created_by INTEGER NOT NULL REFERENCES users(id),
	-- The timestamp when this relationship was created
	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE IF NOT EXISTS next_procedure_templates (
	PRIMARY KEY (parent, predecessor, successor),
	-- The parent procedure template
	parent INTEGER NOT NULL REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The predecessor procedure template
	predecessor INTEGER NOT NULL REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The successor procedure template
	successor INTEGER NOT NULL REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE CHECK (must_be_distinct_i32(predecessor, successor)),
	-- The user who created this relationship
	created_by INTEGER NOT NULL REFERENCES users(id),
	-- The timestamp when this relationship was created
	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	-- We enforce that the parent procedure is indeed a parent of the predecessor procedure
	FOREIGN KEY (parent, predecessor) REFERENCES parent_procedure_templates(parent, child),
	-- We enforce that the parent procedure is indeed a parent of the successor procedure
	FOREIGN KEY (parent, successor) REFERENCES parent_procedure_templates(parent, child)
);
-- Trigger function
CREATE OR REPLACE FUNCTION ensure_parent_procedure_templates() RETURNS TRIGGER LANGUAGE plpgsql AS $$ BEGIN -- Insert predecessor parent relationship if missing
INSERT INTO parent_procedure_templates (parent, child, created_by)
VALUES (NEW.parent, NEW.predecessor, NEW.created_by) ON CONFLICT (parent, child) DO NOTHING;
-- Insert successor parent relationship if missing
INSERT INTO parent_procedure_templates (parent, child, created_by)
VALUES (NEW.parent, NEW.successor, NEW.created_by) ON CONFLICT (parent, child) DO NOTHING;
RETURN NEW;
END;
$$;
-- Trigger
CREATE OR REPLACE TRIGGER before_insert_next_procedure_templates BEFORE
INSERT ON next_procedure_templates FOR EACH ROW EXECUTE FUNCTION ensure_parent_procedure_templates();
CREATE TABLE IF NOT EXISTS procedure_template_asset_models (
	-- Identifier of the procedure template asset model
	id SERIAL PRIMARY KEY,
	-- The name of the procedure template asset model
	name TEXT NOT NULL CHECK (must_be_paragraph(name)),
	-- Procedure template this asset model is associated with
	procedure_template INTEGER NOT NULL REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- Optional reference to a procedure template asset model from another procedure template
	-- which this procedure template asset model is based on
	based_on INTEGER REFERENCES procedure_template_asset_models(id),
	-- The asset model this procedure template asset model is associated with
	asset_model INTEGER NOT NULL REFERENCES asset_models(id) ON DELETE CASCADE,
	-- We enforce that, if based_on is specified, then the asset model must be the same as the one
	-- of the procedure template asset model it is based on.
	FOREIGN KEY (based_on, asset_model) REFERENCES procedure_template_asset_models(id, asset_model),
	-- The name of the procedure template asset model must be unique for a given procedure template
	-- (i.e., you cannot have two asset models with the same name for the same procedure template)
	UNIQUE (procedure_template, name),
	-- We create an index on (procedure_template, asset_model) to allow for foreign
	-- keys from the concrete procedures to check that the asset model is correctly aligned.
	UNIQUE (id, procedure_template),
	-- We create an index on (procedure_template, asset_model) to allow for foreign
	-- keys from the concrete procedures to check that the asset model is correctly aligned.
	UNIQUE (id, asset_model)
);
CREATE OR REPLACE FUNCTION inherit_procedure_template_asset_models() RETURNS TRIGGER AS $$ BEGIN
INSERT INTO procedure_template_asset_models (
		name,
		procedure_template,
		based_on,
		asset_model
	)
SELECT pam.name,
	NEW.parent,
	pam.id,
	pam.asset_model
FROM procedure_template_asset_models pam
WHERE pam.procedure_template = NEW.child;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER trg_inherit_procedure_template_asset_models
AFTER
INSERT ON parent_procedure_templates FOR EACH ROW EXECUTE FUNCTION inherit_procedure_template_asset_models();CREATE TABLE IF NOT EXISTS packaging_models (
    id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id)
);CREATE TABLE IF NOT EXISTS bead_models (
    id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id),
    diameter_millimeters REAL NOT NULL CHECK (
        must_be_strictly_positive_f32(diameter_millimeters)
    )
);CREATE TABLE IF NOT EXISTS cap_models (
    id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id)
);CREATE TABLE IF NOT EXISTS sample_source_models (
  id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id)
);
CREATE TABLE IF NOT EXISTS sample_sources (
  id UUID PRIMARY KEY REFERENCES physical_assets(id),
  model INTEGER NOT NULL REFERENCES sample_source_models(id),
  FOREIGN KEY (id, model) REFERENCES assets(id, model)
);CREATE TABLE IF NOT EXISTS spectra (
    id UUID PRIMARY KEY REFERENCES digital_assets(id) ON DELETE CASCADE,
    spectra_collection_id UUID NOT NULL REFERENCES spectra_collections(id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS procedures (
	-- The ID of this procedure.
	procedure UUID PRIMARY KEY DEFAULT gen_random_uuid(),
	-- The procedure template of this procedure.
	procedure_template INTEGER NOT NULL REFERENCES procedure_templates(procedure_template),
	-- The parent procedure (if any) of this procedure.
	parent_procedure UUID REFERENCES procedures(procedure) ON DELETE CASCADE CHECK (
		must_be_distinct_uuid(procedure, parent_procedure)
	),
	-- The parent procedure template (if any) of this procedure.
	parent_procedure_template INTEGER REFERENCES procedure_templates(procedure_template) CHECK (
		must_be_distinct_i32(procedure_template, parent_procedure_template)
	),
	-- The predecessor procedure (if any) of this procedure.
	predecessor_procedure UUID REFERENCES procedures(procedure) ON DELETE CASCADE CHECK (
		must_be_distinct_uuid(procedure, predecessor_procedure)
	),
	-- The predecessor procedure template (if any) of this procedure.
	predecessor_procedure_template INTEGER REFERENCES procedure_templates(procedure_template) CHECK (
		must_be_distinct_i32(
			procedure_template,
			predecessor_procedure_template
		)
	),
	-- The name of the most concrete table this procedure is associated with.
	most_concrete_table TEXT NOT NULL,
	-- User who created this procedure.
	created_by INTEGER NOT NULL REFERENCES users(id),
	-- Timestamp when this procedure was created.
	created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	-- User who last updated this procedure.
	updated_by INTEGER NOT NULL REFERENCES users(id),
	-- Timestamp when this procedure was last updated.
	updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
	-- We check that the created_at is before or equal to updated_at.
	CHECK (must_be_smaller_than_utc(created_at, updated_at)),
	-- We create an index on (procedure_template, parent_procedure_template) to allow for foreign
	-- keys from the concrete procedures to check that the procedure template is correctly aligned.
	UNIQUE (procedure, procedure_template),
	-- We enforce that if a parent procedure and parent procedure template are specified,
	-- then the parent procedure must indeed be of the specified parent procedure template.
	FOREIGN KEY (parent_procedure, parent_procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- We enforce that if a predecessor procedure and predecessor procedure template are specified,
	-- then the predecessor procedure must indeed be of the specified predecessor procedure template.
	FOREIGN KEY (
		predecessor_procedure,
		predecessor_procedure_template
	) REFERENCES procedures(procedure, procedure_template),
	-- We enforce that if a parent procedure template is specified, then the parent procedure template
	-- must indeed be a valid parent procedure template for the specified procedure template.
	FOREIGN KEY (parent_procedure_template, procedure_template) REFERENCES parent_procedure_templates(parent, child),
	-- We enforce that if both a predecessor procedure template and a parent procedure template are specified,
	-- then there must exist a row in `next_procedure_templates`
	FOREIGN KEY (
		parent_procedure_template,
		predecessor_procedure_template,
		procedure_template
	) REFERENCES next_procedure_templates(parent, predecessor, successor),
	-- We check that either both parent_procedure and parent_procedure_template are NULL,
	-- or neither is NULL.
	CHECK (
		(
			parent_procedure IS NULL
			AND parent_procedure_template IS NULL
		)
		OR (
			parent_procedure IS NOT NULL
			AND parent_procedure_template IS NOT NULL
		)
	),
	-- We check that either both predecessor_procedure and predecessor_procedure_template are NULL,
	-- or neither is NULL.
	CHECK (
		(
			predecessor_procedure IS NULL
			AND predecessor_procedure_template IS NULL
		)
		OR (
			predecessor_procedure IS NOT NULL
			AND predecessor_procedure_template IS NOT NULL
		)
	),
	-- We check that if the previous procedure is specified, then the parent procedure must also be specified.
	CHECK (
		(predecessor_procedure IS NULL)
		OR (parent_procedure IS NOT NULL)
	)
);
CREATE TABLE IF NOT EXISTS procedure_assets (
	-- The ID of this procedure asset.
	id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
	-- The ID of the procedure this asset is used in.
	procedure UUID NOT NULL REFERENCES procedures(procedure),
	-- The procedure template of the procedure this asset is used in.
	procedure_template INTEGER NOT NULL REFERENCES procedure_templates(procedure_template),
	-- The asset model of the asset used in this procedure.
	asset_model INTEGER NOT NULL REFERENCES asset_models(id),
	-- The specific asset used in this procedure (if any).
	asset UUID REFERENCES assets(id),
	-- We enforce that there must be a procedure template asset for this asset.
	procedure_template_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The ancestor asset model defined in the procedure template asset.
	ancestor_model INTEGER NOT NULL REFERENCES asset_models(id),
	-- The procedure template must match the procedure template of the procedure.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The procedure template asset must must be compatible with the procedure template of the procedure.
	FOREIGN KEY (
		procedure_template_asset_model,
		procedure_template
	) REFERENCES procedure_template_asset_models(id, procedure_template),
	-- We check that the ancestor asset is indeed the one defined in the procedure template asset.
	FOREIGN KEY (
		procedure_template_asset_model,
		ancestor_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the asset is indeed a descendant of the ancestor asset defined in the procedure template asset.
	FOREIGN KEY (asset_model, ancestor_model) REFERENCES asset_model_ancestors(descendant_model, ancestor_model),
	-- We check that the specified asset (if any) is indeed of the specified asset model.
	FOREIGN KEY (asset, asset_model) REFERENCES assets(id, model),
	-- We create a unique index to allow for foreign keys checking that the current procedure asset
	-- corresponds to a specific procedure template asset model in the procedure template.
	UNIQUE (id, procedure_template_asset_model),
	-- We create a unique index to allow for foreign keys checking that the current procedure asset
	-- corresponds to a specific asset model.
	UNIQUE (id, asset_model),
	-- We create a unique index to allow for foreign keys checking that the current procedure asset
	-- corresponds to a specific asset (if any).
	UNIQUE (id, asset)
);
-- When we insert a procedure assets, the parent procedure if any
-- must also receive its own version of the procedure asset. The
-- parent procedure's procedure asset will reference many of the
-- same fields, but the `procedure_template_asset_model` will be
-- the one defined in the parent procedure template which is characterized
-- by being `based_on` the current procedure template asset model.
CREATE OR REPLACE FUNCTION inherit_procedure_assets() RETURNS TRIGGER AS $$ BEGIN
INSERT INTO procedure_assets (
		procedure,
		procedure_template,
		asset_model,
		asset,
		procedure_template_asset_model,
		ancestor_model
	)
SELECT p.parent_procedure,
	p.parent_procedure_template,
	NEW.asset_model,
	NEW.asset,
	ptam.id,
	NEW.ancestor_model
FROM procedures p
	JOIN procedure_template_asset_models ptam ON ptam.based_on = NEW.procedure_template_asset_model
	AND ptam.procedure_template = p.parent_procedure_template
WHERE p.procedure = NEW.procedure
	AND p.parent_procedure IS NOT NULL;
RETURN NEW;
END;
$$ LANGUAGE plpgsql;
CREATE OR REPLACE TRIGGER trg_inherit_procedure_assets
AFTER
INSERT ON procedure_assets FOR EACH ROW EXECUTE FUNCTION inherit_procedure_assets();CREATE TABLE IF NOT EXISTS commercial_products (
	id INTEGER PRIMARY KEY REFERENCES asset_models(id),
	deprecation_date TIMESTAMP WITH TIME ZONE,
	brand_id INTEGER NOT NULL REFERENCES brands(id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS commercial_weighing_device_models (
	id INTEGER PRIMARY KEY,
	weighing_device_model INTEGER NOT NULL REFERENCES weighing_device_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES weighing_device_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, weighing_device_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_volume_measuring_device_models (
	id INTEGER PRIMARY KEY,
	volume_measuring_device_model INTEGER NOT NULL REFERENCES volume_measuring_device_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES volume_measuring_device_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, volume_measuring_device_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_pipette_models (
	id INTEGER PRIMARY KEY,
	pipette_model INTEGER NOT NULL REFERENCES pipette_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES pipette_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, pipette_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_pipette_tip_models (
	id INTEGER PRIMARY KEY,
	pipette_tip_model INTEGER NOT NULL REFERENCES pipette_tip_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES pipette_tip_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, pipette_tip_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_packaging_models (
	id INTEGER PRIMARY KEY,
	packaging_model INTEGER NOT NULL REFERENCES packaging_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES packaging_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, packaging_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_bead_models (
	id INTEGER PRIMARY KEY,
	bead_model INTEGER NOT NULL REFERENCES bead_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES bead_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, bead_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_cap_models (
	id INTEGER PRIMARY KEY,
	cap_model INTEGER NOT NULL REFERENCES cap_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES cap_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, cap_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_ball_mill_machine_models (
	id INTEGER PRIMARY KEY,
	ball_mill_machine_model INTEGER NOT NULL REFERENCES ball_mill_machine_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES ball_mill_machine_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, ball_mill_machine_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_centrifuge_models (
	id INTEGER PRIMARY KEY,
	centrifuge_model INTEGER NOT NULL REFERENCES centrifuge_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES centrifuge_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, centrifuge_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_freezer_models (
	id INTEGER PRIMARY KEY,
	freezer_model INTEGER NOT NULL REFERENCES freezer_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES freezer_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, freezer_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_freeze_dryer_models (
	id INTEGER PRIMARY KEY,
	freeze_dryer_model INTEGER NOT NULL REFERENCES freeze_dryer_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES freeze_dryer_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, freeze_dryer_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_positioning_device_models (
	id INTEGER PRIMARY KEY,
	positioning_device_model INTEGER NOT NULL REFERENCES positioning_device_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES positioning_device_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, positioning_device_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_camera_models (
	id INTEGER PRIMARY KEY,
	camera_model INTEGER NOT NULL REFERENCES camera_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES camera_models(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES commercial_products(id) ON DELETE CASCADE,
	FOREIGN KEY (id, camera_model) REFERENCES asset_models(id, parent_model)
);CREATE TABLE IF NOT EXISTS organism_models (
  id INTEGER PRIMARY KEY REFERENCES sample_source_models(id)
);
CREATE TABLE IF NOT EXISTS organisms (
  id UUID PRIMARY KEY REFERENCES sample_sources(id),
  model INTEGER NOT NULL REFERENCES organism_models(id),
  FOREIGN KEY (id, model) REFERENCES assets(id, model)
);CREATE TABLE IF NOT EXISTS sample_models (
  id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id),
  sample_source_model INTEGER NOT NULL REFERENCES sample_source_models(id),
	-- We create a unique index to allow for foreign keys checking that there exist a `sample_source_model`
	-- for the current `sample_model`.
  UNIQUE (id, sample_source_model)
);

CREATE TABLE IF NOT EXISTS samples (
  id UUID PRIMARY KEY REFERENCES physical_assets(id),
  model INTEGER NOT NULL REFERENCES sample_models(id),
  sample_source UUID REFERENCES sample_sources(id),
  sample_source_model INTEGER NOT NULL REFERENCES sample_source_models(id),
  FOREIGN KEY (id, model) REFERENCES assets(id, model),
  FOREIGN KEY (model, sample_source_model) REFERENCES sample_models(id, sample_source_model),
  FOREIGN KEY (sample_source, sample_source_model) REFERENCES assets(id, model)
);CREATE TABLE IF NOT EXISTS storage_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The storage temperature in Kelvin.
	kelvin REAL NOT NULL DEFAULT 293.15 CHECK (must_be_strictly_positive_f32(kelvin)),
	-- Tolerance percentage for the storage temperature.
	kelvin_tolerance_percentage REAL NOT NULL DEFAULT 1.0 CHECK (
		must_be_strictly_positive_f32(kelvin_tolerance_percentage)
		AND must_be_smaller_than_f32(kelvin_tolerance_percentage, 100.0)
	),
	-- The container that will be used for storage.
	stored_into_model INTEGER NOT NULL REFERENCES container_models(id),
	procedure_template_stored_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The asset that is being stored.
	stored_asset_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	procedure_template_stored_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- We check that the `stored_into_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_stored_into_model,
		stored_into_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `stored_asset_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_stored_asset_model,
		stored_asset_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `stored_into_model` is indeed a container that can hold the `stored_asset_model`.
	FOREIGN KEY (stored_into_model, stored_asset_model) REFERENCES container_compatibility_rules(container_model, contained_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_stored_into_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_stored_into_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_stored_asset_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_stored_asset_model
	)
);
CREATE TABLE IF NOT EXISTS storage_procedures (
	-- Identifier of the storage procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a storage procedure template.
	procedure_template INTEGER NOT NULL REFERENCES storage_procedure_templates(procedure_template),
	-- The asset being stored, which must be a physical asset.
	stored_asset UUID NOT NULL REFERENCES physical_assets(id),
	-- The model of the asset being stored, which must be a physical asset model.
	stored_asset_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	-- The procedure template asset model describing the `stored_asset`.
	procedure_template_stored_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset describing the `stored_asset`.
	procedure_stored_asset UUID NOT NULL REFERENCES procedure_assets(id),
	-- The container into which the asset is being stored.
	stored_into UUID NOT NULL REFERENCES containers(id),
	-- The model of the container into which the asset is being stored.
	stored_into_model INTEGER NOT NULL REFERENCES container_models(id),
	-- The procedure template asset model describing the `stored_into`.
	procedure_template_stored_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset describing the `stored_into`.
	procedure_stored_into UUID NOT NULL REFERENCES procedure_assets(id),
	-- The current procedure must be a storage procedure.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The procedure template asset model describing the `stored_asset` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_stored_asset_model
	) REFERENCES storage_procedure_templates(
		procedure_template,
		procedure_template_stored_asset_model
	),
	-- The procedure template asset model describing the `stored_into` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_stored_into_model
	) REFERENCES storage_procedure_templates(
		procedure_template,
		procedure_template_stored_into_model
	),
	-- The procedure template asset model and the procedure asset describing the `stored_asset`
	-- must be compatible.
	FOREIGN KEY (
		procedure_stored_asset,
		procedure_template_stored_asset_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- The procedure template asset model and the procedure asset describing the `stored_into`
	-- must be compatible.
	FOREIGN KEY (
		procedure_stored_into,
		procedure_template_stored_into_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- Check the compatibility between the `stored_asset` and the `stored_into_model`.
	FOREIGN KEY (stored_into_model, stored_asset_model) REFERENCES container_compatibility_rules(container_model, contained_asset_model),
	-- We check that the `procedure_stored_asset` is associated to the `stored_asset_model`.
	FOREIGN KEY (procedure_stored_asset, stored_asset_model) REFERENCES procedure_assets(id, asset_model),
	-- We check that the `procedure_stored_into` is associated to the `stored_into_model`.
	FOREIGN KEY (procedure_stored_into, stored_into_model) REFERENCES procedure_assets(id, asset_model),
	-- We check that the `procedure_stored_asset` is associated to the `stored_asset`.
	FOREIGN KEY (procedure_stored_asset, stored_asset) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_stored_into` is associated to the `stored_into`.
	FOREIGN KEY (procedure_stored_into, stored_into) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS capping_procedure_templates (
	-- Identifier of the capping procedure template, which is also a foreign key to the general procedure template.
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The container to be capped.
	capped_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The procedure template associated with the container model.
	procedure_template_capped_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The cap to be used for the container.
	capped_with_model INTEGER NOT NULL REFERENCES cap_models(id),
	-- The procedure template associated with the cap model.
	procedure_template_capped_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- We check that the `container_model` is indeed the trackable that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_capped_container_model,
		capped_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `capped_with_model` is indeed a trackable that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_capped_with_model,
		capped_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `capped_with_model` is indeed a cap that can be used with the `capped_container_model`.
	FOREIGN KEY (capped_container_model, capped_with_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_capped_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_capped_container_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_capped_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_capped_with_model
	)
);
CREATE TABLE IF NOT EXISTS capping_procedures (
	-- Identifier of the capping procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- We enforce that the model of this procedure must be a capping procedure template.
	procedure_template INTEGER NOT NULL REFERENCES capping_procedure_templates(procedure_template),
	-- The container being capped, which must be a volumetric container.
	capped_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The model of the container being capped.
	capped_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The procedure template asset model describing the `capped_container`.
	procedure_template_capped_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset describing the `capped_container`.
	procedure_capped_container UUID NOT NULL REFERENCES procedure_assets(id),
	-- The cap being used, which must be a cap model.
	capped_with_model INTEGER NOT NULL REFERENCES cap_models(id),
	-- The procedure template asset model describing the `capped_with_model`.
	procedure_template_capped_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset describing the `capped_with_model`.
	procedure_capped_with UUID NOT NULL REFERENCES procedure_assets(id),
	-- The current procedure must be a capping procedure.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The procedure template asset model describing the `capped_container` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_capped_container_model
	) REFERENCES capping_procedure_templates(
		procedure_template,
		procedure_template_capped_container_model
	),
	-- The procedure template asset model describing the `capped_with_model` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_capped_with_model
	) REFERENCES capping_procedure_templates(
		procedure_template,
		procedure_template_capped_with_model
	),
	-- The procedure template asset model and the procedure asset describing the `capped_container`
	-- must be compatible.
	FOREIGN KEY (
		procedure_capped_container,
		procedure_template_capped_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- The procedure template asset model and the procedure asset describing the `capped_with_model`
	-- must be compatible.
	FOREIGN KEY (
		procedure_capped_with,
		procedure_template_capped_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We ensure that the `procedure_capped_container` is associated with the `capped_container_model`.
	FOREIGN KEY (
		procedure_capped_container,
		capped_container_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We ensure that the `procedure_capped_with` is associated with the `capped_with_model`.
	FOREIGN KEY (procedure_capped_with, capped_with_model) REFERENCES procedure_assets(id, asset_model),
	-- We ensure that the `procedure_capped_container` is associated with the `capped_container`.
	FOREIGN KEY (procedure_capped_container, capped_container) REFERENCES procedure_assets(id, asset),
	-- We check that the `capped_container_model` is compatible with the `capped_with_model`.
	FOREIGN KEY (capped_container_model, capped_with_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model)
);CREATE TABLE IF NOT EXISTS disposal_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The disposed asset asset model being disposed of.
	disposed_asset_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	-- The associated procedure asset model for the disposed asset.
	procedure_template_disposed_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The disposed asset model must match the procedure template of the procedure.
	FOREIGN KEY (
		procedure_template_disposed_asset_model,
		disposed_asset_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_disposed_asset_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_disposed_asset_model
	)
);
CREATE TABLE IF NOT EXISTS disposal_procedures (
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The model of the procedure.
	procedure_template INTEGER NOT NULL REFERENCES disposal_procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The disposed asset is the one that is being disposed_asset of.
	disposed_asset UUID REFERENCES physical_assets(id),
	-- The procedure template asset model associated to the `disposed_asset`.
	procedure_template_disposed_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `disposed_asset`.
	procedure_disposed_asset UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We ensure that the parent table's procedure_template is indeed a disposal_procedure_template.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The procedure template asset model describing the `disposed_asset` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_disposed_asset_model
	) REFERENCES disposal_procedure_templates(
		procedure_template,
		procedure_template_disposed_asset_model
	),
	-- We enforce that the `procedure_disposed_asset` is associated with the `procedure_template_disposed_asset_model`.
	FOREIGN KEY (
		procedure_disposed_asset,
		procedure_template_disposed_asset_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the `procedure_disposed_asset` is associated with the `disposed_asset`.
	FOREIGN KEY (procedure_disposed_asset, disposed_asset) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS packaging_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	packaged_with_model INTEGER NOT NULL REFERENCES packaging_models(id),
	procedure_template_packaged_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	sample_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	procedure_template_sample_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- We check that the `packaged_with_model` is indeed an asset model that is compatible with the procedure template asset model.
	FOREIGN KEY (
		procedure_template_packaged_with_model,
		packaged_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `sample_model` is indeed an asset model that is compatible with the procedure template asset model.
	FOREIGN KEY (
		procedure_template_sample_model,
		sample_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- The `sample_model` must be compatible with the `packaged_with_model`.
	FOREIGN KEY (packaged_with_model, sample_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_packaged_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_packaged_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_sample_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_sample_model
	)
);
CREATE TABLE IF NOT EXISTS packaging_procedures (
	-- The extended `procedure`.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The procedure template of the extended `procedure`.
	procedure_template INTEGER NOT NULL REFERENCES packaging_procedure_templates(procedure_template),
	-- The sample being packaged, which must be a physical asset.
	sample UUID NOT NULL REFERENCES physical_assets(id),
	-- The model of the sample being packaged, which must be a physical asset model.
	sample_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	-- The procedure template asset model associated to the `sample`.
	procedure_template_sample_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `sample`.
	procedure_sample UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The packaging used for packaging, which must be a packaging model.
	packaged_with_model INTEGER NOT NULL REFERENCES packaging_models(id),
	-- The procedure template asset model associated to the `packaged_with_model`.
	procedure_template_packaged_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `packaged_with_model`.
	procedure_packaged_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is a packaging procedure.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_packaged_with_model` must be the same as in the `packaging_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_packaged_with_model
	) REFERENCES packaging_procedure_templates(
		procedure_template,
		procedure_template_packaged_with_model
	),
	-- The `procedure_template_sample_model` must be the same as in the `packaging_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_sample_model
	) REFERENCES packaging_procedure_templates(
		procedure_template,
		procedure_template_sample_model
	),
	-- We check that the `procedure_sample` is associated to the `sample`.
	FOREIGN KEY (procedure_sample, sample) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_packaged_with` is associated to the `packaged_with_model`.
	FOREIGN KEY (procedure_packaged_with, packaged_with_model) REFERENCES procedure_assets(id, asset_model),
	-- We check that the `procedure_sample` is indeed associated to the `procedure_template_sample_model`.
	FOREIGN KEY (
		procedure_sample,
		procedure_template_sample_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_packaged_with` is indeed associated to the `procedure_template_packaged_with_model`.
	FOREIGN KEY (
		procedure_packaged_with,
		procedure_template_packaged_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `sample` is indeed compatible with the `packaged_with_model`.
	FOREIGN KEY (packaged_with_model, sample_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We check that the `procedure_sample` is associated to the `sample_model`.
	FOREIGN KEY (procedure_sample, sample_model) REFERENCES procedure_assets(id, asset_model)
);CREATE TABLE IF NOT EXISTS commercial_product_lots (
	id INTEGER PRIMARY KEY REFERENCES physical_asset_models(id) ON DELETE CASCADE,
	lot TEXT NOT NULL,
	product_model INTEGER NOT NULL REFERENCES commercial_products(id) ON DELETE CASCADE,
	-- A lot must be unique within the scope of a product model.
	UNIQUE (lot, product_model),
	-- The parent product model must be a commercial product.
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_weighing_device_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES weighing_device_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_weighing_device_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_volume_measuring_device_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES volume_measuring_device_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_volume_measuring_device_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_pipette_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES pipette_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_pipette_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_pipette_tip_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES pipette_tip_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_pipette_tip_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_packaging_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES packaging_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_packaging_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_bead_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES bead_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_bead_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_cap_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES cap_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_cap_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_ball_mill_machine_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES ball_mill_machine_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_ball_mill_machine_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_centrifuge_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES centrifuge_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_centrifuge_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_freezer_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES freezer_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_freezer_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_freeze_dryer_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES freeze_dryer_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_freeze_dryer_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_positioning_device_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES positioning_device_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_positioning_device_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);
CREATE TABLE IF NOT EXISTS commercial_camera_lots (
	id INTEGER PRIMARY KEY,
	FOREIGN KEY (id) REFERENCES commercial_product_lots(id) ON DELETE CASCADE,
	FOREIGN KEY (id) REFERENCES camera_models(id) ON DELETE CASCADE,
	product_model INTEGER NOT NULL REFERENCES commercial_camera_models(id),
	FOREIGN KEY (id, product_model) REFERENCES asset_models(id, parent_model)
);-- Your SQL goes here
-- A migration to create the organism_taxa table.
-- This is a N to M relationship between organisms and taxa.
-- An organism can be associated to no or more taxa, and a taxon can be found in multiple organisms.
--
CREATE TABLE IF NOT EXISTS organism_taxa (
  created_by INTEGER NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT CURRENT_TIMESTAMP,
  organism_id UUID NOT NULL,
  taxon_id INTEGER NOT NULL,
  PRIMARY KEY (organism_id, taxon_id),
  FOREIGN KEY (created_by) REFERENCES users(id),
  FOREIGN KEY (organism_id) REFERENCES organisms(id) ON DELETE CASCADE,
  FOREIGN KEY (taxon_id) REFERENCES taxa(id)
);CREATE TABLE IF NOT EXISTS weighing_devices (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_weighing_device_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS volume_measuring_devices (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_volume_measuring_device_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS pipettes (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_pipette_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS ball_mill_machines (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_ball_mill_machine_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS centrifuges (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_centrifuge_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS freezers (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_freezer_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS freeze_dryers (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_freeze_dryer_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS positioning_devices (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_positioning_device_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);
CREATE TABLE IF NOT EXISTS cameras (
	id UUID PRIMARY KEY REFERENCES physical_assets (id) ON DELETE CASCADE,
	model INTEGER NOT NULL REFERENCES commercial_camera_lots (id),
	FOREIGN KEY (id, model) REFERENCES assets (id, model)
);CREATE TABLE IF NOT EXISTS photograph_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The device used for photograph.
	photographed_with_model INTEGER NOT NULL REFERENCES camera_models(id),
	procedure_template_photographed_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	photographed_asset_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	procedure_template_photographed_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	photograph_model INTEGER NOT NULL REFERENCES digital_asset_models(id),
	procedure_template_photograph_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- We check that the `photographed_with_model` is indeed a trackable that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_photographed_with_model,
		photographed_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_photographed_asset_model,
		photographed_asset_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_photograph_model,
		photograph_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_photographed_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_photographed_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_photographed_asset_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_photographed_asset_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_photograph_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_photograph_model
	)
);
CREATE TABLE IF NOT EXISTS photograph_procedures (
	-- Identifier of the photograph procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a photograph procedure template.
	procedure_template INTEGER NOT NULL REFERENCES photograph_procedure_templates(procedure_template),
	-- The asset being photographed, which must be a physical asset.
	photographed_asset UUID REFERENCES physical_assets(id),
	-- The procedure template asset model associated to the `photographed_asset`.
	procedure_template_photographed_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `photographed_asset`.
	procedure_photographed_asset UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The positioning device used for photograph. This field is optional, as the positioning device might not necessarily be tracked.
	photographed_with UUID REFERENCES cameras(id),
	-- The procedure template asset model associated to the `photographed_with_model`.
	procedure_template_photographed_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `photographed_with`.
	procedure_photographed_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The resulting photograph.
	photograph UUID NOT NULL REFERENCES photographs(id) ON DELETE CASCADE,
	-- The procedure template asset model associated to the `photograph_model`.
	procedure_template_photograph_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `photograph`.
	procedure_photograph UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the current `photograph` has indeed the same `photograph_template`.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_photographed_with_model` must be the same as in the `photograph_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_photographed_with_model
	) REFERENCES photograph_procedure_templates(
		procedure_template,
		procedure_template_photographed_with_model
	),
	-- The `procedure_template_photographed_asset_model` must be the same as in the `photograph_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_photographed_asset_model
	) REFERENCES photograph_procedure_templates(
		procedure_template,
		procedure_template_photographed_asset_model
	),
	-- The `procedure_template_photograph_model` must be the same as in the `photograph_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_photograph_model
	) REFERENCES photograph_procedure_templates(
		procedure_template,
		procedure_template_photograph_model
	),
	-- We check that the `procedure_photographed_with` is associated to the same `procedure_template_photographed_with_model`.
	FOREIGN KEY (
		procedure_photographed_with,
		procedure_template_photographed_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_photographed_asset` is associated to the same `procedure_template_photographed_asset_model`.
	FOREIGN KEY (
		procedure_photographed_asset,
		procedure_template_photographed_asset_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_photograph` is associated to the same `procedure_template_photograph_model`.
	FOREIGN KEY (
		procedure_photograph,
		procedure_template_photograph_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_photographed_asset` is associated to the `photographed_asset`.
	FOREIGN KEY (procedure_photographed_asset, photographed_asset) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_photographed_with` is associated to the `photographed_with`.
	FOREIGN KEY (procedure_photographed_with, photographed_with) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_photograph` is associated to the `photograph`.
	FOREIGN KEY (procedure_photograph, photograph) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS geolocation_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The device used for geolocation.
	geolocated_with_model INTEGER NOT NULL REFERENCES positioning_device_models(id),
	procedure_template_geolocated_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	geolocated_asset_model INTEGER NOT NULL REFERENCES physical_asset_models(id),
	procedure_template_geolocated_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- We check that the `geolocated_with_model` is indeed an asset model that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_geolocated_with_model,
		geolocated_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the asset model is indeed a procedure asset model.
	FOREIGN KEY (
		procedure_template_geolocated_asset_model,
		geolocated_asset_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_geolocated_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_geolocated_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_geolocated_asset_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_geolocated_asset_model
	)
);
CREATE TABLE IF NOT EXISTS geolocation_procedures (
	-- Identifier of the geolocation procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a geolocation procedure template.
	procedure_template INTEGER NOT NULL REFERENCES geolocation_procedure_templates(procedure_template),
	-- The asset being geolocated, which must be a physical asset.
	geolocated_asset UUID NOT NULL REFERENCES physical_assets(id),
	-- The procedure template asset model associated to the `geolocated_asset`.
	procedure_template_geolocated_asset_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `geolocated_asset`.
	procedure_geolocated_asset UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The positioning device used for geolocation. This field is optional, as the positioning device might not necessarily be tracked.
	geolocated_with UUID REFERENCES positioning_devices(id),
	-- The procedure asset associated to the `geolocated_with`.
	procedure_geolocated_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The procedure template asset model associated to the `geolocated_with_model`.
	procedure_template_geolocated_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The latitude and longitude of the geolocation.
	location GEOGRAPHY(POINT, 4326) NOT NULL,
	-- We enforce that the current `geolocation` has indeed the same `geolocation_template`.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_geolocated_with_model` must be the same as in the `geolocation_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_geolocated_with_model
	) REFERENCES geolocation_procedure_templates(
		procedure_template,
		procedure_template_geolocated_with_model
	),
	-- The `procedure_template_geolocated_asset_model` must be the same as in the `geolocation_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_geolocated_asset_model
	) REFERENCES geolocation_procedure_templates(
		procedure_template,
		procedure_template_geolocated_asset_model
	),
	-- We check that the `procedure_geolocated_asset` has the same `procedure_template_geolocated_asset_model`.
	FOREIGN KEY (
		procedure_geolocated_asset,
		procedure_template_geolocated_asset_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_geolocated_with` has the same `procedure_template_geolocated_with_model`.
	FOREIGN KEY (
		procedure_geolocated_with,
		procedure_template_geolocated_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_geolocated_asset` is associated to the `geolocated_asset`.
	FOREIGN KEY (procedure_geolocated_asset, geolocated_asset) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_geolocated_with` is associated to the `geolocated_with`.
	FOREIGN KEY (procedure_geolocated_with, geolocated_with) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS freeze_drying_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The storage temperature in Kelvin.
	kelvin REAL NOT NULL DEFAULT 203.15 CHECK (must_be_strictly_positive_f32(kelvin)),
	-- Tolerance percentage for the storage temperature.
	kelvin_tolerance_percentage REAL NOT NULL DEFAULT 5.0 CHECK (
		must_be_strictly_positive_f32(kelvin_tolerance_percentage)
		AND must_be_smaller_than_f32(kelvin_tolerance_percentage, 100.0)
	),
	-- We use a default of 4 Pa for the pressure in the freeze-drying chamber.
	pascal REAL NOT NULL DEFAULT 4.0 CHECK (
		must_be_strictly_positive_f32(pascal)
		AND must_be_smaller_than_f32(pascal, 500.0)
	),
	-- We use a default of 3 days (259200 seconds) for the freeze-drying procedure.
	seconds REAL NOT NULL DEFAULT 259200.0 CHECK (
		must_be_strictly_greater_than_f32(seconds, 7200.0)
		AND must_be_strictly_smaller_than_f32(seconds, 604800.0)
	),
	-- The device used for the freeze drying procedure.
	freeze_dried_with_model INTEGER NOT NULL REFERENCES freeze_dryer_models(id),
	procedure_template_freeze_dried_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The container that is being freeze_dried.
	freeze_dried_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_freeze_dried_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- We check that the `freeze_dried_with_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_freeze_dried_with_model,
		freeze_dried_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `freeze_dried_container_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_freeze_dried_container_model,
		freeze_dried_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `freeze_dried_container_model` is indeed a freeze drier that can hold the `freeze_dried_with_model`.
	FOREIGN KEY (
		freeze_dried_with_model,
		freeze_dried_container_model
	) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_freeze_dried_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_freeze_dried_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_freeze_dried_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_freeze_dried_container_model
	)
);
CREATE TABLE IF NOT EXISTS freeze_drying_procedures (
	-- Identifier of the freeze drying procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a freeze drying procedure template.
	procedure_template INTEGER NOT NULL REFERENCES freeze_drying_procedure_templates(procedure_template),
	-- The container that is being freeze dried, which must be a volumetric container.
	freeze_dried_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The container model that is being freeze dried, which must be a volumetric container model.
	freeze_dried_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The procedure template asset model associated to the `freeze_dried_container`.
	procedure_template_freeze_dried_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `freeze_dried_container`.
	procedure_freeze_dried_container UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The freeze drier used for the freeze drying procedure. This field is optional, as the freeze drier might not necessarily be tracked.
	freeze_dried_with UUID REFERENCES freeze_dryers(id),
	-- The model of the freeze drier used, which must be a freeze drier model.
	freeze_dried_with_model INTEGER NOT NULL REFERENCES freeze_dryer_models(id),
	-- The procedure template asset model associated to the `freeze_dried_with`.
	procedure_template_freeze_dried_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `freeze_dried_with`.
	procedure_freeze_dried_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the current `freeze_drying_procedures` has indeed the same `freeze_drying_procedures_template`.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- We enforce that the `freeze_dried_with` is indeed a weighing device of the correct model.
	FOREIGN KEY (freeze_dried_with, freeze_dried_with_model) REFERENCES assets(id, model),
	-- We enforce that the `procedure_template_freeze_dried_with_model` is the same as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_freeze_dried_with_model
	) REFERENCES freeze_drying_procedure_templates(
		procedure_template,
		procedure_template_freeze_dried_with_model
	),
	-- We enforce that the `procedure_template_freeze_dried_container_model` is the same as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_freeze_dried_container_model
	) REFERENCES freeze_drying_procedure_templates(
		procedure_template,
		procedure_template_freeze_dried_container_model
	),
	-- We enforce that the `procedure_freeze_dried_container` is associated with `procedure_template_freeze_dried_container_model`.
	FOREIGN KEY (
		procedure_freeze_dried_container,
		procedure_template_freeze_dried_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the `procedure_freeze_dried_with` is associated with `procedure_template_freeze_dried_with_model`.
	FOREIGN KEY (
		procedure_freeze_dried_with,
		procedure_template_freeze_dried_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- The compatibility rules between the freeze drier and the container being freeze dried must be respected.
	FOREIGN KEY (
		freeze_dried_with_model,
		freeze_dried_container_model
	) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We enforce that the `procedure_freeze_dried_container` is associated with the `freeze_dried_container_model`.
	FOREIGN KEY (
		procedure_freeze_dried_container,
		freeze_dried_container_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We enforce that the `procedure_freeze_dried_with` is associated with the `freeze_dried_with_model`.
	FOREIGN KEY (
		procedure_freeze_dried_with,
		freeze_dried_with_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We enforce that the `procedure_freeze_dried_container` is associated with the `freeze_dried_container`.
	FOREIGN KEY (
		procedure_freeze_dried_container,
		freeze_dried_container
	) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_freeze_dried_with` is associated with the `freeze_dried_with`.
	FOREIGN KEY (procedure_freeze_dried_with, freeze_dried_with) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS freezing_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The storage temperature in Kelvin.
	kelvin REAL NOT NULL DEFAULT 203.15 CHECK (must_be_strictly_positive_f32(kelvin)),
	-- Tolerance percentage for the storage temperature.
	kelvin_tolerance_percentage REAL NOT NULL DEFAULT 5.0 CHECK (
		must_be_strictly_positive_f32(kelvin_tolerance_percentage)
		AND must_be_smaller_than_f32(kelvin_tolerance_percentage, 100.0)
	),
	-- We use a default of 43200 seconds (12 hours) for the freezing procedure.
	seconds REAL DEFAULT 43200.0 CHECK (
		must_be_strictly_positive_f32(seconds)
		AND must_be_strictly_greater_than_f32(seconds, 1800.0)
	),
	-- The device used for freezing.
	frozen_with_model INTEGER NOT NULL REFERENCES freezer_models(id),
	procedure_template_frozen_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The container that is being stored in the freezer.
	frozen_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_frozen_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- We check that the `frozen_with_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_frozen_with_model,
		frozen_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `frozen_container_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_frozen_container_model,
		frozen_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `frozen_with_model` is indeed a container that can hold the `frozen_container_model`.
	FOREIGN KEY (frozen_with_model, frozen_container_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_frozen_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_frozen_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_frozen_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_frozen_container_model
	)
);
CREATE TABLE IF NOT EXISTS freezing_procedures (
	-- Identifier of the freezing procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a freezing procedure template.
	procedure_template INTEGER NOT NULL REFERENCES freezing_procedure_templates(procedure_template),
	-- The container that is being frozen, which must be a volumetric container.
	frozen_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The model of the container being frozen, which must be a container model.
	frozen_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The procedure template asset model associated to the `frozen_container`.
	procedure_template_frozen_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `frozen_container`.
	procedure_frozen_container UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The freezer used for the freezing procedure. This field is optional, as the freezer might not necessarily be tracked.
	frozen_with UUID REFERENCES freezers(id),
	-- The model of the freezer used, which must be a freezer model.
	frozen_with_model INTEGER NOT NULL REFERENCES freezer_models(id),
	-- The procedure template asset model associated to the `frozen_with_model`.
	procedure_template_frozen_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `frozen_with`.
	procedure_frozen_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the current `freezing_procedure_templates` has indeed the same `freezing_procedure_templates_template`.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_frozen_with_model` must be the same as in the `freezing_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_frozen_with_model
	) REFERENCES freezing_procedure_templates(
		procedure_template,
		procedure_template_frozen_with_model
	),
	-- The `procedure_template_frozen_container_model` must be the same as in the `freezing_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_frozen_container_model
	) REFERENCES freezing_procedure_templates(
		procedure_template,
		procedure_template_frozen_container_model
	),
	-- We check that the `frozen_with_model` is compatible with the `frozen_container_model`.
	FOREIGN KEY (frozen_with_model, frozen_container_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We ensure that the `procedure_frozen_container` is associated with the `procedure_template_frozen_container_model`.
	FOREIGN KEY (
		procedure_frozen_container,
		procedure_template_frozen_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We ensure that the `procedure_frozen_with` is associated with the `procedure_template_frozen_with_model`.
	FOREIGN KEY (
		procedure_frozen_with,
		procedure_template_frozen_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We ensure that the `procedure_frozen_container` is associated to the `frozen_container_model`.
	FOREIGN KEY (
		procedure_frozen_container,
		frozen_container_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We ensure that the `procedure_frozen_with` is associated to the `frozen_with_model`.
	FOREIGN KEY (procedure_frozen_with, frozen_with_model) REFERENCES procedure_assets(id, asset_model),
	-- We ensure that the `procedure_frozen_container` is associated to the `frozen_container`.
	FOREIGN KEY (procedure_frozen_container, frozen_container) REFERENCES procedure_assets(id, asset),
	-- We ensure that the `procedure_frozen_with` is associated to the `frozen_with`.
	FOREIGN KEY (procedure_frozen_with, frozen_with) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS fractioning_procedure_templates (
	-- Identifier of the fractioning procedure template, which is also a foreign key to the general procedure template.
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- Expected amount of the fraction to be collected in kilograms.
	kilograms REAL NOT NULL CHECK (must_be_strictly_positive_f32(kilograms)),
	-- The tolerance percentage of the fraction in kilograms.
	tolerance_percentage REAL NOT NULL CHECK (
		must_be_strictly_positive_f32(tolerance_percentage)
		AND must_be_smaller_than_f32(tolerance_percentage, 100.0)
	),
	-- The model of the scale used to measure the fraction in kilograms.
	weighed_with_model INTEGER NOT NULL REFERENCES weighing_device_models(id),
	-- The model of the instrument used for weighing should always be an asset model that is compatible with the procedure template.
	procedure_template_weighed_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- Source container model from which the fraction is taken.
	fragment_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_fragment_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- Destination container model to which the fraction is transferred.
	fragment_placed_into_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_fragment_placed_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- Foreign key to ensure that the `weighed_with_model` is indeed a weighing instrument.
	FOREIGN KEY (
		procedure_template_weighed_with_model,
		weighed_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We enforce that the `fragment_container_model` is indeed a procedure asset model.
	FOREIGN KEY (
		procedure_template_fragment_container_model,
		fragment_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_fragment_placed_into_model,
		fragment_placed_into_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_weighed_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_weighed_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_fragment_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_fragment_container_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_fragment_placed_into_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_fragment_placed_into_model
	)
);
CREATE TABLE IF NOT EXISTS fractioning_procedures (
	-- Identifier of the fractioning procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a fractioning procedure template.
	procedure_template INTEGER NOT NULL REFERENCES fractioning_procedure_templates(procedure_template),
	-- The source container from which the fraction is taken, which must be a volumetric container model.
	fragment_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `fragment_container`.
	procedure_template_fragment_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `fragment_container`.
	procedure_fragment_container UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The destination container to which the fraction is transferred, which must be a volumetric container model.
	fragment_placed_into UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `fragment_placed_into`.
	procedure_template_fragment_placed_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `fragment_placed_into`.
	procedure_fragment_placed_into UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The actual amount of the fraction collected in kilograms.
	kilograms REAL NOT NULL CHECK (must_be_strictly_positive_f32(kilograms)),
	-- The scale used to measure the fraction in kilograms. This field is optional, 
	-- as the weighing device might not necessarily be tracked.
	weighed_with UUID REFERENCES weighing_devices(id),
	-- The procedure template asset model associated to the `weighed_with_model`.
	procedure_template_weighed_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `weighed_with`.
	procedure_weighed_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the current `fractioning_procedures` has indeed the same `fractioning_procedures_template`.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- We enforce that the `procedure_template_weighed_with_model` is associated with the `procedure_template`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_weighed_with_model
	) REFERENCES fractioning_procedure_templates(
		procedure_template,
		procedure_template_weighed_with_model
	),
	-- We enforce that the `procedure_template_fragment_container_model` is associated with the `procedure_template`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_fragment_container_model
	) REFERENCES fractioning_procedure_templates(
		procedure_template,
		procedure_template_fragment_container_model
	),
	-- We enforce that the `procedure_template_fragment_placed_into_model` is associated with the `procedure_template`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_fragment_placed_into_model
	) REFERENCES fractioning_procedure_templates(
		procedure_template,
		procedure_template_fragment_placed_into_model
	),
	-- We enforce that the `procedure_fragment_container` is associated with the `fragment_container`.
	FOREIGN KEY (
		procedure_fragment_container,
		fragment_container
	) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_fragment_placed_into` is associated with the `fragment_placed_into`.
	FOREIGN KEY (
		procedure_fragment_placed_into,
		fragment_placed_into
	) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_weighed_with` is associated with the `weighed_with`.
	FOREIGN KEY (procedure_weighed_with, weighed_with) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_fragment_container` is associated with `procedure_template_fragment_container_model`.
	FOREIGN KEY (
		procedure_fragment_container,
		procedure_template_fragment_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the `procedure_fragment_placed_into` is associated with `procedure_template_fragment_placed_into_model`.
	FOREIGN KEY (
		procedure_fragment_placed_into,
		procedure_template_fragment_placed_into_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the `procedure_weighed_with` is associated with `procedure_template_weighed_with_model`.
	FOREIGN KEY (
		procedure_weighed_with,
		procedure_template_weighed_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model)
);CREATE TABLE IF NOT EXISTS centrifuge_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The storage temperature in Kelvin.
	kelvin REAL NOT NULL DEFAULT 293.15 CHECK (must_be_strictly_positive_f32(kelvin)),
	-- Tolerance percentage for the storage temperature.
	kelvin_tolerance_percentage REAL NOT NULL DEFAULT 1.0 CHECK (
		must_be_strictly_positive_f32(kelvin_tolerance_percentage)
		AND must_be_smaller_than_f32(kelvin_tolerance_percentage, 100.0)
	),
	-- The time in seconds that the centrifuge should be used for the procedure.
	seconds REAL NOT NULL DEFAULT 120.0 CHECK (
		must_be_greater_than_f32(seconds, 30.0)
		AND must_be_smaller_than_f32(seconds, 1800.0)
	),
	-- The RPMs (rotations per minute) of the centrifuge.
	rotation_per_minute REAL NOT NULL DEFAULT 13000.0 CHECK (
		must_be_greater_than_f32(rotation_per_minute, 5000.0)
		AND must_be_smaller_than_f32(rotation_per_minute, 30000.0)
	),
	-- The device used for the centrifuge procedure.
	centrifuged_with_model INTEGER NOT NULL REFERENCES centrifuge_models(id),
	procedure_template_centrifuged_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The container that is being centrifuged.
	centrifuged_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The centrifuged container model should allways be an asset model that is compatible with the procedure template.
	procedure_template_centrifuged_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- We check that the `centrifuged_with_model` is indeed a instrument that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_centrifuged_with_model,
		centrifuged_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `procedure_template_centrifuged_container_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_centrifuged_container_model,
		centrifuged_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `centrifuged_with_model` is indeed a container that can hold the `centrifuged_with_model`.
	CONSTRAINT centrifuge_pm_compatibility_rules FOREIGN KEY (
		centrifuged_with_model,
		centrifuged_container_model
	) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_centrifuged_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_centrifuged_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_centrifuged_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_centrifuged_container_model
	)
);
CREATE TABLE IF NOT EXISTS centrifuge_procedures (
	-- Identifier of the centrifuge procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- We enforce that the model of this procedure must be a centrifuge procedure template.
	procedure_template INTEGER NOT NULL REFERENCES centrifuge_procedure_templates(procedure_template),
	-- The container that is being centrifuged, which must be a volumetric container.
	centrifuged_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The model of the container that is being centrifuged.
	centrifuged_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The procedure template asset model associated to the `centrifuged_container`.
	procedure_template_centrifuged_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `centrifuged_container`.
	procedure_centrifuged_container UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The centrifuge model used for the centrifuge procedure.
	centrifuged_with_model INTEGER NOT NULL REFERENCES centrifuge_models(id),
	-- The centrifuge used for the procedure. This field is optional because the centrifuge
	-- might not have been recorded at the time of performing the procedure.
	centrifuged_with UUID REFERENCES centrifuges(id),
	-- The procedure template asset model associated to the `centrifuged_with_model`.
	procedure_template_centrifuged_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `centrifuged_with`.
	procedure_centrifuged_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is a centrifugating procedure.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- We enforce that the specified `centrifuged_with` is of the specified `centrifuged_with_model`.
	FOREIGN KEY (centrifuged_with, centrifuged_with_model) REFERENCES assets(id, model),
	-- The procedure template asset model describing the `centrifuged_container` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_centrifuged_container_model
	) REFERENCES centrifuge_procedure_templates(
		procedure_template,
		procedure_template_centrifuged_container_model
	),
	-- The procedure template asset model describing the `centrifuged_with_model` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_centrifuged_with_model
	) REFERENCES centrifuge_procedure_templates(
		procedure_template,
		procedure_template_centrifuged_with_model
	),
	-- We enforce that the specified `procedure_centrifuged_container` is of the specified `procedure_template_centrifuged_container_model`.
	FOREIGN KEY (
		procedure_centrifuged_container,
		procedure_template_centrifuged_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the specified `procedure_centrifuged_with` is of the specified `procedure_template_centrifuged_with_model`.
	FOREIGN KEY (
		procedure_centrifuged_with,
		procedure_template_centrifuged_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `centrifuged_with_model` is indeed a instrument that is compatible with the `centrifuged_container_model`.
	FOREIGN KEY (
		centrifuged_with_model,
		centrifuged_container_model
	) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We ensure that the `procedure_centrifuged_container` is associated with the `centrifuged_container_model`.
	FOREIGN KEY (
		procedure_centrifuged_container,
		centrifuged_container_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We ensure that the `procedure_centrifuged_container` is associated with the `centrifuged_container`.
	FOREIGN KEY (
		procedure_centrifuged_container,
		centrifuged_container
	) REFERENCES procedure_assets(id, asset),
	-- We ensure that the `procedure_centrifuged_with` is associated with the `centrifuged_container`.
	FOREIGN KEY (
		procedure_centrifuged_with,
		centrifuged_with_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We ensure that the `procedure_centrifuged_with` is associated with the `centrifuged_with`.
	FOREIGN KEY (procedure_centrifuged_with, centrifuged_with) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS ball_mill_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The storage temperature in Kelvin.
	kelvin REAL NOT NULL DEFAULT 293.15 CHECK (must_be_strictly_positive_f32(kelvin)),
	-- Tolerance percentage for the storage temperature.
	kelvin_tolerance_percentage REAL NOT NULL DEFAULT 1.0 CHECK (
		must_be_strictly_positive_f32(kelvin_tolerance_percentage)
		AND must_be_smaller_than_f32(kelvin_tolerance_percentage, 100.0)
	),
	-- By default, we set it to 150 seconds (2.5 minutes).
	seconds REAL NOT NULL DEFAULT 150.0 CHECK (
		must_be_strictly_smaller_than_f32(seconds, 900.0)
		AND must_be_strictly_greater_than_f32(seconds, 30.0)
	),
	-- The time in seconds that the ball mill should be used for the procedure.
	hertz REAL NOT NULL DEFAULT 25.0 CHECK (
		must_be_strictly_smaller_than_f32(hertz, 50.0)
		AND must_be_strictly_greater_than_f32(hertz, 15.0)
	),
	-- The beads model used for the procedure.
	bead_model INTEGER NOT NULL REFERENCES bead_models(id),
	procedure_template_bead_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	--- The number of beads used in the procedure.
	number_of_beads SMALLINT NOT NULL DEFAULT 3 CHECK (must_be_strictly_positive_i16(number_of_beads)),
	-- The device used for the ball mill procedure.
	milled_with_model INTEGER NOT NULL REFERENCES ball_mill_machine_models(id),
	procedure_template_milled_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The container that is being milled.
	milled_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_milled_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	FOREIGN KEY (procedure_template_bead_model, bead_model) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `milled_with` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_milled_with_model,
		milled_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `milled_container_model` is indeed a container that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_milled_container_model,
		milled_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `milled_with` is indeed a ball mill machine that can hold the `milled_container_model`.
	FOREIGN KEY (milled_with_model, milled_container_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We check that the `milled_with` is indeed a ball mill machine that can use the `bead_model`.
	FOREIGN KEY (milled_with_model, bead_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We check that the `bead_model` is indeed a beads model that can be used with the `milled_container_model`.
	FOREIGN KEY (bead_model, milled_container_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_bead_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_bead_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_milled_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_milled_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_milled_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_milled_container_model
	)
);
CREATE TABLE IF NOT EXISTS ball_mill_procedures (
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	procedure_template INTEGER NOT NULL REFERENCES ball_mill_procedure_templates(procedure_template),
	-- The beads model used for the procedure.
	bead_model INTEGER NOT NULL REFERENCES bead_models(id),
	-- The procedure template asset model associated to the `bead_model`.
	procedure_template_bead_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `bead_model`.
	procedure_bead UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The device used for the ball mill procedure.
	milled_with_model INTEGER NOT NULL REFERENCES ball_mill_machine_models(id),
	-- The procedure template asset model associated to the `milled_with_model`.
	procedure_template_milled_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `milled_with_model`.
	procedure_milled_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The ball mill machine used for the procedure. This field is optional because the ball mill
	-- machine might not have been recorded at the time of performing the procedure.
	milled_with UUID REFERENCES ball_mill_machines(id),
	-- The container that is being milled.
	milled_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The container model that is being milled.
	milled_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The procedure template asset model associated to the `milled_container`.
	procedure_template_milled_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `milled_container`.
	procedure_milled_container UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is a ball mill procedure without the possibility of a mistake.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The procedure template asset model describing the `bead_model` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_bead_model
	) REFERENCES ball_mill_procedure_templates(
		procedure_template,
		procedure_template_bead_model
	),
	-- The procedure template asset model describing the `milled_with_model` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_milled_with_model
	) REFERENCES ball_mill_procedure_templates(
		procedure_template,
		procedure_template_milled_with_model
	),
	-- The procedure template asset model describing the `milled_container_model` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_milled_container_model
	) REFERENCES ball_mill_procedure_templates(
		procedure_template,
		procedure_template_milled_container_model
	),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset model `bead_model`.
	FOREIGN KEY (procedure_bead, procedure_template_bead_model) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset model `milled_with_model`.
	FOREIGN KEY (
		procedure_milled_with,
		procedure_template_milled_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset model `milled_container_model`.
	FOREIGN KEY (
		procedure_milled_container,
		procedure_template_milled_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the `procedure_milled_container` procedure asset is indeed associated to the `milled_container_model`.
	FOREIGN KEY (
		procedure_milled_container,
		milled_container_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We enforce that the `procedure_milled_with` procedure asset is indeed associated to the `milled_with_model`.
	FOREIGN KEY (procedure_milled_with, milled_with_model) REFERENCES procedure_assets(id, asset_model),
	-- We enforce that the `procedure_milled_with` procedure asset is indeed associated to the `milled_with`.
	FOREIGN KEY (procedure_milled_with, milled_with) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_bead` procedure asset is indeed associated to the `bead_model`.
	FOREIGN KEY (procedure_bead, bead_model) REFERENCES procedure_assets(id, asset_model),
	-- We enforce that the `procedure_milled_container` procedure asset is indeed associated to the `milled_container`.
	FOREIGN KEY (procedure_milled_container, milled_container) REFERENCES procedure_assets(id, asset),
	-- We check that the `milled_with` is indeed a ball mill machine that can hold the `milled_container_model`.
	FOREIGN KEY (milled_with_model, milled_container_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We check that the `milled_with` is indeed a ball mill machine that can use the `bead_model`.
	FOREIGN KEY (milled_with_model, bead_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We check that the `bead_model` is indeed a beads model that can be used with the `milled_container_model`.
	FOREIGN KEY (bead_model, milled_container_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model)
);CREATE TABLE IF NOT EXISTS pouring_procedure_templates (
	-- Identifier of the pouring procedure template, which is also a foreign key to the general procedure template.
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The device model used to measure the liquid volume.
	measured_with_model INTEGER NOT NULL REFERENCES volume_measuring_device_models(id),
	-- The associated procedure asset model for the measuring device.
	procedure_template_measured_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The source container from which the liquid is poured.
	poured_from_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The associated procedure asset model for the source container. It may be associated
	-- to any type of other procedure templates (e.g., fractioning, packaging, etc.).
	procedure_template_poured_from_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The volumetric container into which the liquid is poured.
	poured_into_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The associated procedure asset model for the destination container. It is always associated
	-- to the same procedure template of this pouring procedure template.
	procedure_template_poured_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The amount of liquid that is poured into the container.
	liters REAL NOT NULL CHECK (must_be_strictly_positive_f32(liters)),
	-- The measuring device must match the procedure template of the procedure.
	FOREIGN KEY (
		procedure_template_measured_with_model,
		measured_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_poured_into_model,
		poured_into_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_poured_from_model,
		poured_from_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_measured_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_measured_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_poured_from_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_poured_from_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_poured_into_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_poured_into_model
	)
);
CREATE TABLE IF NOT EXISTS pouring_procedures (
	-- The extended `procedure`.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The procedure template of the extended `procedure`.
	procedure_template INTEGER NOT NULL REFERENCES pouring_procedure_templates(procedure_template),
	-- The container from which the liquid is poured.
	poured_from UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `poured_from`.
	procedure_template_poured_from_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `poured_from`.
	procedure_poured_from UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The actual measuring device (if known) used to measure the liquid volume.
	measured_with UUID REFERENCES volume_measuring_devices(id),
	-- The procedure template asset model associated to the `measured_with_model`.
	procedure_template_measured_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `measured_with`.
	procedure_measured_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The container into which the liquid is poured.
	poured_into UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `poured_into`.
	procedure_template_poured_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `poured_into`.
	procedure_poured_into UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is a packaging procedure.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_measured_with_model` must be the same as in the `pouring_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_measured_with_model
	) REFERENCES pouring_procedure_templates(
		procedure_template,
		procedure_template_measured_with_model
	),
	-- The `procedure_template_poured_from_model` must be the same as in the `pouring_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_poured_from_model
	) REFERENCES pouring_procedure_templates(
		procedure_template,
		procedure_template_poured_from_model
	),
	-- The `procedure_template_poured_into_model` must be the same as in the `pouring_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_poured_into_model
	) REFERENCES pouring_procedure_templates(
		procedure_template,
		procedure_template_poured_into_model
	),
	-- We check that the `procedure_poured_from` is associated to the `poured_from`.
	FOREIGN KEY (procedure_poured_from, poured_from) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_poured_into` is associated to the `poured_into`.
	FOREIGN KEY (procedure_poured_into, poured_into) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_poured_from` is indeed associated to the `procedure_template_poured_from_model`.
	FOREIGN KEY (
		procedure_poured_from,
		procedure_template_poured_from_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_measured_with` is indeed associated to the `procedure_template_measured_with_model`.
	FOREIGN KEY (
		procedure_measured_with,
		procedure_template_measured_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_poured_into` is indeed associated to the `procedure_template_poured_into_model`.
	FOREIGN KEY (
		procedure_poured_into,
		procedure_template_poured_into_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_measured_with` is associated to the `measured_with` asset (if any).
	FOREIGN KEY (procedure_measured_with, measured_with) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS aliquoting_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The amount of liters that should be aliquoted.
	liters REAL NOT NULL CHECK (must_be_strictly_positive_f32(liters)),
	-- Source container from which the aliquot is taken.
	aliquoted_from_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_aliquoted_from_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- Destination container to which the aliquot is transferred.
	aliquoted_into_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_aliquoted_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The device used for the aliquoting procedure.
	aliquoted_with_model INTEGER NOT NULL REFERENCES pipette_models(id),
	procedure_template_aliquoted_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The pipette tip to be mounted on the pipette.
	pipette_tip_model INTEGER NOT NULL REFERENCES pipette_tip_models(id),
	procedure_template_pipette_tip_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	FOREIGN KEY (
		procedure_template_aliquoted_with_model,
		aliquoted_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_pipette_tip_model,
		pipette_tip_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `aliquoted_with_model` is compatible with the `pipette_tip_model`.
	FOREIGN KEY (aliquoted_with_model, pipette_tip_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	FOREIGN KEY (
		procedure_template_aliquoted_from_model,
		aliquoted_from_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_aliquoted_into_model,
		aliquoted_into_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_aliquoted_from_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_aliquoted_from_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_aliquoted_into_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_aliquoted_into_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_aliquoted_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_aliquoted_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_pipette_tip_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_pipette_tip_model
	)
);
CREATE TABLE IF NOT EXISTS aliquoting_procedures (
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- We enforce that the model of this procedure must be an aliquoting procedure template.
	procedure_template INTEGER NOT NULL REFERENCES aliquoting_procedure_templates(procedure_template),
	-- The identifier of the instrument used for aliquoting.
	aliquoted_with UUID REFERENCES pipettes(id),
	-- The identifier of the instrument model used for aliquoting.
	aliquoted_with_model INTEGER NOT NULL REFERENCES pipette_models(id),
	-- The procedure template asset model associated to the `aliquoted_with`.
	procedure_template_aliquoted_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `aliquoted_with`.
	procedure_aliquoted_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The pipette tip model mounted on the pipette.
	pipette_tip_model INTEGER NOT NULL REFERENCES pipette_tip_models(id),
	-- The procedure template asset model associated to the `pipette_tip_model`.
	procedure_template_pipette_tip_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `pipette_tip_model`.
	procedure_pipette_tip UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The container being aliquoted, which must be a volumetric container model.
	aliquoted_from UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `aliquoted_from`.
	procedure_template_aliquoted_from_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `aliquoted_from`.
	procedure_aliquoted_from UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The container receiving the aliquot, which must be a volumetric container model.
	aliquoted_into UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `aliquoted_into`.
	procedure_template_aliquoted_into_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `aliquoted_into`.
	procedure_aliquoted_into UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is an aliquoting procedure without the possibility of a mistake.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The procedure template asset model describing the `aliquoted_with` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_aliquoted_with_model
	) REFERENCES aliquoting_procedure_templates(
		procedure_template,
		procedure_template_aliquoted_with_model
	),
	-- The procedure template asset model describing the `pipette_tip_model` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_pipette_tip_model
	) REFERENCES aliquoting_procedure_templates(
		procedure_template,
		procedure_template_pipette_tip_model
	),
	-- The procedure template asset model describing the `aliquoted_from` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_aliquoted_from_model
	) REFERENCES aliquoting_procedure_templates(
		procedure_template,
		procedure_template_aliquoted_from_model
	),
	-- The procedure template asset model describing the `aliquoted_into` must be the same one
	-- as the one in the procedure template.
	FOREIGN KEY (
		procedure_template,
		procedure_template_aliquoted_into_model
	) REFERENCES aliquoting_procedure_templates(
		procedure_template,
		procedure_template_aliquoted_into_model
	),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset `aliquoted_with`.
	FOREIGN KEY (
		procedure_aliquoted_with,
		procedure_template_aliquoted_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset model `pipette_tip_model`.
	FOREIGN KEY (
		procedure_pipette_tip,
		procedure_template_pipette_tip_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset `aliquoted_from`.
	FOREIGN KEY (
		procedure_aliquoted_from,
		procedure_template_aliquoted_from_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the procedure template asset model reported in the procedure is indeed
	-- the same one associated to the procedure asset for the asset `aliquoted_into`.
	FOREIGN KEY (
		procedure_aliquoted_into,
		procedure_template_aliquoted_into_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enfore that the `aliquoted_with_model` asset model is correctly associated to the `aliquoted_with` procedure asset.
	FOREIGN KEY (procedure_aliquoted_with, aliquoted_with_model) REFERENCES procedure_assets(id, asset_model),
	-- We enfore that the `aliquoted_with` asset is correctly associated to the `aliquoted_with` procedure asset.
	FOREIGN KEY (procedure_aliquoted_with, aliquoted_with) REFERENCES procedure_assets(id, asset),
	-- We enfore that the `aliquoted_from` asset is correctly associated to the `aliquoted_from` procedure asset.
	FOREIGN KEY (procedure_aliquoted_from, aliquoted_from) REFERENCES procedure_assets(id, asset),
	-- We enfore that the `aliquoted_into` asset is correctly associated to the `aliquoted_into` procedure asset.
	FOREIGN KEY (procedure_aliquoted_into, aliquoted_into) REFERENCES procedure_assets(id, asset),
	-- We enfore that the `pipette_tip_model` asset model is correctly associated to the `pipette_tip` procedure asset.
	FOREIGN KEY (procedure_pipette_tip, pipette_tip_model) REFERENCES procedure_assets(id, asset_model),
	-- We enfore that the `pipette_tip_model` is compatible with the `aliquoted_with_model`.
	FOREIGN KEY (aliquoted_with_model, pipette_tip_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model)
);CREATE TABLE IF NOT EXISTS supernatant_procedure_templates (
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The amount of liters that should be transferred
	liters REAL NOT NULL CHECK (must_be_strictly_positive_f32(liters)),
	-- The source container from which the supernatant is taken.
	stratified_source_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_stratified_source_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- Destination container to which the supernatant is transferred.
	supernatant_destination_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	procedure_template_supernatant_destination_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The device used for the aliquoting procedure.
	transferred_with_model INTEGER NOT NULL REFERENCES pipette_models(id),
	procedure_template_transferred_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The pipette tip to be mounted on the pipette.
	pipette_tip_model INTEGER NOT NULL REFERENCES pipette_tip_models(id),
	procedure_template_pipette_tip_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	FOREIGN KEY (
		procedure_template_transferred_with_model,
		transferred_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_pipette_tip_model,
		pipette_tip_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We check that the `transferred_with_model` is compatible with the `pipette_tip_model`.
	CONSTRAINT supernatant_pm_compatibility_rules FOREIGN KEY (transferred_with_model, pipette_tip_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model) ON DELETE CASCADE,
	FOREIGN KEY (
		procedure_template_stratified_source_model,
		stratified_source_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_supernatant_destination_model,
		supernatant_destination_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_stratified_source_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_stratified_source_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_supernatant_destination_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_supernatant_destination_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_transferred_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_transferred_with_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_pipette_tip_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_pipette_tip_model
	)
);
CREATE TABLE IF NOT EXISTS supernatant_procedures (
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- We enforce that the model of this procedure must be a supernatant procedure template.
	procedure_template INTEGER NOT NULL REFERENCES supernatant_procedure_templates(procedure_template),
	-- The source container from which the supernatant is taken.
	stratified_source UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `stratified_source`.
	procedure_template_stratified_source_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `stratified_source`.
	procedure_stratified_source UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The destination container to which the supernatant is transferred.
	supernatant_destination UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `supernatant_destination`.
	procedure_template_supernatant_destination_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `supernatant_destination`.
	procedure_supernatant_destination UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The device used for the aliquoting procedure.
	transferred_with UUID NOT NULL REFERENCES pipettes(id),
	-- The model of the device used for the aliquoting procedure.
	transferred_with_model INTEGER NOT NULL REFERENCES pipette_models(id),
	-- The procedure template asset model associated to the `transferred_with`.
	procedure_template_transferred_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `transferred_with`.
	procedure_transferred_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The pipette tip to be mounted on the pipette.
	pipette_tip_model INTEGER NOT NULL REFERENCES pipette_tip_models(id),
	-- The procedure template asset model associated to the `pipette_tip_model`.
	procedure_template_pipette_tip_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `pipette_tip_model`.
	procedure_pipette_tip UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is a supernatant procedure without the possibility of a mistake.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_stratified_source_model` must be the same as in the `supernatant_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_stratified_source_model
	) REFERENCES supernatant_procedure_templates(
		procedure_template,
		procedure_template_stratified_source_model
	),
	-- The `procedure_template_supernatant_destination_model` must be the same as in the `supernatant_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_supernatant_destination_model
	) REFERENCES supernatant_procedure_templates(
		procedure_template,
		procedure_template_supernatant_destination_model
	),
	-- The `procedure_template_transferred_with_model` must be the same as in the `supernatant_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_transferred_with_model
	) REFERENCES supernatant_procedure_templates(
		procedure_template,
		procedure_template_transferred_with_model
	),
	-- The `procedure_template_pipette_tip_model` must be the same as in the `supernatant_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_pipette_tip_model
	) REFERENCES supernatant_procedure_templates(
		procedure_template,
		procedure_template_pipette_tip_model
	),
	-- We check that the `procedure_stratified_source` is associated to the `stratified_source`.
	FOREIGN KEY (procedure_stratified_source, stratified_source) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_supernatant_destination` is associated to the `supernatant_destination`.
	FOREIGN KEY (
		procedure_supernatant_destination,
		supernatant_destination
	) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_transferred_with` is associated to the `transferred_with_model`.
	FOREIGN KEY (procedure_transferred_with, transferred_with) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_pipette_tip` is associated to the `pipette_tip_model`.
	FOREIGN KEY (procedure_pipette_tip, pipette_tip_model) REFERENCES procedure_assets(id, asset_model),
	-- We check that the `procedure_stratified_source` is indeed associated to the `procedure_template_stratified_source_model`.
	FOREIGN KEY (
		procedure_stratified_source,
		procedure_template_stratified_source_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_supernatant_destination` is indeed associated to the `procedure_template_supernatant_destination_model`.
	FOREIGN KEY (
		procedure_supernatant_destination,
		procedure_template_supernatant_destination_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_transferred_with` is indeed associated to the `procedure_template_transferred_with_model`.
	FOREIGN KEY (
		procedure_transferred_with,
		procedure_template_transferred_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_pipette_tip` is indeed associated to the `procedure_template_pipette_tip_model`.
	FOREIGN KEY (
		procedure_pipette_tip,
		procedure_template_pipette_tip_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `transferred_with_model` is compatible with the `pipette_tip_model`.
	FOREIGN KEY (transferred_with_model, pipette_tip_model) REFERENCES asset_compatibility_rules(left_asset_model, right_asset_model),
	-- We check that the `procedure_transferred_with` is associated to the `transferred_with_model`.
	FOREIGN KEY (
		procedure_transferred_with,
		transferred_with_model
	) REFERENCES procedure_assets(id, asset_model),
	-- We check that the `procedure_pipette_tip` is associated to the `pipette_tip_model`.
	FOREIGN KEY (procedure_pipette_tip, pipette_tip_model) REFERENCES procedure_assets(id, asset_model)
);CREATE TABLE IF NOT EXISTS weighing_procedure_templates (
	-- Identifier of the weighing procedure template, which is also a a foreign key to the general procedure template table.
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- The sample container model is the one that is being weighed.
	weighed_container_model INTEGER NOT NULL REFERENCES volumetric_container_models(id),
	-- The sample container model should always be an asset model that is compatible with the procedure template.
	procedure_template_weighed_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The model of the instrument to be used for weighing.
	weighed_with_model INTEGER NOT NULL REFERENCES weighing_device_models(id),
	-- The instrument model used for weighing should always be an asset model that is compatible with the procedure template.
	procedure_template_weighed_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- We check that the `weighed_with` is indeed an asset model that is compatible with the procedure template.
	FOREIGN KEY (
		procedure_template_weighed_with_model,
		weighed_with_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We enforce that the `weighed_container_model` is indeed a procedure asset model.
	FOREIGN KEY (
		procedure_template_weighed_container_model,
		weighed_container_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_weighed_container_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_weighed_container_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_weighed_with_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_weighed_with_model
	)
);
CREATE TABLE IF NOT EXISTS weighing_procedures(
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- We enforce that the model of this procedure must be a weighing procedure template.
	procedure_template INTEGER NOT NULL REFERENCES weighing_procedure_templates(procedure_template),
	-- The container being weighed, which must be a volumetric container model.
	weighed_container UUID NOT NULL REFERENCES volumetric_containers(id),
	-- The procedure template asset model associated to the `weighed_container`.
	procedure_template_weighed_container_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `weighed_container`.
	procedure_weighed_container UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The measured weight, which must be strictly positive.
	kilograms REAL NOT NULL CHECK (must_be_strictly_positive_f32(kilograms)),
	-- The weighing device used for weighing. This field is optional as there
	-- are several situations where the weighing device is not tracked.
	weighed_with UUID REFERENCES weighing_devices(id),
	-- The procedure template asset model associated to the `weighed_with_model`.
	procedure_template_weighed_with_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- The procedure asset associated to the `weighed_with_model`.
	procedure_weighed_with UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- We enforce that the extended `procedure` has indeed the same `procedure_template`, making
	-- sure that the procedure is a weighing procedure without the possibility of a mistake.
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- The `procedure_template_weighed_with_model` must be the same as in the `weighing_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_weighed_container_model
	) REFERENCES weighing_procedure_templates(
		procedure_template,
		procedure_template_weighed_container_model
	),
	-- The `procedure_template_weighed_container_model` must be the same as in the `weighing_procedure_templates`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_weighed_with_model
	) REFERENCES weighing_procedure_templates(
		procedure_template,
		procedure_template_weighed_with_model
	),
	-- We check that the `procedure_weighed_container` is associated to the `weighed_container`.
	FOREIGN KEY (procedure_weighed_container, weighed_container) REFERENCES procedure_assets(id, asset),
	-- We check that the `procedure_weighed_with` is associated to the `procedure_template_weighed_container_model`.
	FOREIGN KEY (
		procedure_weighed_container,
		procedure_template_weighed_container_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_weighed_with` is associated to the `procedure_template_weighed_with_model`.
	FOREIGN KEY (
		procedure_weighed_with,
		procedure_template_weighed_with_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We check that the `procedure_weighed_with` is associated to the `weighed_with` asset (if any).
	FOREIGN KEY (procedure_weighed_with, weighed_with) REFERENCES procedure_assets(id, asset)
);CREATE TABLE IF NOT EXISTS harvesting_procedure_templates (
	-- Identifier of the harvesting procedure template, which is also a foreign key to the general procedure template.
	procedure_template INTEGER PRIMARY KEY REFERENCES procedure_templates(procedure_template) ON DELETE CASCADE,
	-- Sample source model from which the sample is taken.
	sample_source_model INTEGER NOT NULL REFERENCES sample_source_models(id),
	procedure_template_sample_source_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- Sample model harvested from the sample source model.
	sample_model INTEGER NOT NULL REFERENCES sample_models(id),
	procedure_template_sample_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id) ON DELETE CASCADE,
	-- We enforce that the `sample_source_model` is indeed a procedure asset model.
	FOREIGN KEY (
		procedure_template_sample_source_model,
		sample_source_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	FOREIGN KEY (
		procedure_template_sample_model,
		sample_model
	) REFERENCES procedure_template_asset_models(id, asset_model),
	-- We enforce that the `sample_model` is associated with the `sample_source_model`.
	FOREIGN KEY (sample_model, sample_source_model) REFERENCES sample_models(id, sample_source_model),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_sample_source_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_sample_source_model
	),
	-- We create a unique index to allow for foreign keys checking that there exist a `procedure_template_sample_model`
	-- for the current `procedure_template`.
	UNIQUE (
		procedure_template,
		procedure_template_sample_model
	)
);

CREATE TABLE IF NOT EXISTS harvesting_procedures (
	-- Identifier of the harvesting procedure, which is also a foreign key to the general procedure.
	procedure UUID PRIMARY KEY REFERENCES procedures(procedure) ON DELETE CASCADE,
	-- The template of this procedure should be a harvesting procedure template.
	procedure_template INTEGER NOT NULL REFERENCES harvesting_procedure_templates(procedure_template),
	-- The sample source from which the sample is harvested, which must be a sample source asset.
	sample_source UUID NOT NULL REFERENCES sample_sources(id),
	-- The procedure template asset model associated to the `sample_source`.
	procedure_template_sample_source_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `sample_source`.
	procedure_sample_source UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	-- The sample harvetsed from the sample source, which must be a sample asset.
	sample UUID NOT NULL REFERENCES samples(id),
	-- The procedure template asset model associated to the `sample`.
	procedure_template_sample_model INTEGER NOT NULL REFERENCES procedure_template_asset_models(id),
	-- The procedure asset associated to the `sample`.
	procedure_sample UUID NOT NULL REFERENCES procedure_assets(id) ON DELETE CASCADE,
	FOREIGN KEY (procedure, procedure_template) REFERENCES procedures(procedure, procedure_template),
	-- We enforce that the `procedure_template_sample_source_model` is associated with the `procedure_template`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_sample_source_model
	) REFERENCES harvesting_procedure_templates(
		procedure_template,
		procedure_template_sample_source_model
	),
	-- We enforce that the `procedure_template_sample_model` is associated with the `procedure_template`.
	FOREIGN KEY (
		procedure_template,
		procedure_template_sample_model
	) REFERENCES harvesting_procedure_templates(
		procedure_template,
		procedure_template_sample_model
	),
	-- We enforce that the `procedure_sample_source` is associated with the `sample_source`.
	FOREIGN KEY (procedure_sample_source, sample_source) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_sample` is associated with the `sample`.
	FOREIGN KEY (procedure_sample, sample) REFERENCES procedure_assets(id, asset),
	-- We enforce that the `procedure_sample_source` is associated with `procedure_template_sample_source_model`.
	FOREIGN KEY (
		procedure_sample_source,
		procedure_template_sample_source_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model),
	-- We enforce that the `procedure_sample` is associated with `procedure_template_sample_model`.
	FOREIGN KEY (
		procedure_sample,
		procedure_template_sample_model
	) REFERENCES procedure_assets(id, procedure_template_asset_model)
);CREATE TABLE IF NOT EXISTS soil_models (
  id INTEGER PRIMARY KEY REFERENCES sample_source_models(id)
);
CREATE TABLE IF NOT EXISTS soils (
  id UUID PRIMARY KEY REFERENCES sample_sources(id),
  model INTEGER NOT NULL REFERENCES soil_models(id),
  FOREIGN KEY (id, model) REFERENCES assets(id, model)
);