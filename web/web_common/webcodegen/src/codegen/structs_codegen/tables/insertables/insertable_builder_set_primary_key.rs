//! Submodule implementing the `SetPrimaryKey` trait for the insertable
//! builder struct of a table.

use diesel::PgConnection;
use proc_macro2::TokenStream;
use syn::Ident;

use crate::{Table, errors::WebCodeGenError, traits::TableLike};

impl Table {
    pub(super) fn generate_insertable_builder_set_primary_key(
        &self,
        conn: &mut PgConnection,
    ) -> Result<TokenStream, WebCodeGenError> {
        let extension_tables = self.extension_tables(conn)?;

        let primary_key_type = self.primary_key_type(conn)?;
        let builder_ident = self.insertable_builder_ident()?;
        let extension_foreign_keys = self.extension_foreign_keys(conn)?;
        let generics = extension_tables
            .iter()
            .map(TableLike::struct_ident)
            .collect::<Result<Vec<Ident>, WebCodeGenError>>()?;
        let mut primary_key_assignments = extension_foreign_keys
            .iter()
            .map(|foreign_key| {
                let constraint_ident = foreign_key.constraint_ident(conn)?;
                Ok(quote::quote! {
                    self.#constraint_ident = self.#constraint_ident.set_primary_key(primary_key);
                })
            })
            .collect::<Result<Vec<TokenStream>, WebCodeGenError>>()?;

        let mut primary_key_retrievals = extension_foreign_keys
            .iter()
            .map(|foreign_key| {
                let constraint_ident = foreign_key.constraint_ident(conn)?;
                Ok(quote::quote! {
                    if let Some(primary_key) = self.#constraint_ident.primary_key() {
                        return Some(primary_key);
                    }
                })
            })
            .collect::<Result<Vec<TokenStream>, WebCodeGenError>>()?;

        // We identify whether we are in a table which has a primary key column which is
        // a UUID and is generated by the uuid_generate_v4() function.
        if let Some(uuid_primary_key) = self.has_uuid_primary_key(conn)? {
            let primary_key_ident = uuid_primary_key.snake_case_ident()?;
            primary_key_assignments.push(quote::quote! {
                self.#primary_key_ident = Some(primary_key);
            });
            primary_key_retrievals.push(quote::quote! {
                if let Some(primary_key) = self.#primary_key_ident {
                    return Some(primary_key);
                }
            });
        }

        let maybe_generics =
            if generics.is_empty() { None } else { Some(quote::quote! {<#(#generics),*>}) };
        let maybe_where_statement = if generics.is_empty() {
            None
        } else {
            Some(quote::quote! {
                where
                    #(#generics: web_common_traits::prelude::SetPrimaryKey<PrimaryKey = #primary_key_type>),*
            })
        };
        let maybe_mut =
            if primary_key_assignments.is_empty() { None } else { Some(quote::quote! {mut}) };
        let primary_key_ident = if primary_key_assignments.is_empty() {
            quote::quote! {_primary_key}
        } else {
            quote::quote! {primary_key}
        };

        Ok(quote::quote! {
            impl #maybe_generics web_common_traits::prelude::SetPrimaryKey for #builder_ident #maybe_generics #maybe_where_statement
            {
                type PrimaryKey = #primary_key_type;

                fn set_primary_key(#maybe_mut self, #primary_key_ident: Self::PrimaryKey) -> Self {
                    #(#primary_key_assignments)*
                    self
                }
            }
        })
    }
}
